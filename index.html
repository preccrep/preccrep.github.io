<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"preccrep.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="serial processing">
<meta property="og:type" content="website">
<meta property="og:title" content="Serial">
<meta property="og:url" content="https://preccrep.github.io/index.html">
<meta property="og:site_name" content="Serial">
<meta property="og:description" content="serial processing">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="preccrep">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://preccrep.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Serial</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Serial" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Serial</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">of or relating to the sequential performance of multiple operations</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">85</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/06/13/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">MIPS汇编语言编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-06-13 21:35:27 / Modified: 22:42:08" itemprop="dateCreated datePublished" datetime="2021-06-13T21:35:27+08:00">2021-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MIPS下各个寄存器编号及描述"><a href="#MIPS下各个寄存器编号及描述" class="headerlink" title="MIPS下各个寄存器编号及描述"></a>MIPS下各个寄存器编号及描述</h1><div class="table-container">
<table>
<thead>
<tr>
<th>寄存器编号</th>
<th>寄存器名</th>
<th>寄存器用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>zero</td>
<td>永远返回0</td>
</tr>
<tr>
<td>1</td>
<td>$at</td>
<td>汇编保留寄存器（不可用作其他用途）</td>
</tr>
<tr>
<td>2-3</td>
<td>$v0-$v1</td>
<td>(value的简写)存储表达式或者函数的返回值</td>
</tr>
<tr>
<td>4-7</td>
<td>$a0-$a3</td>
<td>(Argument简写)存储子程序的前4个参数，在子程序调用过程中释放</td>
</tr>
<tr>
<td>8-15</td>
<td>$t0-$t7</td>
<td>(temp简写)临时变量，同上调用时不保存</td>
</tr>
<tr>
<td>16-23</td>
<td>$s0-$s7</td>
<td>(Save or Static简写？)静态变量？调用时保存</td>
</tr>
<tr>
<td>24-25</td>
<td>$t8-$t9</td>
<td>(Temp简写)算是前面$0-$7的继续，属性同$t0-$t7</td>
</tr>
<tr>
<td>26-27</td>
<td>$k0-$k1</td>
<td>(break off简写?)中断函数返回值，不可做其他用途</td>
</tr>
<tr>
<td>28</td>
<td>gp\</td>
<td>(GlobalPointer简写)指向64k(gp\</td>
<td>(GlobalPointer简写)指向64k(2^{16}$)大小的静态数据块的中间地址</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>$sp</td>
<td>(Stack Pointer简写)栈指针，指向栈顶</td>
</tr>
<tr>
<td>30</td>
<td>$s8/$fp</td>
<td>(Save / Frame Pointer)帧指针</td>
</tr>
<tr>
<td>31</td>
<td>$ra</td>
<td>返回地址，目测不可用作其他用途</td>
</tr>
</tbody>
</table>
</div>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><p>数据声明 + 普通文本 + 程序编码（文件后缀是 .s 或 .asm）</p>
<p>数据声明在代码段之后（在之前也没什么问题）</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><ul>
<li>数据段以 <code>.data</code> 为开始标志</li>
<li>声明变量后，即在主存中分配空间</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li>代码段以 <code>.text</code> 为开始标志</li>
<li>各项指令操作</li>
<li>程序入口标志：<code>main:</code></li>
<li>程序结束标志</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>同C系语言。</p>
<p>基本模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Comment giving name of program and description of function</span><br><span class="line"># ...</span><br><span class="line"># Template.s</span><br><span class="line">		.data # variable declarations follow this line</span><br><span class="line">					# 数据变量声明</span><br><span class="line">					# ...</span><br><span class="line">		.text # instructions follow this line</span><br><span class="line">				# 代码段</span><br><span class="line">main:			# indicates start of code (first instruction to execute)</span><br><span class="line">					# 主程序</span><br><span class="line">					# ...</span><br><span class="line"></span><br><span class="line"># End of program, leave a blank line</span><br></pre></td></tr></table></figure>
<h1 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h1><p>声明的格式：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">变量名: 数据类型 变量值</span></span><br></pre></td></tr></table></figure>
<p>冒号不可缺少。</p>
<p>通常给变量赋一个初始值，对于 <code>.space</code>，要指明需要多少大小的空间(bytes)。</p>
<h1 id="加载-保存-指令集"><a href="#加载-保存-指令集" class="headerlink" title="加载/保存 指令集"></a>加载/保存 指令集</h1><ul>
<li>如果要访问内存，只能使用 <code>load/store</code> 指令</li>
<li>其他的只能是寄存器操作</li>
</ul>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><h3 id="lw"><a href="#lw" class="headerlink" title="lw"></a>lw</h3><p><code>lw register_dest, RAM_src</code></p>
<p>从内存中复制RAM_src的内容到对应的寄存器中(w即word，一个字长，4个字节，因此该数据大小为4个字节)</p>
<h3 id="lb"><a href="#lb" class="headerlink" title="lb"></a>lb</h3><p><code>lb register_dest, RAM_src</code></p>
<p>同上，lb为load byte.</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><h3 id="sw"><a href="#sw" class="headerlink" title="sw"></a>sw</h3><p><code>sw register_src, RAM_dest</code></p>
<p>指将指定寄存器中的数据写入到特定的内存中。</p>
<h2 id="sb"><a href="#sb" class="headerlink" title="sb"></a>sb</h2><p><code>sb register_src, RAM_dest</code></p>
<p>同上，但数据大小为1字节。</p>
<h2 id="load-imm"><a href="#load-imm" class="headerlink" title="load imm"></a>load imm</h2><h3 id="li"><a href="#li" class="headerlink" title="li"></a>li</h3><p><code>li register_dest, value</code></p>
<p>加载立即数。</p>
<h1 id="立即与间接寻址"><a href="#立即与间接寻址" class="headerlink" title="立即与间接寻址"></a>立即与间接寻址</h1><h2 id="la"><a href="#la" class="headerlink" title="la"></a>la</h2><p>Load address 直接给地址</p>
<p>例如，<code>la $t0, var1</code> 将 var1 (表示的是内存地址)放到 $t0 中。</p>
<p>如果变量var1不是内存地址，就成 <code>li</code> 指令了。</p>
<h2 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h2><p><code>lw</code>: 寄存器中存储的是内存地址，需要访问该内存地址得到数据再放到目的寄存器中。</p>
<p><code>lw $t2,($t0)</code> load word at RAM address contained in $t0 into $t2<br><code>sw $t2,($t0)</code> store word in register $t2 into RAM at address contained in $t0</p>
<h2 id="加偏移量"><a href="#加偏移量" class="headerlink" title="加偏移量"></a>加偏移量</h2><p><code>lw $t2,4($t0)</code> load word at RAM address ($t0+4) into register $t2, ”4” gives offset from address in register $t0<br><code>sw $t2,-12($t0)</code> store word in register $t2 into RAM at address ($t0 - 12),negative offsets are fine</p>
<h2 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h2><ul>
<li>最多3个操作数</li>
<li>操作数只能是寄存器，不允许出现地址</li>
<li>所有指令统一是32位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add $t0,$t1,$t2 # $t0 &#x3D; $t1 + $t2; add as signed (2&#39;s complement) integers</span><br><span class="line">sub $t2,$t3,$t4	#  $t2 &#x3D; $t3 - $t4</span><br><span class="line">addi    $t2,$t3, 5  #  $t2 &#x3D; $t3 + 5;   &quot;add immediate&quot; (no sub immediate)</span><br><span class="line">addu    $t1,$t6,$t7	#  $t1 &#x3D; $t6 + $t7;   add as unsigned integers</span><br><span class="line">subu    $t1,$t6,$t7	#  $t1 &#x3D; $t6 - $t7;   subtract as unsigned integers</span><br><span class="line">mult    $t3,$t4        #  multiply 32-bit quantities in $t3 and $t4, and store 64-bit</span><br><span class="line">                    #  result in special registers Lo and Hi:  (Hi,Lo) &#x3D; $t3 * $t4</span><br><span class="line">　　　　　　　　　　　　#　　　　　　　　　　　　　运算结果存储在hi,lo（hi高位数据， lo低位数据）</span><br><span class="line">div $t5,$t6        #  Lo &#x3D; $t5 &#x2F; $t6   (integer quotient)</span><br><span class="line">                    #  Hi &#x3D; $t5 mod $t6   (remainder)</span><br><span class="line">　　　　　　　　　　　　#　　　　　　　　　　　　　商数存放在 lo, 余数存放在 hi</span><br><span class="line">mfhi    $t0		#  move quantity in special register Hi to $t0:   $t0 &#x3D; Hi</span><br><span class="line">　　　　　　　　#　　　　　　　　　　　　　　　　  不能直接获取 hi 或 lo中的值， 需要mfhi, mflo指令传值给寄存器</span><br><span class="line">mflo    $t1		#  move quantity in special register Lo to $t1:   $t1 &#x3D; Lo</span><br><span class="line">                    #  used to get at result of product or quotient</span><br><span class="line"></span><br><span class="line">move    $t2,$t3    #  $t2 &#x3D; $t3</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="分支（if-else系列）"><a href="#分支（if-else系列）" class="headerlink" title="分支（if else系列）"></a>分支（if else系列）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b   target      #  unconditional branch to program label target</span><br><span class="line">beq $t0,$t1,target #  branch to target if  $t0 &#x3D; $t1</span><br><span class="line">blt $t0,$t1,target #  branch to target if  $t0 &lt; $t1</span><br><span class="line">ble $t0,$t1,target #  branch to target if  $t0 &lt;&#x3D; $t1</span><br><span class="line">bgt $t0,$t1,target #  branch to target if  $t0 &gt; $t1</span><br><span class="line">bge $t0,$t1,target #  branch to target if  $t0 &gt;&#x3D; $t1</span><br><span class="line">bne $t0,$t1,target #  branch to target if  $t0 &lt;&gt; $t1</span><br></pre></td></tr></table></figure>
<h2 id="跳转（while-for-goto系列）"><a href="#跳转（while-for-goto系列）" class="headerlink" title="跳转（while, for, goto系列）"></a>跳转（while, for, goto系列）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j   target  　　　　#  unconditional jump to program label target</span><br><span class="line">                   # 看到就跳， 不用考虑任何条件</span><br><span class="line">jr  $t3		#  jump to address contained in $t3 (&quot;jump register&quot;)</span><br><span class="line">　　　　　　#  类似相对寻址，跳到该寄存器给出的地址处</span><br></pre></td></tr></table></figure>
<h2 id="子程序调用"><a href="#子程序调用" class="headerlink" title="子程序调用"></a>子程序调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jal sun_label   # &quot;jump and link&quot;</span><br></pre></td></tr></table></figure>
<p>将当前程序计数器保存在 <code>$ra</code> 中，通过上面保存在 <code>$ra</code> 中的计数器返回到调用前。</p>
<p><strong>如果调用的子程序中有调用了其他的子程序，如此往复，则返回地址的标记就用栈来存储。</strong></p>
<h2 id="系统调用与输入-输出（主要针对SPIM模拟器）"><a href="#系统调用与输入-输出（主要针对SPIM模拟器）" class="headerlink" title="系统调用与输入/输出（主要针对SPIM模拟器）"></a>系统调用与输入/输出（主要针对SPIM模拟器）</h2><ul>
<li>使用syscall，以下指令应该是通用的。</li>
<li>参数使用的寄存器：<code>$v0, $a0, $a1</code>.</li>
<li>返回值使用：<code>$v0</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Service</th>
<th>Code in $v0 对应功能的调用码</th>
<th>Arguemnts 所需参数</th>
<th>Results 返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>打印一个整型</td>
<td>$v0=1</td>
<td>将要打印的整型赋值给$a0</td>
<td></td>
</tr>
<tr>
<td>打印一个浮点数</td>
<td>$v0=2</td>
<td>将要打印的浮点数赋值给$f12</td>
<td></td>
</tr>
<tr>
<td>打印双精度浮点数</td>
<td>$v0=3</td>
<td>将要打印的双精度浮点数赋值给$f12</td>
<td></td>
</tr>
<tr>
<td>打印字符串</td>
<td>$v0=4</td>
<td>将要打印的字符串的地址赋值给$a0</td>
<td></td>
</tr>
<tr>
<td>读取一个整型</td>
<td>$v0=5</td>
<td></td>
<td>将读取的整型赋值给$v0</td>
</tr>
<tr>
<td>读取浮点数</td>
<td>$v0=6</td>
<td></td>
<td>将读取的浮点数赋值给$v0</td>
</tr>
<tr>
<td>读取双精度浮点数</td>
<td>$v0=7</td>
<td></td>
<td>将读取的双精度浮点数赋值给$v0</td>
</tr>
<tr>
<td>读取字符串</td>
<td>$v0=8</td>
<td>将读取字符串地址赋值给$a0，将读取字符串的长度赋值给$a1</td>
<td></td>
</tr>
<tr>
<td>sbrk(应该同C中的sbrk()函数一样) 动态分配内存</td>
<td>$v0=9</td>
<td>$a0=amount 需要分配的空间大小，单位目测是字节</td>
<td>将分配好的空间首地址给$a0</td>
</tr>
<tr>
<td>退出</td>
<td>\v0=10</td>
<td>退出</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>打印的字符串应该有一个终止符(‘\0’)，声明字符串为 <code>.asciiz</code> 类型即可。</li>
<li>对于读取整型，浮点数，双精度浮点数等数据操作，系统会读取一整行（以’\n’为结束）</li>
<li>读取字符串时，输入过长就截短，短了不补，最后会加上终止符</li>
<li>The sbrk service returns the address to a block of memory containing n additional bytes. This would be used for dynamic memory allocation.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/06/13/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-13 17:32:30" itemprop="dateCreated datePublished" datetime="2021-06-13T17:32:30+08:00">2021-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/05/10/%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/" class="post-title-link" itemprop="url">约束与触发器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-10 19:33:19" itemprop="dateCreated datePublished" datetime="2021-05-10T19:33:19+08:00">2021-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-11 07:50:19" itemprop="dateModified" datetime="2021-05-11T07:50:19+08:00">2021-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h1><p>删除/更新具有引用关系的表时，有以下操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 被引用的行禁止删除</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联，被引用行删除时，引用行也一起删除；即子表里的行跟着父表里相应的行一起删除</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行删除时，引用行不做什么处理</span></span><br><span class="line"><span class="keyword">no</span> action</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行禁止更新</span></span><br><span class="line"><span class="keyword">on</span> update restrict</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行更新时，引用行自动更新</span></span><br><span class="line"><span class="keyword">on</span> update cascade</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id) <span class="keyword">on</span> <span class="keyword">delete</span> restrict,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id) <span class="keyword">on</span> <span class="keyword">delete</span> cascade,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>外键约束的几种方法：</p>
<p>方法1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_headers(</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    customer_id <span class="type">int</span>,</span><br><span class="line">    ship_to <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在创建表时，作为外键的列后面直接依赖父表列</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id),</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时，在末尾指定外键约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span>,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id),</span><br><span class="line">    <span class="keyword">foreign</span> key(so_id) <span class="keyword">references</span> so_headers(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 【注】：如果没有指定外键别名，则默认的外键别名为：&quot;表名_列名_fkey&quot;</span></span><br></pre></td></tr></table></figure>
<p>方法3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时，在末尾指定外键约束，并且指定外键别名；so_id_fkey</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span>,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id),</span><br><span class="line">    <span class="keyword">constraint</span> so_id_fkey <span class="keyword">foreign</span> key(so_id) <span class="keyword">references</span> so_headers(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个主键建立外键约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> child_table(</span><br><span class="line">    c1 <span class="type">int</span> primady key,</span><br><span class="line">    c2 <span class="type">int</span>,</span><br><span class="line">    c3 <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(c2,c3) <span class="keyword">references</span> 父表(p1,p2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>方法4：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键别名 <span class="keyword">foreign</span> key(列名) <span class="keyword">references</span> 父表(列名);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> 外键别名;</span><br></pre></td></tr></table></figure>
<h2 id="DEFERRABLE"><a href="#DEFERRABLE" class="headerlink" title="DEFERRABLE"></a>DEFERRABLE</h2><p>推迟约束</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器(trigger)是用户定义在关系表上的由事件驱动调用函数的机制。</p>
<p>触发器比CHECK更灵活，可以实施各种复杂的检查和操作，具有更精细和更强大的数据保护能力。</p>
<p>在创建触发器之前，必须首先创建触发器函数，触发器函数的语法格式是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> 变量声明;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	函数执行代码</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>触发器中有两对<script type="math/tex">，第一对</script>前是函数头部。触发器函数定义的头部RETURNS后面只能是TRIGGER，并且触发器函数不能带任何参数。</p>
<p>两对$$之间是函数体。包括DECLARE部分的变量声明以及BEGIN和END之间的函数执行代码。DECLARE部分是可选的。</p>
<p>由于PG允许使用各种语言比如PL/pgSQL，C，Python来编写函数，所以第二对$$之后是对函数编写语言的说明。这里是PL/pgSQL。</p>
<p>触发器函数创建后，使用<code>CREATE TRIGGER</code>命令创建触发器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER name &#123;BEFORE|AFTER&#125; &#123;event [OR...]&#125;</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> YYY</span><br><span class="line">[FOR [EACH] &#123;ROW|STATEMENT&#125;]</span><br><span class="line">[WHEN &#123;condition&#125;]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name();</span><br></pre></td></tr></table></figure>
<p>{event [OR…]}中，{}里面是一个或多个用OR分隔的事件列表。这里的事件包括数据库的数据修改操作，比如INSERT、DELETE或UPDATE等命令。</p>
<p>BEFORE|AFTER的意思是触发器可以分为BEFORE和AFTER触发器，分别在操作完成前和操作完成后执行触发器函数。</p>
<p>ON TABLE后面给出触发器所在表的表名。</p>
<p>触发器可以按行或按语句触发，也就是行级触发器和语句级触发器。</p>
<p>行级：<code>[FOR [EACH] &#123;ROW|STATEMENT&#125;]</code></p>
<p>语句级：<code>[FOR [EACH] &#123;STATEMENT&#125;]</code></p>
<p>行级触发器的触发器函数为触发语句影响的每一行执行一次。</p>
<p>语句级触发器的触发器函数为每条触发语句执行一次。</p>
<p>假设表examiner有10000行，定义了如下的UPDATE触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE examiner <span class="keyword">SET</span> erage <span class="operator">=</span> erage <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果是语句级触发器，则执行完该语句后，触发动作只发生1次；如果是行级触发器，则执行10000次。</p>
<p>触发器必须返回一个NULL或者一个元组类型的变量。</p>
<p>语句级触发器应返回NULL。</p>
<p>行级after触发器的值总是被忽略，可以返回null。</p>
<p>行级before触发器的返回值不同，对触发器操作的影响也不同。</p>
<p>如果返回NULL则忽略该触发器的行级操作，其后的触发器也不会执行。</p>
<p>如果返回非NULL，则返回的行将成为被插入或更新的行。</p>
<p>如果是行级触发器，可以在触发器函数中使用NEW和OLD引用UPDATE/INSERT事件之后的新值和UPDATE/DELETE事件之前的旧值。</p>
<p>插入examinee表的考号长度必须为10位：</p>
<p>创建触发器函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> examineeid() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $examineeid$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	IF(<span class="keyword">CHAR_LENGTH</span>(new.eeid)<span class="operator">&lt;&gt;</span><span class="number">10</span>) <span class="keyword">THEN</span></span><br><span class="line">		RAISE EXCEPTION <span class="string">&#x27;格式错误&#x27;</span>;</span><br><span class="line">		<span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line">	<span class="keyword">ELSE</span></span><br><span class="line">		<span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$examinee$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<p>NEW代表INSERT或UPDATE操作产生的新的数据行</p>
<p>创建触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> examineeid_insert BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> examinee</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> examineeid();</span><br></pre></td></tr></table></figure>
<p>三种：</p>
<p>1.DEFERRABLE INITIALLY DEFERRED</p>
<p>2.DEFERRABLE INITIALLY IMMEDIATE</p>
<p>3.NOT DEFERRABLE</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span>&quot;subject_iddddd&quot; <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> &quot;Subjects&quot; (&quot;id&quot;) DEFERRABLE INITIALLY IMMEDIATE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注1：<strong><code>IMMEDIATE</code> 会在每一个语句执行后进行约束检查，<code>DEFERRED</code> 则只会在事务结束时才检查约束。（DEFERRED 只是推迟检查而不是不检查）</strong></p>
<p>注2：此设置仅影响 <strong>UNIQUE，PRIMARY KEY，REFERENCES （外键）和 EXCLUDE 约束</strong></p>
</blockquote>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET CONSTRAINTS &#123; <span class="built_in">ALL</span> | <span class="keyword">name</span> [, ...] &#125; &#123; <span class="keyword">DEFERRED</span> | IMMEDIATE &#125;</span><br></pre></td></tr></table></figure>
<p>注1：<strong>对 <code>NOT DEFERRABLE</code> 来说，<code>SET CONSTRAINTS</code> 不生效。</strong></p>
<p>注2：<code>SET CONSTRAINTS ALL</code> 更改所有 DEFERRABLE 约束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/05/09/%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-09 18:43:29" itemprop="dateCreated datePublished" datetime="2021-05-09T18:43:29+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-23 01:11:57" itemprop="dateModified" datetime="2021-05-23T01:11:57+08:00">2021-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h1><p>从发送主机向接收主机传送数据段</p>
<p>发送主机：将数据段封装到数据报中。</p>
<p>接收主机：向传输层交付数据段。</p>
<p>每个主机和路由器都运行网络层协议。</p>
<p>路由器检验所有穿越它的IP数据报的头部域。</p>
<h2 id="网络层核心功能"><a href="#网络层核心功能" class="headerlink" title="网络层核心功能"></a>网络层核心功能</h2><h3 id="转发与路由"><a href="#转发与路由" class="headerlink" title="转发与路由"></a>转发与路由</h3><p>转发(forwarding)：将分组从路由器的输入端口转移到合适的输出端口。</p>
<blockquote>
<p>每个路由器维护一张转发表，转发表确定本路由器如何转发分组。</p>
<p>转发表的内容：地址-输出链路，如0100-3, 0101-2, 0111-2, 1001-1.</p>
<p>取出收到的数据报的地址信息，然后查转发表得到输出链路。</p>
</blockquote>
<p>路由(routing)：确定分组从源到目的经过的路径。</p>
<p><strong>如何得到路由信息？</strong></p>
<p>网络层设备都会运行一些路由协议，或路由算法(routing algorithms)，根据路由算法确定通过网络的端到端路径。</p>
<h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p>数据分组传输之前两端主机需要首先建立虚拟/逻辑连接，网络设备（如路由器）参与连接的建立。</p>
<p>网络层连接与传输层连接的对比：</p>
<ul>
<li>网络层连接：两个主机之间的连接，并且在路径上的每个网络层设备都要参与建立连接。</li>
<li>传输层连接：两个应用进程之间的连接（端到端的连接，对中间网络设备透明）。</li>
</ul>
<blockquote>
<p><strong>网络层为发送端（主机）到接收端（主机）的数据报传送”通道(channel)”提供怎样的服务模型(service model)？</strong></p>
<p>不同的网络架构(Network Architecture)提供的服务模型是不一样的。例如Internet提供的是best effort服务模型，不保障Bandwidth, Loss, Order或Timing，通过数据是否丢失来判断拥塞(congestion)。ATM的服务模型有CBR，VBR，ABR，UBR。</p>
</blockquote>
<p><strong>网络层服务模型</strong></p>
<ul>
<li>无连接服务(connection-less service)：<ul>
<li>不事先为系列分组的传输确定传输路径</li>
<li>每个分组独立确定传输路径</li>
<li>不同分组可能传输路径不同</li>
<li>数据报网络(datagram network)</li>
</ul>
</li>
<li>连接服务(connection service)：<ul>
<li>首先为系列分组的传输确定从源到目的经过的路径（建立连接）</li>
<li>然后沿该路径（连接）传输系列分组</li>
<li>系列分组传输路径相同</li>
<li>分组传输顺序可以保证</li>
<li>传输结束后拆除连接</li>
<li>虚电路网络(virtual-circuit network)</li>
</ul>
</li>
</ul>
<h1 id="虚电路网络和数据报网络"><a href="#虚电路网络和数据报网络" class="headerlink" title="虚电路网络和数据报网络"></a>虚电路网络和数据报网络</h1><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>数据报网络和虚电路网络是典型的两类<strong>分组交换网络</strong>。</p>
<p>数据报网络提供网络层无连接服务。</p>
<p>虚电路网络提供网络层连接服务。</p>
<p>类似于传输层的无连接服务（UDP）和面向连接服务（TCP），但是网络层服务：</p>
<ol>
<li>是主机到主机的服务</li>
<li>网络核心实现（传输层是端到端实现）</li>
</ol>
<p>虚电路：一条从源主机到目的主机，类似于电路的路径（逻辑连接）。</p>
<ul>
<li>分组交换</li>
<li>每个分组的传输利用链路的全部带宽</li>
<li><p>源到目的路径经过的网络层设备共同完成虚电路功能</p>
</li>
<li><p>通信过程：呼叫建立(call setup)——数据传输——拆除呼叫</p>
</li>
<li>每个分组携带虚电路标识(VCID)，而不是目的主机地址</li>
<li>虚电路经过的每个网络设备（如路由器），都要维护每条经过它的虚电路的连接状态</li>
<li>链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配<ul>
<li>预分配资源 = 可预期服务性能</li>
<li>如ATM的电路仿真(CBR)</li>
</ul>
</li>
</ul>
<p>每条虚电路包括：</p>
<ol>
<li><p>从源主机到目的主机到一条路径</p>
</li>
<li><p>虚电路号(VCID)，沿路每段链路一个编号</p>
<blockquote>
<p>链路带宽越大，允许建立的虚电路的数量就越大。</p>
<p>同一条虚电路在每一段链路上的VCID可能是不一样的。</p>
</blockquote>
</li>
<li><p>沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路。</p>
</li>
</ol>
<p>沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址。</p>
<p>同一条VC，在每段链路上的VCID通常不同：</p>
<ul>
<li>路由器转发分组时依据转发表改写/替换虚电路号</li>
</ul>
<p><strong>虚电路信令协议(signaling protocols)</strong></p>
<p>用于VC的建立、维护与拆除：路径选择</p>
<p>应用于虚电路网络：如ATM、帧中继(frame-relay)网络等</p>
<p>目前的Internet不采用。</p>
<p>初识呼叫——呼叫到达——接受呼叫——呼叫建立——数据流开始——接收数据</p>
<p>通信结束后，也通过虚电路信令协议进行呼叫的拆除。</p>
<h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>网络层无连接</p>
<p>每个分组携带目的地址</p>
<p>路由器根据分组的目的地址转发分组：</p>
<ul>
<li>基于路由协议/算法构建转发表</li>
<li>检索转发表</li>
<li>每个分组独立选路</li>
<li>每个分组走的路径可能不一样，因为如果在传输过程中路由器更新了转发表，那么后面的分组就会走新的路径</li>
</ul>
<p>数据报中含有目的主机的IP地址。但是IP地址是32位的二进制数，一共有2^32种不同情况，严重降低了传输效率。解决方法是：转发表中的目的地址不是一个明确的地址，而是一个地址范围。这样就将许多具有共同列表地址的转发表进行了聚合。</p>
<p>目的地址范围的匹配采用<strong>最长前缀匹配优先</strong>（在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口[entry]）。</p>
<p><strong>Internet（数据报网络）</strong></p>
<ul>
<li>计算机之间的数据交换：”弹性”服务，没有严格时间需求。</li>
<li>链路类型众多：特点、性能各异，统一服务困难。</li>
<li>“智能”端系统：可以自适应、性能控制、差错恢复</li>
<li>简化网络，复杂”边缘”</li>
</ul>
<p><strong>ATM（VC网络）</strong></p>
<ul>
<li>电话网络演化而来</li>
<li>核心业务是实时对话：严格的时间、可靠性需求，需要有保障的服务。</li>
<li>“哑”端系统（非智能）：电话机、传真机</li>
<li>简化”边缘”，复杂网络</li>
</ul>
<h1 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h1><h2 id="Internet网络层"><a href="#Internet网络层" class="headerlink" title="Internet网络层"></a>Internet网络层</h2><p>主要功能就是路由和转发。</p>
<p>主机、路由器网络层主要功能：</p>
<ul>
<li>路由协议：路径选择，如RIP，OSPF，BGP</li>
<li>转发表（路由表）</li>
<li>IP协议：寻址规约(conventions)，数据报（分组）格式，分组处理规约</li>
<li>ICMP协议（互联网控制报文协议）：差错报告，路由器”信令协议”</li>
<li>实现IP协议，通常也要实现ICMP协议。后者可以看做是前者的一个伴随协议。</li>
</ul>
<h2 id="IP数据报（分组）格式"><a href="#IP数据报（分组）格式" class="headerlink" title="IP数据报（分组）格式"></a>IP数据报（分组）格式</h2><p>IP数据报格式：首部 + 数据(e.g. TCP, UDP段)</p>
<p>数据报长度是32位，即从0到31位。</p>
<blockquote>
<p>首部（固定部分5行、可变部分1行）</p>
<p>数据（1行）</p>
</blockquote>
<p>首部分为固定部分和可变部分。</p>
<p>固定部分：</p>
<p>版本号(4位，0~3)，首部长度，服务类型(TOS)，总长度</p>
<p>标识，标识位，片偏移</p>
<p>生存时间(TTL)，协议，首部检验和</p>
<p>源IP地址</p>
<p>目的IP地址</p>
<p>可变部分：</p>
<p>选项字段（长度可变），填充</p>
<ol>
<li><p>版本号：4位，如果是IPv4就是4，如果是IPv6就是6。</p>
</li>
<li><p>首部长度：4位。是IP分组的首部长度。</p>
<ul>
<li>以4字节为单位（1行32比特，刚好4字节）</li>
<li>IP固定部分首部长度为5*4=20字节</li>
<li>最典型的，例如是IPv4协议，那么版本号是0100(4d)，首部长度0101(5d)。</li>
</ul>
</li>
<li>服务类型(TOS)：8位，指示期望获得哪种类型的服务。<ul>
<li>1998年这个字段改名为<em>区分服务</em></li>
<li>只有在网络提供区分服务(DiffServ)时使用</li>
<li>一般情况下不使用，通常IP分组的该字段（第2字节）的值为00H</li>
</ul>
</li>
<li>总长度：16位，是IP分组的总字节数（首部+数据）<ul>
<li>最大IP分组的总长度：65535B</li>
<li>最小的IP分组首部：20B（可变部分为0）</li>
<li>IP分组可以封装的最大数据：65535-20=65515B</li>
<li>当然在实际中不会达到最大数据，因为一定会将它切分的。</li>
</ul>
</li>
<li>生存时间(TTL)：8位，是IP分组在网络中可以通过的路由器数（或跳步数）<ul>
<li>路由器转发一次分组，TTL减一</li>
<li>如果TTL=0，则路由器丢弃该IP分组</li>
</ul>
</li>
<li>协议：8位，指示IP分组封装的是哪个协议的数据包<ul>
<li>实现复用/分解</li>
<li>6为TCP，表示封装的是TCP段；17为UDP，表示封装的是UDP数据报</li>
</ul>
</li>
<li>首部校验和：16位，实现对IP分组首部的差错检测<ul>
<li>计算校验和时，该字段置为全0</li>
<li>采用反码算数运算求和，和的反码作为首部校验和字段</li>
<li>逐跳计算、逐跳检验</li>
</ul>
</li>
<li>源IP地址、目的IP地址字段各占32位</li>
</ol>
<h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>网络链路存在MTU（最大传输单元）——链路层数据可封装数据的上限。不同链路的MTU不同。</p>
<p>大IP分组向较小MTU链路转发时，可以被”分片”(fragmented)。</p>
<p>IP分片到达目的主机后进行”重组”(reassembled)。</p>
<p>路由器对IP分组只分片不重组。</p>
<p>如果此路由器不让分片，那么就把这个IP分组丢掉，一般地会再发一个ICMP的分组（具体是怎样再查查，这里只是粗略记录）。</p>
<p>IP首部中的总长度、标识、标识位和片偏移用来标识分片以及确定分片的相对顺序。</p>
<p>标识字段：16位，用于标识一个IP分组</p>
<ul>
<li>IP协议利用一个计数器，每产生一个IP分组，计数器就加一，利用此时计数器的值和其他一些信息唯一标识该IP分组</li>
</ul>
<p>标识位：3位</p>
<h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p>接口：主机/路由器与物理链路的连接</p>
<ul>
<li>实现网络层功能</li>
<li>路由器通常有多个接口</li>
<li>主机通常只有一个或两个接口（有线的以太网接口，无限的802.11接口）</li>
</ul>
<p>IP地址：32比特(IPv4)编号用于标识主机、路由器的<strong>接口</strong></p>
<p>一般用点分十进制的方式表示。</p>
<p>11011111 00000001 00000001 00000001 = 233.1.1.1</p>
<p>一个IP地址唯一标识一个接口。</p>
<p>IP地址与每个接口关联。</p>
<h3 id="IP子网-subnets"><a href="#IP子网-subnets" class="headerlink" title="IP子网(subnets)"></a>IP子网(subnets)</h3><p>IP地址：</p>
<ul>
<li>网络号(NetID) - 高位比特</li>
<li>主机号(HostID) - 低位比特</li>
</ul>
<p>NetID           HostID</p>
<p>233.1.1        .1</p>
<p>相同的网络号构成IP子网。</p>
<p>IP子网：</p>
<ul>
<li>IP地址具有相同网络号的设备接口</li>
<li><strong>不跨越路由器</strong>（第三及以上层网络设备）可以彼此<strong>物理联通</strong>的接口</li>
</ul>
<p>“有类”编址：</p>
<p>A类地址，50%：NetID(8位) + HostID(24位)</p>
<p>0.0.0.0 ~ 127.255.255.255</p>
<p>B类地址，25%：NetID(16位) + HostID(16位)</p>
<p>128.0.0.1 ~ 191.255.255.255</p>
<p>C类地址，12.5%：NetID(24位) + HostID(8位)</p>
<p>192.0.0.0 ~ 223.255.255.255</p>
<p>D类地址，6.25%：32位，1110</p>
<p>224.0.0.0～239.255.255.255</p>
<p>E类地址，6.25%：32位，1111</p>
<p>240.0.0.0～255.255.255.255</p>
<h2 id="IP子网划分与子网掩码"><a href="#IP子网划分与子网掩码" class="headerlink" title="IP子网划分与子网掩码"></a>IP子网划分与子网掩码</h2><p>子网划分：</p>
<p>IP地址——网络号(NetID) + 子网号(SubID) + 主机号(HostID)</p>
<p>就是将刚才的主机号划分为了：子网号(SubID) + 主机号(HostID)。即 子网号是原主机号的部分比特。</p>
<p>子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台主机，它们处于同一广播域。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。可以把基于每类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址，子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。</p>
<p>比如，当一组IP地址指定给一个公司时，公司可能将该网络“分割成”小的网络，每个部门一个。这样，技术部门和管理部门都可以有属于它们的小网络。通过划分子网，我们可以按照我们的需要将网络分割成小网络。这样也有助于降低流量和隐藏网络的复杂性。</p>
<p>子网掩码：</p>
<p>形如IP地址：32位，点分十进制形式</p>
<p>取值：NetID, SubID位全取1，HostID全取0</p>
<p>例如：</p>
<p>A网的默认子网掩码为：255.0.0.0</p>
<p>B网的默认子网掩码为：255.255.0.0</p>
<p>C网的默认子网掩码为：255.255.255.0</p>
<p>借用3比特划分子网的B网的子网掩码为：255.255.224.0 （224就是11100000）</p>
<p><strong>子网地址+子网掩码</strong> —— 准确确定子网大小</p>
<p>将IP分组的目的IP地址与子网掩码<strong>按位与</strong>运算，提取子网地址。</p>
<h1 id="CIDR与路由聚集"><a href="#CIDR与路由聚集" class="headerlink" title="CIDR与路由聚集"></a>CIDR与路由聚集</h1><p>无类域间路由(CIDR: Classless InterDomain Routing)</p>
<ul>
<li><p>消除传统的A、B、C类地址界限：将NetID和SubID合在一起变成Network Prefix(Prefix)，即统称为网络前缀，并且可以任意长度</p>
</li>
<li><p>融合子网地址与子网掩码，方便子网划分</p>
<p>无类地址格式：a.b.c.d/x，其中x为前缀长度</p>
</li>
</ul>
<p>11001000 00010111 0001000<strong>0 00000000</strong></p>
<p>前面是前缀（长为8+8+7=23），后面是主机号HostID。</p>
<p>写成CIDR地址形式就是200.23.16.0/23。</p>
<p><strong>优势</strong></p>
<ul>
<li>提高IPv4地址空间分配效率</li>
<li>提高路由效率<ul>
<li>将多个子网聚合为一个较大的子网</li>
<li>构成超网</li>
<li>路由聚合(route aggregation)</li>
</ul>
</li>
</ul>
<h1 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h1><p>如何获得IP地址？</p>
<ul>
<li><p>“硬编码”：静态配置</p>
</li>
<li><p>动态主机配置协议 - DHCP：Dynamic Host Configuration Protocol</p>
<p>从服务器动态获取：IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址</p>
<p>“即插即用”</p>
<p>允许地址重用</p>
<p>支持在用地址续租</p>
<p>支持移动用户加入网络</p>
</li>
</ul>
<p><strong>动态主机配置协议DHCP</strong></p>
<ol>
<li>主机广播”DHCP discover”（发现报文）等待是否有DHCP服务器响应</li>
<li>DHCP服务器利用”DHCP offer”（提供报文）进行响应，告诉客户端自己可以提供的一个IP地址</li>
<li>主机请求IP地址：客户端向服务器发送”DHCP request”（请求报文）表示愿意接受这个IP地址同时请求服务器将它真正分配给自己</li>
<li>DHCP服务器分配IP地址：服务器向客户端发送”DHCP ack”（确认报文）表示确认分配</li>
</ol>
<p>DHCP协议在应用层实现：</p>
<ul>
<li>请求报文封装到UDP数据报中</li>
<li>IP广播</li>
<li>链路层广播（例如，以太网广播）</li>
</ul>
<p>DCHP服务器内建于服务器中。</p>
<p>DHCP服务器构造ACK报文，包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址。</p>
<h1 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h1><p>本地网络内通信的IP数据报的源与目的IP地址均在子网10.0.0/24（显然这是一个私有地址，比如说是家庭网络）内。</p>
<p>所有离开本地网络去往Internet的数据报的源IP地址需要替换为相同的NAT IP地址（例如138.76.29.7）以及不同的端口号。</p>
<p>动机：</p>
<ul>
<li>只需从ISP申请一个IP地址，因此面临IPv4地址耗尽</li>
<li>本地网络设备IP地址的变更，无需通告外界网络</li>
<li>变更ISP时，无需修改内部网络设备IP地址</li>
<li>内部网络设备对外界网络不可见，即不可直接寻址</li>
</ul>
<p>实现：</p>
<ul>
<li>替换：利用(NAT IP地址，新端口号)替换每个外出IP数据报的(源IP地址，源端口号)</li>
<li>记录：将每对(NAT IP地址，新端口号)与(源IP地址，源端口号)的替换信息存储到NAT转换表中</li>
<li>根据NAT转换表，用(源IP地址，源端口号)替换每个进入内网IP数据报的(目的IP地址，目的端口号)</li>
</ul>
<p>NAT转换表包含：WAN端地址、LAN端地址。</p>
<p>NAT穿透问题：外部设备期望连接内网地址的服务器</p>
<p>方法1: 静态配置NAT（转换表），将特定端口的连接请求转发给服务器。</p>
<p>方法2: 利用UPnP(Universal Plug and Play)互联网网关设备协议(IGD-Internet Gateway Device)自动配置：学习到NAT公共IP地址，在NAT转换表中增删端口映射。</p>
<p>方法3: 中继(如Skype)</p>
<h1 id="互联网控制报文协议ICMP"><a href="#互联网控制报文协议ICMP" class="headerlink" title="互联网控制报文协议ICMP"></a>互联网控制报文协议ICMP</h1><p>Internet Control Message Protocol支持主机或路由器</p>
<p>差错或异常报告</p>
<p>网络探询</p>
<p>两类ICMP报文：</p>
<p>差错报文</p>
<h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>最初动机：32位IPv4地址空间已分配殆尽</p>
<p>其他动机：改进首部格式：快速处理/转发数据报，支持QoS</p>
<p>IPv6数据报格式：</p>
<ul>
<li>固定长度的40字节基本首部</li>
<li>不允许分片</li>
</ul>
<p>虽然首部没有可选项、是固定长度，但是有可选的扩展首部。</p>
<p>IPv6数据报格式：</p>
<p>基本首部，扩展首部1，扩展首部2，…，扩展首部N，数据部分（例如TCP段）</p>
<h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><p>路由算法（协议）确定最佳路径，转发表确定在本路由器如何转发分组。</p>
<h2 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h2><h3 id="静态路由-amp-动态路由"><a href="#静态路由-amp-动态路由" class="headerlink" title="静态路由&amp;动态路由"></a>静态路由&amp;动态路由</h3><p>静态路由：</p>
<ul>
<li>手工配置</li>
<li>路由更新慢</li>
<li>优先级高</li>
</ul>
<p>动态路由：</p>
<ul>
<li>路由更新快<ul>
<li>定期更新</li>
<li>及时响应链路费用或网络拓扑结构变化</li>
</ul>
</li>
<li>由路由算法计算出来的</li>
</ul>
<h3 id="全局信息-amp-分散信息"><a href="#全局信息-amp-分散信息" class="headerlink" title="全局信息&amp;分散信息"></a>全局信息&amp;分散信息</h3><p>全局信息：</p>
<ul>
<li>所有路由器掌握完整的网络拓扑和链路费用信息。</li>
<li>链路状态（LS）路由算法</li>
</ul>
<p>分散信息：</p>
<ul>
<li>路由器只掌握物理相连的邻居以及链路费用。</li>
<li>距离向量（DV）路由算法</li>
</ul>
<h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p>Dijkstra算法</p>
<ul>
<li><p>c(x, y): 结点x到结点y的链路费用；如果x和y不直接相连，则为∞。</p>
</li>
<li><p>D(v): 从源到目的v的当前路径费用值。</p>
</li>
<li>p(v): 沿从源到v的当前路径，v的前序结点集合。</li>
<li>N’: 已经找到最小费用路径的结点集合。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">N&#x27;= &#123;u&#125;</span><br><span class="line"><span class="keyword">for</span> 所有结点v</span><br><span class="line">	<span class="keyword">if</span> v nextTo u</span><br><span class="line">		<span class="constructor">D(<span class="params">v</span>)</span> = c(u, v)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="constructor">D(<span class="params">v</span>)</span> = ∞</span><br><span class="line"></span><br><span class="line">循环：</span><br><span class="line">	找出不在N&#x27;中的结点w，使得<span class="constructor">D(<span class="params">w</span>)</span>最小</span><br><span class="line">	将w加入N&#x27;</span><br><span class="line">	更新w的所有不在N&#x27;中的邻居v的<span class="constructor">D(<span class="params">v</span>)</span>: <span class="constructor">D(<span class="params">v</span>)</span> = min&#123;c(v, w)+<span class="constructor">D(<span class="params">w</span>)</span>, <span class="constructor">D(<span class="params">v</span>)</span>&#125;</span><br><span class="line">until 所有结点都在N&#x27;中</span><br></pre></td></tr></table></figure>
<p>但是存在振荡现象。</p>
<h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>Bellman-Ford方程（动态规划）</p>
<ul>
<li>Dx(y) := 从x到y最短路径的费用（距离）</li>
<li>Dx(y) = min{c(x, v) + Dv(y)}</li>
</ul>
<p>异步迭代：</p>
<ul>
<li>引发每次局部迭代的因素：<ul>
<li>局部链路费用改变</li>
<li>来自邻居的DV更新</li>
</ul>
</li>
</ul>
<p>分布式：</p>
<ul>
<li>每个结点只当DV变化时才通告给邻居</li>
</ul>
<p>无穷计数问题</p>
<h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>将任意规模网络抽象为一个图计算路由——过于理想化。</p>
<p>标识所有路由器</p>
<p>“扁平”网络</p>
<p>网络规模巨大时，交换量会占用所有网络带宽。</p>
<p>聚合路由器为一个区域：自治系统AS</p>
<h2 id="Internet路由"><a href="#Internet路由" class="headerlink" title="Internet路由"></a>Internet路由</h2><p>AS内部路由：</p>
<ul>
<li>Internet采用层次路由</li>
<li>AS内部路由协议也称为内部网络协议IGP(interior gateway protocol)</li>
<li>最常见的AS内部路由协议：<ul>
<li>路由信息协议：RIP(Routing Information Protocol)</li>
<li>开放最短路径优先：OSPF(Open Shortest Path First)</li>
<li>内部网关路由协议：IGRP(Interior Gateway Routing Protocol)<ul>
<li>Cisco私有协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>早于1982年随BSD- UNIX操作系统发布</p>
<p>跳数指从<strong>源端口到达目的端口所经过的路由个数，</strong>每经过一个路由器，跳数加1 。数据包经过一台路由器就是一跳，经过的路由器数量，就是它的跳数。</p>
<p>距离向量路由算法：</p>
<ul>
<li>距离度量：跳步数(max = 15hops)，每条链路1个跳步</li>
<li>每隔30秒，邻居之间交换一次DV，成为通告(advertisement)</li>
<li>每次通告：最多25个目的子网(IP地址形式)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138122809#:~:text=%E8%B7%B3%E6%95%B0%E6%8C%87%E4%BB%8E%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%80%E7%BB%8F%E8%BF%87%E7%9A%84%E8%B7%AF%E7%94%B1%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%AF%8F%E7%BB%8F%E8%BF%87%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E8%B7%B3%E6%95%B0%E5%8A%A01%20%E3%80%82.,%E5%9C%A8%E8%BF%99%E7%A7%8D%E7%AE%97%E6%B3%95%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E9%83%BD%E5%BF%85%E9%A1%BB%E5%8F%82%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E4%BA%A4%E6%8D%A2%EF%BC%8C%E4%BB%A5%E4%BF%9D%E8%AF%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E7%BB%93%E7%82%B9%E9%83%BD%E7%9B%91%E5%90%AC%E4%BB%8E%E5%85%B6%E4%BB%96%E7%BB%93%E7%82%B9%E4%BC%A0%E6%9D%A5%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%B8%8B%E5%88%97%E6%83%85%E5%86%B5%E4%B8%8B%E6%9B%B4%E6%96%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E8%A1%A8%EF%BC%9A.%20%E8%A2%AB%E9%80%9A%E5%91%8A%E4%B8%80%E6%9D%A1%E6%96%B0%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%AF%A5%E8%B7%AF%E7%94%B1%E5%9C%A8%E6%9C%AC%E7%BB%93%E7%82%B9%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%85%A5%E8%BF%99%E6%9D%A1%E6%96%B0%E7%9A%84%E8%B7%AF%E7%94%B1%E3%80%82.%20%E5%8F%91%E6%9D%A5%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E4%B8%AD%E6%9C%89%E4%B8%80%E6%9D%A1%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%AA%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%AF%A5%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E7%9B%B8%E6%AF%94%EF%BC%8C%E6%9C%89%E8%BE%83%E7%9F%AD%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%88%E8%BE%83%E5%B0%8F%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%89%E3%80%82.">LINK</a></p>
<p>OSPF(Open Shortest Path First)协议：</p>
<ul>
<li>开放：公众可用</li>
<li>采用链路状态路由算法</li>
<li></li>
</ul>
<p>Don’t let anyone rush yourself with their timelines.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/05/03/%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">传输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 09:15:47" itemprop="dateCreated datePublished" datetime="2021-05-03T09:15:47+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-22 16:14:20" itemprop="dateModified" datetime="2021-05-22T16:14:20+08:00">2021-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>传输层服务的基本理论和基本机制：</p>
<ul>
<li>多路复用/分用</li>
<li>可靠数据传输机制</li>
<li>流量控制机制</li>
<li>拥塞控制机制</li>
</ul>
<p>Internet的传输层协议</p>
<ul>
<li>UDP: 无连接传输服务</li>
<li>TCP: 面向连接的传输服务</li>
<li>TCP拥塞控制</li>
</ul>
<p>主机上运行着五层Internet协议栈，有应用层、传输层、网络层、数据链路层和物理层；路由器上只有三层协议栈，即网络层及以上的是没有的。</p>
<p>传输层协议为运行在不同host上的进程提供了一种<strong>逻辑通信机制</strong>。</p>
<blockquote>
<p>逻辑通信机制，就是指进程之间仿佛是直接连接的，不需要关心有多远的物理距离、经过了多少个路由器、使用的是什么物理媒介。</p>
</blockquote>
<p>端系统运行传输层协议：</p>
<ul>
<li>发送方：将应用递交的消息分成一个或多个的segment，并向下传给网络层。</li>
<li>接收方：将接收到的segment组装成消息，并向上交给应用层。</li>
</ul>
<p>传输层可以为应用提供多种协议：</p>
<ul>
<li>Internet上的TCP</li>
<li>Internet上的UDP</li>
</ul>
<p><strong>比较</strong></p>
<ul>
<li><p>网络层：提供<strong>主机</strong>之间的逻辑通信机制</p>
</li>
<li><p>传输层：提供<strong>应用进程</strong>之间的逻辑通信机制</p>
<p>— 位于网络层之上（IP），依赖于网络层服务，对网络层进行（可能的）增强</p>
</li>
</ul>
<h1 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h1><p>可靠、按序的交付服务（TCP）</p>
<ul>
<li>拥塞控制</li>
<li>流量控制</li>
<li>连接建立</li>
</ul>
<p>不可靠的交付服务（UDP）</p>
<ul>
<li>基于”尽力而为 (best-effort) “的网络层，没有做（可靠性方面的）扩展</li>
</ul>
<p><strong>两种服务均不提供：延迟、带宽</strong></p>
<h2 id="多路复用和多路分用"><a href="#多路复用和多路分用" class="headerlink" title="多路复用和多路分用"></a>多路复用和多路分用</h2><p>为什么要多路复用/分用？</p>
<ul>
<li>如果某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用。</li>
</ul>
<p>socket是应用层和传输层之间的”门”。</p>
<p><strong>接收端进行多路分用</strong>：传输层依据头部信息将收到的segment交给正确的socket，即不同的进程。</p>
<p><strong>发送端进行多路复用</strong>：从多个socket接收数据，为每块数据封装上头部信息，生成segment，交给网络层。</p>
<h3 id="分用——如何工作？"><a href="#分用——如何工作？" class="headerlink" title="分用——如何工作？"></a>分用——如何工作？</h3><p>主机接收到 IP 数据报（datagram）</p>
<ul>
<li>每个数据报携带源 IP 地址、目的 IP 地址</li>
<li>每个数据报携带一个传输层的段（segment）</li>
<li>每个段携带源端口号和目的端口号</li>
</ul>
<p>TCP/UDP 段格式：</p>
<p>|——————- 32 bits ——————-|</p>
<p>|   源端口号   |  目的端口号  |</p>
<p>|            其他头部信息            |</p>
<p>|      应用数据 (message)       |</p>
<p>主机收到segment后，传输层协议提取IP地址和端口号信息，将segment导向相应的socket。（网络层是不关心端口号信息的）TCP会做更多的处理。</p>
<p><strong>无连接分用</strong></p>
<p>UDP的socket用<strong>二元组</strong>标识（目的IP地址，目的端口号）</p>
<p>主机收到UDP段后：</p>
<ul>
<li>检查段中的目的端口号</li>
<li>将UDP段导向绑定在该端口号的socket</li>
</ul>
<p>来自不同源IP地址和/或源端口号的IP数据包被导向同一个socket。</p>
<p><strong>面向连接分用</strong></p>
<p>TCP的socket用<strong>四元组</strong>标识：</p>
<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
<p>接收端利用所有的4个值将segment导向合适的socket。</p>
<p>服务器可能同时支持多个TCP socket。每个socket用自己的四元组标识。</p>
<p>web服务器为每个客户端开不同的socket。</p>
<blockquote>
<p>也就是说，例如host B中的进程1向host A发起TCP连接，SP(source port)是9157，DP是80；进程2也发起TCP连接，SP是5775，DP是80；两个进程的S-IP和D-IP相同，都是B和A。但是socket不同，服务器为每个客户端开不同的socket。进程1对应socket1，进程2对应socket2。服务器上的这两个socket的SP相同，都是80，S-IP和D-IP也分别相同，但是DP不同，分别是5775和9157.</p>
</blockquote>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>User Datagram Protocol [ RFC 768 ]</p>
<p>基于Internet IP协议：</p>
<ul>
<li>复用/分用</li>
<li>简单的错误校验（因为路由器在存储转发的过程中也可能会出错）</li>
</ul>
<p>UDP提供的是”Best effort”服务，所以会丢失、非按序到达。</p>
<p>每个UDP段的处理独立于其他段。</p>
<blockquote>
<p>UDP为什么存在？</p>
<ul>
<li>无需建立连接（减少延迟，因此DNS使用的是UDP）</li>
<li>实现简单：无需维护连接状态</li>
<li>头部开销少（UDP头部8个字节，而TCP是20个字节）</li>
<li>没有拥塞控制：应用可以更好地控制发送时间和速率（TCP有拥塞控制，会根据实际情况自动调整发送时间和速率）</li>
</ul>
</blockquote>
<p>常用于流媒体应用：容忍丢失、速率敏感</p>
<p>UDP还用于：DNS，SNMP</p>
<p><strong>在UDP上是可以实现可靠数据传输的</strong>——在应用层增加可靠性机制、应用特定的错误恢复机制（即在应用层实现，因此对应用层开发人员来说难度较大）</p>
<p>UDP segment format:</p>
<p>[32bits]</p>
<p>|         sp         |          dp         |</p>
<p>|     length      |    checksum  |</p>
<p>| Application data (message)|</p>
<p>length是UDP段的长度（包含头部），checksum是校验和（实现错误校验功能）。</p>
<h3 id="UDP-checksum"><a href="#UDP-checksum" class="headerlink" title="UDP checksum"></a>UDP checksum</h3><p>目的：检测UDP段在传输过程中是否发生错误（如位翻转）。</p>
<p>发生错误是因为传输是端到端的，可能经历了多种物理媒介、多个路由器等等，中途很有可能发生错误。</p>
<p><strong>发送方</strong>：</p>
<ul>
<li>将段的内容视为16-bit整数</li>
<li>校验和计算：计算所有整数的和，进位单独取出来与剩下的16位相加，将得到的值按位求反，得到校验和</li>
<li>发送方将校验和放入校验和字段</li>
</ul>
<p><strong>接收方</strong>：</p>
<ul>
<li>计算所收到的校验和</li>
<li>将其与校验和字段进行对比，若不相等则检测出错误，若相等则没有检测出错误，但仍然可能有错误</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>可靠——不错、不丢、不乱</p>
<p>可靠数据传输协议：</p>
<ul>
<li>可靠数据传输对应用层、传输层、链路层都很重要</li>
<li>网络top-10问题</li>
<li>信道的不可靠特性决定了可靠数据传输协议 (rdt) 的复杂性</li>
</ul>
<p><strong>可靠数据传输协议基本结构：接口</strong></p>
<p>rdt_send(): 被上层应用调用，将数据交给rdt (reliable data transfer protocol) 以发送给对方。即发送方向上地响应这样一个rdt_send的调用。</p>
<p>udt_send(): 被rdt调用，在不可靠信道(unreliable channel)上向接收方传输数据。（所谓的不可靠信道，实际上就是我们所说的网络层的IP协议）</p>
<p>rdt_rcv(): 当数据包到达接收方信道时被调用。这一调用就会触发接收方的rdt协议对数据包进行处理。</p>
<p>deliver_data(): 被rdt调用，向上层应用交付数据。</p>
<p>可以看出，rdt_send()和deliver_send()是单向的。这是因为应用层只需要发数据和收数据，不关心数据是怎么处理和传输的。剩下的所有工作都由下面的层完成。</p>
<h3 id="可靠数据传输协议"><a href="#可靠数据传输协议" class="headerlink" title="可靠数据传输协议"></a>可靠数据传输协议</h3><p>渐进的设计可靠数据传输协议的发送方和接收方，只考虑单向数据传输，但控制信息双向流动。利用有限状态机(Finite State Machine, FSM)刻画传输协议。</p>
<p>协议：（逐步贴近真实情况）</p>
<h4 id="Rdt-1-0-可靠信道上的可靠数据传输"><a href="#Rdt-1-0-可靠信道上的可靠数据传输" class="headerlink" title="Rdt 1.0: 可靠信道上的可靠数据传输"></a>Rdt 1.0: 可靠信道上的可靠数据传输</h4><p>假设底层信道完全可靠：不会发生位错误，不会丢弃分组</p>
<p>发送方和接收方的FSM独立（因为这是一个可靠信道！发送方和接收方之间就不需要什么交互，全部交给协议处理就行了）</p>
<h4 id="Rdt-2-0-产生位错误的信道"><a href="#Rdt-2-0-产生位错误的信道" class="headerlink" title="Rdt 2.0: 产生位错误的信道"></a>Rdt 2.0: 产生位错误的信道</h4><p>假设分组不会丢失，只是产生了位错误。</p>
<p>首先，接收方需要知道分组是否出错。如果错了，就要想办法恢复/重传。</p>
<p>检测出错已解决——底层信道可能翻转分组中的位(bit)：利用校验和检测位错误</p>
<p>如何从错误中恢复？这就需要引入新的控制消息来标识——</p>
<ul>
<li>确认机制(Acknowledgements, ACK)：接收方显示地告知发送方分组已正确接收。</li>
<li>NAK：接收方显示地告知发送方分组有错误。</li>
<li>发送方收到NAK后，<strong>重传</strong>分组。</li>
</ul>
<p>基于这种重传机制的rdt协议称为ARQ(Automatic Repeat Request)协议。</p>
<p>Rdt 2.0中引入的新机制：</p>
<ul>
<li>差错检测</li>
<li>接收方反馈控制消息：ACK/NAK</li>
<li>重传</li>
</ul>
<p>但是有一个致命缺陷：如果ACK/NAK的传输出错怎么办？这里使用的是停-等协议，即stop and wait — sender sends one packet, then waits for receiver response.</p>
<p>what happens if ACK/NAK corrupted?</p>
<ul>
<li><p>sender doesn’t know what happened at receiver!</p>
</li>
<li><p>can’t just retransmit: possible duplicate</p>
</li>
</ul>
<p>Handling duplicates:</p>
<ul>
<li><p>sender retransmits current pkt if ACK/NAK corrupted</p>
</li>
<li><p>sender adds <em>sequence number</em> to each pkt</p>
</li>
<li><p>receiver discards (doesn’t deliver up) duplicate pkt</p>
</li>
</ul>
<h4 id="Rdt-2-1-发送方应对ACK-NAK破坏"><a href="#Rdt-2-1-发送方应对ACK-NAK破坏" class="headerlink" title="Rdt 2.1 发送方应对ACK/NAK破坏"></a>Rdt 2.1 发送方应对ACK/NAK破坏</h4><p>增加了两个序列号0和1。</p>
<p>对于发送方，有等待上层调用的状态和等待ACK/NAK的状态这两种，因此总状态是翻倍了的，即两个0两个1。（等待上层调用序列号0分组的状态，等待序列号0的ACK/NAK的状态，等待上层调用序列号1分组的状态，等待序列号1的ACK/NAK的状态）翻倍是因为必须记住当前分组的序列号。</p>
<h4 id="Rdt-2-2-无NAK消息协议"><a href="#Rdt-2-2-无NAK消息协议" class="headerlink" title="Rdt 2.2: 无NAK消息协议"></a>Rdt 2.2: 无NAK消息协议</h4><p>接收方通过ACK告知最后一个被正确接收的分组，在ACK中显示地加入被确认分组的序列号。</p>
<p>发送方接收到重复ACK后，重发当前分组。</p>
<p>停等操作使得Rdt 3.0的性能很差。</p>
<h4 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h4><p>允许发送方在收到ACK之前连续发送多个分组。这就需要更大的<strong>序列号范围</strong>，发送方和接收方需要更大的存储空间以<strong>缓存分组</strong>。</p>
<h4 id="滑动窗口协议-Sliding-window-protocol"><a href="#滑动窗口协议-Sliding-window-protocol" class="headerlink" title="滑动窗口协议 Sliding-window protocol"></a>滑动窗口协议 Sliding-window protocol</h4><p>窗口：允许使用的序列号范围</p>
<p>窗口尺寸为N，表示最多有N个等待确认的消息。</p>
<p>滑动窗口：随着协议的<strong>运行</strong>，窗口在序列号空间内<strong>向前滑动</strong>。</p>
<p>滑动窗口协议：GBN，SR</p>
<p><strong>GBN协议 (Go-Back-N)</strong></p>
<p>分组头部包含k-bit序列号</p>
<p>采用累积确认的机制</p>
<p>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收。</p>
<p>超时timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组。</p>
<p>ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK</p>
<ul>
<li>可能产生重复的ACK</li>
<li>只需要记住唯一的expectedseqnum</li>
</ul>
<p>乱序到达的分组：</p>
<ul>
<li>直接丢弃——接收方不缓存</li>
<li>重新确认序列号最大的、按序到达的分组</li>
</ul>
<p><strong>SR (Selective Repeat)</strong></p>
<p>接收方对每个分组单独进行确认</p>
<ul>
<li>设置<strong>缓存机制</strong>，缓存乱序到达的分组</li>
</ul>
<p>发送方只重传那些没收到ACK的分组</p>
<ul>
<li>为每个分组设置定时器</li>
</ul>
<p>发送方窗口</p>
<ul>
<li>N个连续的序列号</li>
<li>限制已发送且未确认的分组</li>
</ul>
<p>序列号空间大小与窗口尺寸满足的关系：$N_S+N_R\leq2^k$.</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li><p>点对点：一个发送方，一个接收方</p>
</li>
<li><p>可靠的、按序的字节流</p>
</li>
<li><p>流水线机制：TCP拥塞控制和流量控制机制设置窗口尺寸</p>
</li>
<li><p>发送方/接收方缓存</p>
</li>
<li><p>全双工 (full-duplex)：统一连接中能够传输双向数据流</p>
</li>
<li><p>面向连接：</p>
<p>通信双方在发送数据之前必须建立连接</p>
<p>连接状态只在连接的两端中维护，在沿途节点中并不维护状态</p>
<p>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</p>
</li>
<li><p>流量控制机制</p>
</li>
</ul>
<p><strong>序列号</strong></p>
<ul>
<li>序列号指的是segment中第一个字节的编号，而不是segment的编号，通常从500开始</li>
<li>建立TCP连接时，双方随即选择序列号</li>
</ul>
<p><strong>ACKs</strong></p>
<ul>
<li>希望接收到的下一个字节的序列号</li>
<li>累积确认：该序列号之前的所有字节均已被正确接收到</li>
</ul>
<p>接收方如何处理乱序到达的segment？</p>
<ul>
<li>TCP规范中没有规定，由TCP的实现者做出决策</li>
</ul>
<p><strong>TCP可靠数据传输</strong></p>
<ul>
<li><p>TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务</p>
</li>
<li><p>流水线机制</p>
</li>
<li><p>累积确认</p>
</li>
<li><p>TCP使用单一重传定时器</p>
</li>
<li>触发重传的事件：超时，收到重复ACK</li>
<li>渐进式：暂不考虑重复ACK，暂不考虑流量控制，暂不考虑拥塞控制</li>
</ul>
<p><strong>RTT和超时</strong></p>
<p>如何设置定时器的超时时间？</p>
<ul>
<li>大于RTT——但是RTT是变化的</li>
<li>过短：不必要的重传</li>
<li>过长：对段丢失时间反应慢</li>
</ul>
<p>如何估计RTT？</p>
<ul>
<li><p>SampleRTT：测量从段发出去到收到ACK的时间</p>
</li>
<li><p>忽略重传</p>
</li>
<li><p>SampleRTT变化，就测量多个取平均值</p>
</li>
<li><p>指数加权移动平均：</p>
<p>EstimatedRTT=(1-alpha)*EstimatedRTT+alpha*SampleRTT</p>
<p>典型值：0.125</p>
</li>
</ul>
<p><strong>TCP发送方要处理的事件</strong></p>
<p>从应用层收到数据：</p>
<ul>
<li>创建segment</li>
<li>序列号是segment第一个字节的编号</li>
<li>开启计时器</li>
<li>设置超时时间TimeoutInterval</li>
</ul>
<p>超时：</p>
<ul>
<li>重传引起超时的segment</li>
<li>重启定时器</li>
</ul>
<p>收到ACK：</p>
<p>如果确认此前未确认的segment</p>
<ul>
<li>更新SendBase</li>
<li>如果窗口中还有未被确认的分组，重新启动定时器</li>
</ul>
<p><strong>快速重传机制</strong></p>
<p>TCP实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大，因此重发丢失的分组之前要等待很长时间。</p>
<p>通过重复ACK检测分组丢失</p>
<p>如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失，sender重传该分组。</p>
<p>快速重传：在定时器超时之前即进行重传</p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>接收方为TCP连接分配buffer。</p>
<p>流量控制 (flow control)：发送方不会传输的太多、太快以至于淹没接收方（buffer溢出）。</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP sender和receiver在传输数据前需要建立连接</p>
<p>client是连接发起者，server等待客户连接请求。</p>
<h3 id="Three-way-handshake"><a href="#Three-way-handshake" class="headerlink" title="Three way handshake"></a>Three way handshake</h3><ol>
<li><p>client host sends TCP SYN segment to server</p>
<p>specifies initial seq</p>
<p>no data</p>
</li>
<li><p>server host receives SYN, replies with SYNACK segment</p>
<p>server allocates buffers</p>
<p>specifies server initial seq</p>
</li>
<li><p>client receives SYNACK, replies with ACK segment, which may contain data</p>
</li>
</ol>
<h3 id="TCP关闭——4次挥手"><a href="#TCP关闭——4次挥手" class="headerlink" title="TCP关闭——4次挥手"></a>TCP关闭——4次挥手</h3><p>client向server发送FIN</p>
<p>server收到FIN，回复ACK，关闭连接，发送FIN</p>
<p>client收到FIN，回复ACK</p>
<ul>
<li>进入等待状态，timeout了会重复发送ACK</li>
</ul>
<p>server收到ACK，连接关闭</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞(congestion)</p>
<p>表现：</p>
<ul>
<li>分组丢失（路由器缓存溢出）</li>
<li>分组延迟过大（在路由器缓存中排队）</li>
</ul>
<p><strong>拥塞控制的方法</strong></p>
<p>端到端的拥塞控制：</p>
<ul>
<li>网络层不需要显式地提供支持</li>
<li>端系统通过观察loss, delay等网络行为判断是否发生拥塞</li>
<li>TCP采取这种方法</li>
</ul>
<p>网络辅助的拥塞控制：</p>
<ul>
<li>路由器向发送方显示地反馈网络拥塞信息</li>
<li>简单的拥塞只是说</li>
</ul>
<p>TCP快速重传为什么3次ACK</p>
<p>TCP为什么3次握手</p>
<p>TCP MSS</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/04/10/Java%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/Java%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Java复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-10 19:38:31 / Modified: 22:29:38" itemprop="dateCreated datePublished" datetime="2021-04-10T19:38:31+08:00">2021-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h1><blockquote>
<p>感觉自己没救了😭</p>
</blockquote>
<p>路径分隔符：</p>
<p><code>static String pathSeparator</code></p>
<p><code>static char pathSeparatorChar</code></p>
<p>文件名称分隔符：</p>
<p><code>static String separator</code></p>
<p><code>static char separatorChar</code></p>
<p>操作路径：<code>&quot;Code&quot;+File.separator+&quot;Java&quot;+File.separator+&quot;Homework&quot;</code></p>
<p>String类型和char类型作用完全相同，因为在源码里是这样的：</p>
<p><code>public static final String pathSeparator=&quot;&quot;+pathSeparatorChar;</code></p>
<p>路径是不区分大小写的。Unix中文件名称分隔符是<code>/</code>，Windows是<code>\</code>，但是这是转义字符，所以写的时候要写成<code>\\</code>.</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>File(String pathname)</code> 通过将给定路径名字符串转换为抽象路径名来创建一个新File实例。路径结尾可以是文件也可以是文件夹。可以是相对路径或绝对路径。路径可以存在也可以不存在。<strong>这是因为创建File对象，只是把字符串路径封装成File对象，不考虑路径的真假情况。</strong></p>
<p><code>File(String parent, String child)</code></p>
<h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><code>public String getAbsolutePath()</code> 返回此File的绝对路径</li>
<li><code>public String getPath()</code> 将此File转换为路径名字符串(就是把结果放到这个File对象中返回)</li>
<li><code>public String getName()</code> 返回此File表示的文件或目录的名称</li>
<li><code>public long length()</code> 返回由此File表示的文件的长度，以字节为单位。不能是文件夹。若文件不存在，则返回0.</li>
</ul>
<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> 此File表示的文件或目录是否实际存在</li>
<li><code>public boolean isDirectory()</code> 此File表示的是否为目录</li>
<li><code>public boolean isFile()</code> 此File表示的是否是文件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">数据库复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-07 21:01:36" itemprop="dateCreated datePublished" datetime="2021-04-07T21:01:36+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-09 21:01:25" itemprop="dateModified" datetime="2021-06-09T21:01:25+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库使用一个或多个表来存储数据。<br>数学上把一系列域上的笛卡尔积的子集称为关系。</p>
<p>软件系统无法保证数据的真实正确性，但可以保证数据符合可明确定义的约束。这种约束通常称为完整性约束。它是数据安全性的一部分。<br>常见的简单约束有两种形式，一种是对属性取值范围的确定，比如性别只有男、女两种属性的取值（个人认为应该是三种，男、女、无 :)  ）。另一种是对属性值之间相互关系的限定，最典型的就是关系模型中键的定义，如主键、超键、外键、候选键。<br>超键：在给定关系模式中，能唯一标识出各个元组的属性集合。超键中可能包含无关紧要的属性，也就是说超键的真子集也可能是超键。例如在学生成绩表中有学号、姓名和成绩3个属性，其中学号是超键，而且也是主键，因为姓名和成绩可能重复，但学号是唯一的。{学号，姓名}，{学号，成绩}，{学号，姓名，成绩}也是超键。<br>候选键：在给定关系模式中，能够唯一标识出各个元组的属性集合，并且不含多余属性。候选键是超键，但超键不一定是候选键。只有不存在任何真子集是超键的超键才是候选键。<br>主键：一个关系中可能有多个候选键，通常指定其中一个，并且只能是一个，用来标识元组。由于主键具有唯一性，所以主键是候选键，但候选键不一定是主键。<br>外键：如果关系表S1的一个属性子集A，必须匹配另一个关系表S2中出现的数值，则称A是关系表S1的外键。其中，S1称为引用关系，S2称为被引用关系。外键的值，或与被引用关系中出现的数值对应，或为空值。例如关系表1中有院系这个属性，并且是外键，对应关系表2中的单位这个属性，而院系属性中有工程学院，单位属性中此项为教育学院或为空值，那么就出问题了。如果院系属性也为教育学院，或者院系属性为空而单位属性为教育学院，那么是可以的。</p>
<p>可以用代数、逻辑等方法描述关系操作，最基本最常用的是代数方法，即关系代数。<br>关系代数也是一门代数，关系代数包括一个运算集合，这些运算以一个或两个关系作为运算数，产生一个新的关系作为结果。<br>关系代数运算包含基本关系代数运算、附加关系代数运算和扩展关系代数运算。其中基本关系代数运算包含选择、投影、集合并、集合差、笛卡尔积和更名运算。</p>
<p>选择：选择运算是选出满足给定谓词（条件）的元组，结果关系和原关系有着相同的模式。<br>选择运算用 $\sigma$ 表示。将谓词写作 $\sigma$ 的右下标，并在 $\sigma$ 后面的括号中给出作为参数的关系名。例如：</p>
<script type="math/tex; mode=display">
\sigma_{gender=none}(students)</script><p>就是在students关系表中选出gender属性为none的元组。（hhh）<br>投影：投影运算用来从给定关系产生一个只有其部分列的新关系。投影运算用 $\pi$ 表示。所有希望在结果关系中出现的属性作为右下标，作为参数的关系名紧跟在 $\pi$ 后面的括号中。结果关系的模式是 $\pi$ 的下标中列出的所有属性，并按 $\pi$ 下标中列出的顺序出现。例如：</p>
<script type="math/tex; mode=display">
\pi_{id,age}(students)</script><p>于是结果关系中只包含id和age两个属性，并且会去掉结果关系中重复的元组。<br>⚠️ 关系代数把表看作是作为元组集合的关系，既然是集合，就不包括重复元组，也就是说，关系代数每个运算都是去重的。<br>并运算：关系是相容的。两个关系必须是同元的，即它们所包含的属性个数必须相同；两个关系对应属性的域必须相同或相容。<br>例如，找出所有已有考生报考又安排了考官组卷的eid：</p>
<script type="math/tex; mode=display">
\pi_{eid}(eeexam) \bigcup \pi_{eid}(erexam)</script><p>差运算：用来查询在一个关系中而不在另一个关系中的那些元组，和并运算一样，差运算只能在相容的关系间进行。<br>例如，找出所有已有考生报考但没有安排考官组卷的eid：</p>
<script type="math/tex; mode=display">
\pi_{eid}(eeexam)-\pi_{eid}(erexam)</script><p>笛卡尔积运算：结果关系的模式是参与运算的两个关系的模式的串接。运算符左侧关系中的每一个元组与右侧关系的每一个元组拼接，形成结果关系中的一个元组。<br>⚠️ 元组的拼接<br>更名：对给定的关系代数表达式E，表达式 $\rho_X(E)$ 返回表达式E的结果，并把名字X赋给了它。<br>如果关系代数表达式E是n元的，则表达式 $\rho_{X(A_1,A_2,…,A_n)}(E)$ 返回表达式E的结果，并赋给它名字X，同时将E的各属性更名为 $A_1,A_2,…,A_n$。<br>关系运算的运算参数是关系，运算结果也是关系。<br>查询历史学院的考生的姓名：</p>
<script type="math/tex; mode=display">
\sigma_{name}(\pi_{department=history}(contestants))</script><p>关系代数基本运算是完备的，足以表达任何普通的关系代数查询。但是许多查询的表达式复杂、冗长，因此定义附加运算，简化一些查询的表达。<br>常见的附加运算有：集合交、自然联接、属性联接、条件联接和赋值运算。</p>
<p>集合交：集合交运算的结果是由那些同时在参与运算关系中存在的元组组成，只能在相容的关系间进行，用 $\bigcap$ 表示。</p>
<p>自然联接：可以将特定选择运算和笛卡尔积合并为一个运算。首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的<strong>所有</strong>同名属性进行属性值相等的选择运算，最后去掉重复列。也就是结果关系模式中相同的属性只保留一列，因为在任何元组中同名属性的值都是相等的。</p>
<p>例如：</p>
<p>examinee表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>eeid</th>
<th>eename</th>
<th>dname</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>A</td>
<td>历史</td>
</tr>
<tr>
<td>234</td>
<td>B</td>
<td>心理</td>
</tr>
<tr>
<td>345</td>
<td>C</td>
<td>教育</td>
</tr>
</tbody>
</table>
</div>
<p>department表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>dname</th>
<th>dloca</th>
<th>dtele</th>
</tr>
</thead>
<tbody>
<tr>
<td>历史</td>
<td>46-A</td>
<td>444</td>
</tr>
<tr>
<td>教育</td>
<td>45-B</td>
<td>555</td>
</tr>
<tr>
<td>心理</td>
<td>44-C</td>
<td>666</td>
</tr>
</tbody>
</table>
</div>
<p>先算笛卡尔积：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>examinee.eeid</th>
<th>examinee.eename</th>
<th>examinee.dname</th>
<th>department.dname</th>
<th>department.dloca</th>
<th>department.dtele</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>A</td>
<td>历史</td>
<td>历史</td>
<td>46-A</td>
<td>444</td>
</tr>
<tr>
<td>123</td>
<td>A</td>
<td>历史</td>
<td>教育</td>
<td>45-B</td>
<td>555</td>
</tr>
<tr>
<td>123</td>
<td>A</td>
<td>历史</td>
<td>心理</td>
<td>44-C</td>
<td>666</td>
</tr>
<tr>
<td>234</td>
<td>B</td>
<td>心理</td>
<td>历史</td>
<td>46-A</td>
<td>444</td>
</tr>
<tr>
<td>234</td>
<td>B</td>
<td>心理</td>
<td>教育</td>
<td>45-B</td>
<td>555</td>
</tr>
<tr>
<td>234</td>
<td>B</td>
<td>心理</td>
<td>心理</td>
<td>44-C</td>
<td>666</td>
</tr>
<tr>
<td>345</td>
<td>C</td>
<td>教育</td>
<td>历史</td>
<td>46-A</td>
<td>444</td>
</tr>
<tr>
<td>345</td>
<td>C</td>
<td>教育</td>
<td>教育</td>
<td>45-B</td>
<td>555</td>
</tr>
<tr>
<td>345</td>
<td>C</td>
<td>教育</td>
<td>心理</td>
<td>44-C</td>
<td>666</td>
</tr>
</tbody>
</table>
</div>
<p>选择examinee.dname和department.dname相同的元组，最终选出了3组，将examinee.dname和department.dname属性合并后，成为了结果关系。</p>
<p>属性联接：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的<strong>指定</strong>同名属性进行属性值相等的选择运算，最后去掉重复列。指定同名属性只保留一个。</p>
<p>自然联接用 $S1 \infty S2$ 表示，属性联接用 $S1 \infty_{attribute} S2$ 表示。<br>例如指定了属性name，那么联接时就只看S1.name和S2.name相等的元组。<br>因此区别就是，当参与联接运算的两个表有多个<strong>同名列</strong>时，自然联接的匹配条件是所有同名列全部取值相等，而属性联接的匹配条件是指定其中的某些同名列取值相等。<br>赋值：赋值运算是将 $\leftarrow$ 右侧的表达式结果赋给其左侧的关系变量，该关系变量可以在后续的表达式中使用。<br>例如：从A中去除属性X</p>
<script type="math/tex; mode=display">
A\leftarrow A-\sigma_{att1=x}(A)</script><p>关系代数运算的进一步扩充：<br>广义投影：允许将算术运算作为投影的一部分<br>聚集：例如计算给定集合元素的总和、平均值等<br>外联接：使得关系代数表达式可以处理缺失信息</p>
<p>广义投影：允许在投影列表中使用算术表达式。<br>例如 $\pi_{F_1,F_2,…,F_n}(E)$ 中，E是任意关系代数表达式，$F_1,F_2,…,F_n$ 中的每一个都是涉及E的属性的算术表达式，也可以仅仅是单个属性或常量。<br>广义投影的结果是对关系表达式t的每一行分别计算 $F_1,F_2,…,F_n$，<br>聚集函数：sum, avg, count, max, min等。<br>例如：</p>
<script type="math/tex; mode=display">
G_{avg(erage)}(examiner)</script><p>查询结果只包含一个元组，只有单个属性。<br>还可以这样：</p>
<script type="math/tex; mode=display">
_{dname}G_{avg(erage)}(examiner)</script><p>意思是说对元组按dname进行分组。</p>
<p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用系统可能希望在结果中保留悬浮元组，这就有了外联接运算。<br>不考虑悬浮元组的自然联接、属性联接和条件联接都属于内联接。<br>外联接：首先计算内联接，然后加入左侧关系、右侧关系、两侧关系中的悬浮元组，对应称为左外联接(L)、右外联接(R)、全外联接(F)。表示方法：$\infty^R$.</p>
<h1 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h1><p>实体用方框表示。</p>
<p>联系用菱形表示。</p>
<p>实体和实体集统称实体。</p>
<p>实体通常使用属性来描述。同类实体通常使用相同的属性组来描述。</p>
<p>属性可能取值的范围成为属性域</p>
<p>现实生活中经常需要区分同类实体集中一个个不同的实体。例如在考生实体集中，由于可能出现同名同姓的考生，所以用考号来区分。</p>
<p>能够并且用以区分一个实体集中不同实体的最小属性集称为标识符或主键，组成主键的属性称为标识属性。</p>
<p>属性用椭圆表示。</p>
<p><strong>联系也有属性！</strong></p>
<p><strong>用线段将属性与其相对应的联系或实体连接起来。</strong></p>
<p><strong>并在那些用于标识实体或联系的属性下面加上下划线</strong></p>
<h1 id="2021-5-16-add"><a href="#2021-5-16-add" class="headerlink" title="2021/5/16 add"></a>2021/5/16 add</h1><h2 id="候选码-candidate-key-候选键"><a href="#候选码-candidate-key-候选键" class="headerlink" title="候选码(candidate key) / 候选键"></a>候选码(candidate key) / 候选键</h2><p>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。</p>
<p>关系中可以有多组候选码，例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Student</span><span class="params">(S#, Sname, Sage, Sclass, Saddress)</span></span></span><br></pre></td></tr></table></figure>
<p>S#是候选码，(Sname, Saddress)也是候选码。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Employee</span><span class="params">(EmpID, EmpName, MobileNumber)</span></span></span><br></pre></td></tr></table></figure>
<p>EmpID是候选码，MobileNumber也是候选码。</p>
<h2 id="主码-primary-key-主键"><a href="#主码-primary-key-主键" class="headerlink" title="主码(primary key) / 主键"></a>主码(primary key) / 主键</h2><p>当有多个候选码时，可以选定一个作为主码。</p>
<p>DBMS以主码为主要线索管理关系中的各个元组。</p>
<p>例如可以选定属性 S# 作为 Student 表的主码，也可以选定属性组 (Sname, Saddress) 作为 Student 表的主码。</p>
<h2 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h2><p>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性。</p>
<p>最简单的，候选码只包含一个属性。</p>
<p>最极端的，所有属性构成这个关系的候选码，称为全码(all-key)。</p>
<h2 id="外码-foreign-key-外键"><a href="#外码-foreign-key-外键" class="headerlink" title="外码(foreign key) / 外键"></a>外码(foreign key) / 外键</h2><p>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的<strong>候选码</strong>相对应，则称这个属性组为R的外码或外键。</p>
<p>例如”合同”关系中的”客户号”不是候选码，但却是外码，因为它与”客户”关系中的候选码”客户号”相对应。</p>
<p>两个关系是通过<strong>外键</strong>连接起来的。</p>
<h2 id="关系模型的完整性"><a href="#关系模型的完整性" class="headerlink" title="关系模型的完整性"></a>关系模型的完整性</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>关系的主码中的属性值不能为空值。</p>
<p>空值：不知道或无意义的值。</p>
<p>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不允许的。</p>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2中某个元组的Pk值，或者为空值。</p>
<p>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在。</p>
<h2 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h2><p>用户针对具体的应用环境定义的完整性约束条件。</p>
<p>例如，S# 要求是10位整数，性别只能是男或女，年龄只能在12到35岁之间。</p>
<h2 id="DBMS对关系完整性的支持"><a href="#DBMS对关系完整性的支持" class="headerlink" title="DBMS对关系完整性的支持"></a>DBMS对关系完整性的支持</h2><p>实体完整性和参照完整性由DBMS系统自动支持。</p>
<p>DBMS系统通常提供了如下机制：</p>
<ul>
<li>它使用户可以自行定义有关的完整性约束条件</li>
<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性。</li>
</ul>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="并相容性"><a href="#并相容性" class="headerlink" title="并相容性"></a>并相容性</h3><p>某些关系代数操作，如并、差、交等，需要满足”并相容性”。</p>
<p>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性。</p>
<p>定义：关系R与关系S存在相容性，当且仅当：</p>
<ol>
<li>关系R和关系S的属性数目必须相同；</li>
<li>对于任意 i，关系R的第 i 个属性的域必须和关系S的第 i 个属性的域相同。</li>
</ol>
<p>例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student(SID char(<span class="number">10</span>), Sname char(<span class="number">8</span>), Age char(<span class="number">3</span>))</span><br><span class="line">Professor(PID char(<span class="number">10</span>), Pname char(<span class="number">8</span>), Age char(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="并操作-Union"><a href="#并操作-Union" class="headerlink" title="并操作(Union)"></a>并操作(Union)</h3><p>定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：$R \cup S$，它由或者出现在关系R中，或者出现在S中的元组构成。</p>
<p>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</p>
<h3 id="theta-join"><a href="#theta-join" class="headerlink" title="theta-join"></a>theta-join</h3><p>投影与选择操作只是对单个关系（表）进行操作，而实际应用中往往涉及多个表之间的操作，这就需要theta-连接操作。</p>
<h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p>数据库完整性(DB Integrity)是指DBMS应保证的DB的一种特性——在任何情况下的正确性、有效性和一致性。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是指向某检索记录集的指针。</p>
<p>通过这个指针的移动，每次读一行处理一行，直至处理完毕。</p>
<p><strong>第一范式 1NF</strong></p>
<p>若关系模式R(U)中关系的每个分量都是不可分的数据项，则称R(U)属于第一范式.</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>(<span class="params">street</span>, <span class="params">city</span>)</span>)</span><br></pre></td></tr></table></figure>
<p>Star不属于1NF，因为属性address仍包含了street, city两个属性，其分量不是原子。</p>
<p><strong>不符合1NF的处理</strong></p>
<p>将非1NF转换为1NF：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>(<span class="params">street</span>, <span class="params">city</span>)</span>)</span><br><span class="line">转换为：</span><br><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">street</span>, <span class="params">city</span>)</span>或<span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>第二范式 2NF</strong></p>
<p>若R(U)是1NF且U中的每一非主属性完全函数依赖于候选键，则称R(U)属于第二范式。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R(S#, <span class="meta">SN</span>, SD, <span class="meta">CN</span>, G)</span><br><span class="line">其中，S#是学号，<span class="meta">SN</span>是姓名，SD是班级，<span class="meta">CN</span>是课程，G是成绩，</span><br><span class="line">函数依赖：S#-&gt;<span class="meta">SN</span>, S#-&gt;SD, (S#, CD)-&gt;G</span><br><span class="line">候选键包含(S#, <span class="meta">CN</span>)</span><br><span class="line">非主属性包含<span class="meta">SN</span>和SD</span><br><span class="line">因为(S#, <span class="meta">CN</span>) -P-&gt; (<span class="meta">SN</span>, SD)，所以R不属于<span class="number">2</span>NF。</span><br><span class="line">将其分解为<span class="built_in">R1</span>(S#, <span class="meta">SN</span>, SD), <span class="built_in">R2</span>(S#, <span class="meta">CN</span>, G)，则<span class="built_in">R1</span>和<span class="built_in">R2</span>都属于<span class="number">2</span>NF。</span><br></pre></td></tr></table></figure>
<p>第二范式消除了非主属性对候选键的部分依赖。</p>
<p><strong>第三范式 3NF</strong></p>
<p>第三范式是确保每列都和主键列直接相关，而不是间接相关，即限制列的冗余性。 如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。</p>
<p>第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/关系模式">关系模式</a>R 中若不存在这样的码X、属性组Y及非主属性Z（Z (强制依赖)Y），使得X→Y，Y→Z，成立，Y→X不成立，则称R ∈ 3NF。</p>
<p>若R∈3NF，则R的每一个非主属性既不<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/部分函数依赖">部分函数依赖</a>于候选码也不<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/传递函数依赖">传递函数依赖</a>于候选码。</p>
<p>如果R∈3NF，则R也是2NF。</p>
<p>采用投影分解法将一个2NF的关系分解为多个3NF的关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。</p>
<p>将一个2NF关系分解为多个3NF的关系后，并不能完全消除<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/关系模式">关系模式</a>中的各种异常情况和数据冗余。</p>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h2><p><code>SELECT INTO</code>语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<p>常用于创建表的备份复件或者用于对记录进行存档。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] <span class="keyword">FROM</span> old_database</span><br></pre></td></tr></table></figure>
<p>或者只把需要的列插入新表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase]</span><br><span class="line"><span class="keyword">FROM</span> old_table_name</span><br></pre></td></tr></table></figure>
<h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO INCREMENT"></a>AUTO INCREMENT</h2><p><code>AUTO INCREMENT</code>（自动增长）语句会在新纪录插入表时生成一个唯一的数字。PostgreSQL使用序列来标识字段的自增长，数据类型有smallserial, serial和bigserial。</p>
<p>使用<code>AUTO INCREMENT</code>的原因：我们通常希望在每次插入新纪录时，自动地创建主键字段的值。因此我们可以在表中创建一个<code>AUTO INCREMENT</code>字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">伪类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>SMALLSERIAL</code></td>
<td style="text-align:left">2字节</td>
<td style="text-align:left">1 到 32,767</td>
</tr>
<tr>
<td style="text-align:left"><code>SERIAL</code></td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">1 到 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left"><code>BIGSERIAL</code></td>
<td style="text-align:left">8字节</td>
<td style="text-align:left">1 到 922,337,2036,854,775,807</td>
</tr>
</tbody>
</table>
</div>
<p>SERIAL数据类型的基础语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">	colName SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>假定我们要创建一张 COMPANY 表，并创建下面几个字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runoobdb<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID  SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   NAME           TEXT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在往表中插入几条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Paul&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">20000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Allen&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="number">15000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Teddy&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Norway&#x27;</span>, <span class="number">20000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Mark&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Rich-Mond &#x27;</span>, <span class="number">65000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;David&#x27;</span>, <span class="number">27</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="number">85000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Kim&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;South-Hall&#x27;</span>, <span class="number">45000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Houston&#x27;</span>, <span class="number">10000.00</span> );</span><br></pre></td></tr></table></figure>
<p>查看 COMPANY 表的记录如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> id | <span class="type">name</span>  | <span class="type">age</span> | <span class="type">address</span>    | <span class="type">salary</span></span><br><span class="line">----+-------+-----+------------+--------</span><br><span class="line">  <span class="number">1</span> | <span class="type">Paul</span>  |  <span class="type">32</span> | <span class="type">California</span> |  <span class="type">20000</span></span><br><span class="line">  <span class="number">2</span> | <span class="type">Allen</span> |  <span class="type">25</span> | <span class="type">Texas</span>      |  <span class="type">15000</span></span><br><span class="line">  <span class="number">3</span> | <span class="type">Teddy</span> |  <span class="type">23</span> | <span class="type">Norway</span>     |  <span class="type">20000</span></span><br><span class="line">  <span class="number">4</span> | <span class="type">Mark</span>  |  <span class="type">25</span> | <span class="type">Rich</span>-Mond  |  <span class="type">65000</span></span><br><span class="line">  <span class="number">5</span> | <span class="type">David</span> |  <span class="type">27</span> | <span class="type">Texas</span>      |  <span class="type">85000</span></span><br><span class="line">  <span class="number">6</span> | <span class="type">Kim</span>   |  <span class="type">22</span> | <span class="type">South</span>-Hall |  <span class="type">45000</span></span><br><span class="line">  <span class="number">7</span> | <span class="type">James</span> |  <span class="type">24</span> | <span class="type">Houston</span>    |  <span class="type">10000</span></span><br></pre></td></tr></table></figure>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种由事件自动触发执行的特殊存储过程，这些事件可以是对一个表进行 INSERT、UPDATE、DELETE 等操作。</p>
<p>触发器经常用于加强数据的完整性约束和业务规则上的约束等。</p>
<p>在SQL内部把触发器看作是存储过程但是不能传递参数。一般的存储过程通过存储过程名称被直接调用，而触发器主要是通过事件进行触发而被执行。</p>
<p>在SQL Server里就是对一个表的一定操作触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。</p>
<ul>
<li><p>SQL Server为每个触发器都创建了两个专用表﹕Inserted表和Deleted表。这两个表由系统来维护，它们存在于内存中而不是在数据库中。这两个表的结构总是与被该触发器作用的表的结构相同。触发器执行完成后，与该触发器相关的这两个表也被删除。 Deleted表存放由于执行Delete或Update语句而要从表中删除的所有行。 Inserted表存放由于执行Insert或Update语句而要向表中插入的所有行。</p>
</li>
<li><p>SQL Server提供了两种触发器：Instead of和After触发器。</p>
<p>这两种触发器的差别在于它们</p>
<ul>
<li>Instead of触发器用于替代引起触发器执行的T-SQL语句。除表之外，Instead of触发器也可以用于视图，用来扩展视图可以支持的更新操作。</li>
<li>After触发器在一个INSERT, UPDATE或DELETE语句之后执行，约束检查等动作都在After触发器被激活之前发生。After触发器只能用于表。一个表或视图的每一个修改动作(insert,update和delete)都可以有一个instead of 触发器，一个表的每个修改动作都可以有多个After触发器。</li>
</ul>
</li>
<li><p>触发器的执行过程：如果一个INSERT, UPDATE或DELETE语句违反了约束，那么After触发器不会执行，因为对约束的检查是在After触发器被激活之前发生的。所以After触发器不能超越约束。</p>
</li>
<li>Instead of 触发器可以取代激发它的操作来执行。它在Inserted表和Deleted表刚刚建立、其它任何操作还没有发生时被执行。因为Instead of 触发器在约束之前执行，所以它可以对约束进行一些预处理。</li>
</ul>
<p><strong>触发器创建语法</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">CONSTRAINT</span> ] <span class="keyword">TRIGGER</span> name</span><br><span class="line">&#123; BEFORE | AFTER | INSTEAD OF &#125; &#123; event [ OR ... ]&#125;</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line">[ FROM referenced_table_name ]&#123; NOT DEFERRABLE | [ DEFEREABLE ] &#123; IINITIALLY IMMEDIATE | INITIALLY DEFERED&#125; &#125;</span><br><span class="line">FOR [ EACH ] &#123; ROW | STATEMENT &#125;</span><br><span class="line">[ WHEN &#123; condition &#125;]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name ( arguments )</span><br></pre></td></tr></table></figure>
<h1 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h1><p>The general process of assuring that transactions preserve consistency when executing simultaneously is called <em>concurrency control</em>.</p>
<blockquote>
<p>The scheduler takes read/write requests from transactions and either executes them in buffers or delays them.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/04/01/SystemVerilog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/SystemVerilog/" class="post-title-link" itemprop="url">SystemVerilog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-01 20:01:54" itemprop="dateCreated datePublished" datetime="2021-04-01T20:01:54+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-03 11:43:21" itemprop="dateModified" datetime="2021-04-03T11:43:21+08:00">2021-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HDL/" itemprop="url" rel="index"><span itemprop="name">HDL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基于SystemVerilog的测试程序"><a href="#基于SystemVerilog的测试程序" class="headerlink" title="基于SystemVerilog的测试程序"></a>基于SystemVerilog的测试程序</h1><p>电路验证是确认所设计的电路功能正确性的过程，而仿真(simulation)是进行电路验证的主要手段，它可以及早发现所存在的设计问题，降低设计风险，节约设计成本。通常，仿真是通过编写测试程序(testbench)完成的。</p>
<p>测试程序也称为测试台，它是用于测试待测模块(Device Under Test, DUT)功能是否正确的一段SystemVerilog HDL代码，是不可综合的，由激励信号、DUT和输出响应三部分组成。</p>
<p>待测模块DUT：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line">                     <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">assign</span> y= ~b &amp; ~c | a &amp; ~b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>测试程序示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns          //预编译指令，定义时间单位和时间精度</span></span><br><span class="line"><span class="keyword">module</span> sillyfunction_tb();  <span class="comment">//测试程序没有输入/输出端口</span></span><br><span class="line">  <span class="keyword">logic</span> a, b, c, y;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.c</span>(c), <span class="variable">.y</span>(y)); <span class="comment">//实例化待测模块</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span>   <span class="comment">//给出激励信号</span></span><br><span class="line">    a = <span class="number">0</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;   <span class="comment">//000</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//001</span></span><br><span class="line">    b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;          <span class="comment">//010</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//011</span></span><br><span class="line">    a = <span class="number">1</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;   <span class="comment">//100</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//101</span></span><br><span class="line">    b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;          <span class="comment">//110</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">50</span>;                 <span class="comment">//111</span></span><br><span class="line">    <span class="built_in">$finish</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span>    <span class="comment">//输出结果，否则只产生波形</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a = %b, b = %b, c = %b, y = %b&quot;</span>, a, b, c, y);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h1 id="10-表示延迟10个时间单位，-monitor-time表示系统任务，"><a href="#10-表示延迟10个时间单位，-monitor-time表示系统任务，" class="headerlink" title="10 表示延迟10个时间单位，$monitor, $time表示系统任务，"></a>10 表示延迟10个时间单位，$monitor, $time表示系统任务，</h1><p>测试程序的模板如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> testbench_name();  <span class="comment">//testbench为顶层模块，不会被其他模块实例化，因此不需要任何端口</span></span><br><span class="line">  <span class="comment">//信号定义</span></span><br><span class="line">  <span class="comment">//模块实例化</span></span><br><span class="line">  <span class="comment">//添加激励信号</span></span><br><span class="line">  <span class="comment">//显示输出结果（可以不添加任何显示打印语句，只生成波形图即可）</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在SystemVerilog中，施加激励就是向DUT添加输入信号（即测试向量），主要有三种方法：</p>
<ol>
<li>通过initial过程块施加（线性）激励；</li>
<li>通过always过程块施加（循环）激励，主要用于产生时钟信号；</li>
<li>通过文件施加激励。</li>
</ol>
<h2 id="通过initial过程块施加激励"><a href="#通过initial过程块施加激励" class="headerlink" title="通过initial过程块施加激励"></a>通过initial过程块施加激励</h2><p>在initial块中施加激励，每个仿真时刻只用列出<strong>值需要改变的信号</strong>。initial块只执行一次。</p>
<p>在一个测试程序中可以包含多个initial块，并且它们都是<strong>同时并行执行</strong>，因此需要特别注意，不要在多个initial块中，在同一个仿真时刻对同一个信号赋值，否则将产生冲突。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//时刻0发生赋值</span></span><br><span class="line">  data_bus = <span class="number">8&#x27;h00</span>; addr = <span class="number">8&#x27;h3f</span>;</span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>; <span class="comment">//时刻10发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  #<span class="number">15</span> data_bus = <span class="number">8&#x27;hff</span>; <span class="comment">//时刻15发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//时刻0发生赋值</span></span><br><span class="line">  data_bus = <span class="number">8&#x27;h00</span>; addr = <span class="number">8&#x27;h3f</span>;</span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>; <span class="comment">//时刻10发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;hff</span>; <span class="comment">//错误，发送冲突</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="通过文件施加激励"><a href="#通过文件施加激励" class="headerlink" title="通过文件施加激励"></a>通过文件施加激励</h2><p>将激励（测试向量）存放在一个文本文件中，测试程序从文件中读取激励，对DUT进行测试。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction_tb();</span><br><span class="line">  <span class="keyword">logic</span> a,b,c,y;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] stim [<span class="number">7</span>:<span class="number">0</span>];  <span class="comment">//声明一个logic类型的数组stim</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a),<span class="variable">.b</span>(b),<span class="variable">.c</span>(c),<span class="variable">.y</span>(y));</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;testvector.txt&quot;</span>,stim); <span class="comment">//将所有激励读入数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      &#123;a,b,c&#125;=stim[i]; #<span class="number">10</span>;  <span class="comment">//依次测试各个激励</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a = %b, b = %b, c = %b, y = %b&quot;</span>, a, b, c, y);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testvector.txt</span><br><span class="line"><span class="number">000</span></span><br><span class="line"><span class="number">001</span></span><br><span class="line"><span class="number">010</span></span><br><span class="line"><span class="number">011</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure>
<h2 id="输出响应"><a href="#输出响应" class="headerlink" title="输出响应"></a>输出响应</h2><p>在SystemVerilog中，输出响应是指在向DUT的输入端施加激励后，通过观察DUT输出的结果，并与预期结果进行比较，以验证电路功能是否正确。这一过程可通过观测波形图或借助SystemVerilog HDL提供的一系列<strong>系统任务</strong>显示输出结果来实现。</p>
<p>SystemVerilog HDL中常用的系统任务包括：</p>
<p>获取仿真时间：$time</p>
<p>显示信号值：$display, $monitor</p>
<p>结束/中断仿真：$finish, $stop</p>
<p>文件输入：$readmemb, $readmmemh</p>
<p>文件输出：$fopen, $fclose, $fdisplay, $fmonitor</p>
<h3 id="获取仿真时间"><a href="#获取仿真时间" class="headerlink" title="获取仿真时间"></a>获取仿真时间</h3><p>获取仿真时间的系统任务的返回值使用由<code>`timescale</code>定义的时间单位。如：</p>
<p><code>`timescale 1ns/1ps</code></p>
<p><code>`timescale 1ns/1ns</code></p>
<p>$time返回一个64位的整数时间值</p>
<p>$stime返回一个32位的整数时间值</p>
<p>$realtime返回一个实数时间值</p>
<p>如：<code>$monitor($time,&quot;a=%b b=%b c=%b y=%b&quot;,a,b,c,y)</code></p>
<h2 id="显示信号值"><a href="#显示信号值" class="headerlink" title="显示信号值"></a>显示信号值</h2><p>显示信号值的系统任务包括：$display和$monitor</p>
<p><code>$display($time,&quot;a=%b&quot;,a);</code></p>
<p><code>$monitor($time,&quot;a=%b&quot;,a);</code></p>
<p>$display和$monitor的区别在于前者只有执行到该语句时才会进行显示操作，而后者是一个监视器，只要输出变量列表中的某个变量发生变化，就执行一次显示操作。后者使用更方便。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>%h</th>
<th>%o</th>
<th>%d</th>
<th>%b</th>
<th>%c</th>
<th>%s</th>
<th>%t</th>
<th>%m</th>
</tr>
</thead>
<tbody>
<tr>
<td>hexadecimal</td>
<td>octonary</td>
<td>decimal</td>
<td>binary</td>
<td>ASCII</td>
<td>字符串</td>
<td>时间</td>
<td>模块名</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结束-中断仿真"><a href="#结束-中断仿真" class="headerlink" title="结束/中断仿真"></a>结束/中断仿真</h2><p>结束/中断仿真的系统任务包括：$finish和$stop，用于对仿真过程进行控制。</p>
<p>$finish;</p>
<p>$finish(n);</p>
<p>$stop;</p>
<p>$stop(n);</p>
<p>参数n可以取0, 1等值，”0”表示不输出任何信息，”1”表示给出仿真时间。</p>
<h2 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h2><p>在SystemVerilog HDL中文件输入不需要打开文件操作，直接读取文件即可，相关的系统任务包括：$readmemb和$readmemh，前者读取2进制数据，后者读取16进制数据。</p>
<p>$readmemb(“数据文件名”, 数组(存储器)名, &lt;起始地址&gt;, &lt;结束地址&gt;);<br>$readmemh(“数据文件名”, 数组(存储器)名, &lt;起始地址&gt;, &lt;结束地址&gt;);</p>
<p>起始地址和结束地址均可缺省。</p>
<p>文件格式：</p>
<ul>
<li><p>可用”_”提高数据可读性</p>
</li>
<li><p>可包含单行或多行注释</p>
</li>
<li><p>可用<strong>空格</strong>或<strong>换行</strong>来区分单个数据</p>
</li>
<li><p>可以设定一个特定地址，规定其后的数据从该地址开始存储，格式如下：</p>
<p><code>@hex_addr</code></p>
<p>地址必须是16进制，且大小写不敏感，并且@和地址之间不允许有空格。</p>
</li>
</ul>
<p>例如：</p>
<p><strong>testmem.txt:</strong></p>
<p>0000_0000<br>0110_0001 0011_0010<br>//地址3-255没有定义<br>@100     //hex, 256<br>1111_1100<br>//地址257-1022没有定义<br>@3FF<br>1100_0010</p>
<p><strong>数组stim:</strong><br>0    00000000<br>1    01100001<br>2    00110010<br>3<br>4<br>…<br>255<br>256    11111100<br>257<br>…<br>1022<br>1023    11000010</p>
<p><strong>code:</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] stim [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//$readmemb(&quot;testmem.txt&quot;,stim);</span></span><br><span class="line">  <span class="built_in">$readmemb</span>(<span class="string">&quot;testmem.txt&quot;</span>,stim,<span class="number">0</span>,<span class="number">1023</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>在SystemVerilog HDL中文件输出需要先打开文件，相应的系统任务为$fopen，然后可以通过系统任务$fdisplay或$fmonitor将需要保存的信息输入到指定文件中。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MCD;</span><br><span class="line">MCD = <span class="built_in">$fopen</span>(<span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;操作模式&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(MCD, <span class="string">&quot;显示格式控制符&quot;</span>, &lt;输出变量(信号)列表&gt;);</span><br><span class="line"><span class="built_in">$fmonitor</span>(MCD, <span class="string">&quot;显示格式控制符&quot;</span>, &lt;输出变量(信号)列表&gt;);</span><br><span class="line"><span class="built_in">$fclose</span>(MCD);</span><br></pre></td></tr></table></figure>
<p>$fopen打开指定文件并返回一个32位整数，若打开失败，则返回0。操作模式为w, w+, a, a+.</p>
<p>$fclose关闭打开的文件。</p>
<p>$fdisplay和$fmonitor的用法与$display和$monitor的用法一致。</p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>示例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction_tb();</span><br><span class="line">  <span class="keyword">logic</span> a,b,c,y,yexpected;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] stim [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a),<span class="variable">.b</span>(b),<span class="variable">.c</span>(c),<span class="variable">.y</span>(y));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;at_vec.txt&quot;</span>,stim);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      &#123;a,b,c,yexpected&#125;=stim[i]; #<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(y==yexpected)</span><br><span class="line">        <span class="built_in">$display</span>(<span class="built_in">$time</span>,<span class="string">&quot;test pass!&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="built_in">$time</span>,<span class="string">&quot;Error: inputs=%b,%b,%b&quot;</span>,&#123;a,b,c&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at_vec.txt</span><br><span class="line"></span><br><span class="line">000_1</span><br><span class="line">001_0</span><br><span class="line">010_0</span><br><span class="line">...</span><br><span class="line">111_0</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/03/18/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">pthread多线程编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-18 21:31:33" itemprop="dateCreated datePublished" datetime="2021-03-18T21:31:33+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-19 00:26:07" itemprop="dateModified" datetime="2021-03-19T00:26:07+08:00">2021-03-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" itemprop="url" rel="index"><span itemprop="name">并行计算</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线程函数需要声明为<code>void*</code>类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The function to be executed by the thread should take a</span></span><br><span class="line"><span class="comment"> * void* parameter and return a void* exit status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Cast the parameter into what is needed.</span></span><br><span class="line">  <span class="keyword">int</span> *incoming=(<span class="keyword">int</span>*)arg;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Do whatever is necessary using *incoming as the argument.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The thread terminates when this function returns.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread_ID;</span><br><span class="line">  <span class="keyword">void</span> *exit_status;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Put something meaningful into value.</span></span><br><span class="line">  value=<span class="number">42</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create the thread, passing &amp;value for the argument.</span></span><br><span class="line">  pthread_create(&amp;thread_ID,<span class="literal">NULL</span>,thread_function,&amp;value);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The main program continues while the thread executes.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Wait for the thread to terminate.</span></span><br><span class="line">  pthread_join(thread_ID,&amp;exit_status);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Only the main thread is running now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要函数：</p>
<ol>
<li>Create a new thread</li>
</ol>
<p><code>pthread_create()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_t</span> *tid,									<span class="comment">//thread ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,			<span class="comment">//thread attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*),	<span class="comment">//pointer to function to execute</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *arg												<span class="comment">//argument to function</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Return value: 0 if successful. Error code from <errno.h> otherwise.</p>
<p>Notes: Use a structure to pass multiple arguments to the start routine.</p>
<ol>
<li>Wait for a thread to terminate</li>
</ol>
<p><code>pthread_join</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">pthread_t</span> tid,		<span class="comment">//wait for a thread to terminate</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> **status;		<span class="comment">//thread ID to wait for</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Return value: 0 for success. Error code from <errno.h> otherwise.</p>
<p>Notes: Once a thread is joined, the thread no longer exists, its thread ID is no longer valid, and it cannot be joined with any other thread.</p>
<ol>
<li>Get my own thread ID</li>
</ol>
<p><code>pthread_self</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>Return value: The ID of the thread that called this function.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/03/14/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/14/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Java面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-14 13:35:57" itemprop="dateCreated datePublished" datetime="2021-03-14T13:35:57+08:00">2021-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-15 22:56:44" itemprop="dateModified" datetime="2021-03-15T22:56:44+08:00">2021-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><p>静态变量被类中的所有对象共享。静态方法不能访问类中的实例成员。</p>
<p>如果想让一个类中的所有实例共享数据，就要使用<em>静态变量</em>（static variable），也称<em>类变量</em>（class variable）。静态变量将变量值存储在一个公共的内存地址。因为是公共的，所以如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受影响。</p>
<p>无需创建类的实例就可以调用<em>静态方法</em>（static method）。</p>
<p>要声明一个静态变量或定义一个静态方法，就需要中声明中加上修饰符static。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numberOfObjects;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumberOfObjects</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> numberOfObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Math类中所有的方法都是静态的。main方法也是静态方法。</p>
<p>类中的常量是被该类的所有对象所共享的。因此，常量应该声明为<code>final static</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> PI = <span class="number">3.1415</span>;</span><br></pre></td></tr></table></figure>
<p>实例方法可以调用实例方法和静态方法，访问实例数据域或静态数据域。静态方法只能调用静态方法和访问静态数据域。因为静态方法和静态数据域不属于某个特定的对象。</p>
<blockquote>
<p>一个常见的设计错误就是将一个本应该声明为静态的方法声明为实例方法。例如<code>factorial(int n)</code>应该定义为是静态的，因为它不依赖于任何具体的实例。</p>
</blockquote>
<h1 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h1><p>可见性修饰符可以用于确定一个类以及它的成员的可见性。</p>
<p>可以在类、方法和数据域前使用public修饰符，表示它们可以被任何其他的类访问。如果没有可见性修饰符，则默认类、方法和数据域是可以被同一个包中的任何一个类访问的。这称作<em>包私有</em>（package-private）或<em>包内访问</em>（package- access）。</p>
<blockquote>
<p>包可以用来组织类。用下面的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br></pre></td></tr></table></figure>
<p>如果定义时没有包，就表示把它放在默认包中。</p>
<p>Java建议最好把类放入包中，而不要使用默认包。</p>
</blockquote>
<p>private修饰符限定方法和数据域只能在它自己的类中被访问。</p>
<p><img src="/Users/preccrep/Desktop/x.png" alt="x"></p>
<p>如果一个类没有被定义为公共类，则它只能在同一个包内被访问。</p>
<h1 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h1><blockquote>
<p>可以定义不可变类来产生不可变对象。不可变对象的内容不能被改变。</p>
</blockquote>
<p>通常创建一个对象后，它的内容是允许之后改变的。有时候也需要创建一个一旦创建其内容就不能再改变的对象。我们称这种对象为一个<em>不可变对象</em>（immutable object），而它的类就是<em>不可变类</em>（immutable class）。例如，String类就是不可变的。如果把set方法去掉，也可能变为不可变类。</p>
<p>如果一个类是不可变的，那么它的所有数据域必须都是私有的，而且没有对任何一个数据域提供公共的set方法。但是这只是充分条件。反例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> java.util.Date dateCreated;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> ssn, String newName)</span></span>&#123;</span><br><span class="line">    id=ssn;</span><br><span class="line">    name=newName;</span><br><span class="line">    dateCreated=<span class="keyword">new</span> java.util.Date();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getDateCreated</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dateCreated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getDateCreated方法返回的是一个引用。通过这个引用可以改变getDateCreated的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Student student=<span class="keyword">new</span> Student(<span class="number">111222333</span>,<span class="string">&quot;Mika&quot;</span>);</span><br><span class="line">    java.util.Date dateCreated=student.getDateCreated();</span><br><span class="line">    dateCreated.setTime(<span class="number">200000</span>); <span class="comment">//Now dateCreated field is changed!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p><strong>实例变量和静态变量的作用域是整个类，无论变量是在哪里声明的。</strong></p>
<p>一个类的实例变量和静态变量称为<em>类变量</em>（class’s variables）或<em>数据域</em>（data field）。在方法内部定义的变量是局部变量。</p>
<p>类变量只能声明一次，但是在一个方法内不同的非嵌套块中，可以多次声明相同的变量名。</p>
<p>如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量被隐藏。</p>
<h1 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h1><p>关键字this引用对象自身。它也可以在构造方法内部用于调用同一个类的其他构造方法。</p>
<p><strong>关键字this是指向调用对象本身的引用名。</strong>可以用this关键字引用对象的实例成员。</p>
<p>在引用隐藏数据域（例如set方法将数据域名作为参数名）以及调用一个重载的构造方法的时候，this引用是必须的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius=radius; <span class="comment">//关键字this可以用于引用隐藏数据域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">1.0</span>); <span class="comment">//关键字this可以用于调用同一个类的另一个构造方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p>面向对象编程允许从已经存在的类中定义新的类，这称为继承。</p>
<p>继承能够避免冗余并使系统更易于理解和易于维护。</p>
<h2 id="父类和子类"><a href="#父类和子类" class="headerlink" title="父类和子类"></a>父类和子类</h2><p>如果类C1扩展自另一个类C2，那么称C1为<em>次类</em>（subclass），C2为<em>超类</em>（superclass）。超类也称<em>父类</em>（parent class）或<em>基类</em>（base class），次类又称<em>子类</em>（child class）、<em>扩展类</em>（extended class）或<em>派生类</em>（derived class）。子类从它的父类中继承可访问的数据域或方法，还可添加新数据域和新方法。</p>
<p>父类中的私有数据域是不能被子类访问的，但是可以用get和set方法。</p>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>一个Java类只可能直接继承自一个父类，这种限制称为单一继承（single inheritence）。如果使用extends关键字来定义一个子类，它只允许有一个父类。然而，多重继承是可以直接通过接口来实现的。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>关键字super指代父类，可以用于调用父类中的普通方法和构造方法。</p>
<h3 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h3><p>构造方法用于构建一个类的实例。不同于属性和普通方法，父类的构造方法不会被子类继承。它们只能使用关键字super从子类的构造方法中调用。</p>
<p>调用父类构造方法的语法是：<code>super 或 super(parameters)</code></p>
<p>语句<code>super()</code>调用父类的无参构造方法，而语句<code>super(arguments)</code>调用与参数匹配的父类的构造方法。它们必须出现在子类构造方法的第一行，这是显示调用父类构造方法的唯一方式。在子类中调用父类构造方法的名字会引起一个语法错误。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleFromSimpleGeometricObject</span><span class="params">(<span class="keyword">double</span> radius,String color,<span class="keyword">boolean</span> filled)</span></span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(color,filled);</span><br><span class="line">  <span class="keyword">this</span>.radius=radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleFromSimple</span><span class="params">(<span class="keyword">double</span> radius,String color, <span class="keyword">boolean</span> filled)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius=radius;</span><br><span class="line">	setColor(color);</span><br><span class="line">	setFilled(filled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法链（IMPORTANT 354 355）</strong></p>
<h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><p>语法是：<code>super.methodName(parameters)</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="keyword">super</span>.getDateCreated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>要重写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义。</p>
<p>子类从父类中继承方法，有时子类需要修改父类中定义的方法的实现，这称作<strong>方法重写</strong>（method overriding）。</p>
<p>例如GeometricObject类中的toString方法返回表示几何对象的字符串。这个方法可以被重写，返回表示圆的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="comment">//toString is originally defined in Father</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">&quot;\nradius is &quot;</span>+radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Son使用super.toString()访问Father中的toString方法，但是GrandSon不能使用super.super.toString()访问Father中的toString方法。这是一个语法错误。</p>
<blockquote>
<p><strong>值得注意的是：</strong></p>
<p>仅当实例方法是可访问时，它才可被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法是父类中私有的，那么这两个方法完全没有关系。</p>
<p>与实例方法一样，静态方法也能被继承。但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法名（SuperClassName.staticMethodName）调用隐藏的静态方法。</p>
</blockquote>
<p>重载意味着使用同样的名字但是不同的签名来定义多个方法。</p>
<p>重写意味着在子类中提供一个对方法的新的实现。</p>
<ul>
<li>方法重写发生在通过继承而相关的不同类中；方法重载可以发生在同一个类中，也可以发生在由于继承而相关的不同类中。</li>
<li>方法重写具有相同的签名和返回值类型；方法重载具有相同的名字，但是不同的参数列表。</li>
</ul>
<p>为了避免错误，可以使用一个特殊的Java语法，成为重写标注（override annotation），在子类的方法前面放一个@Override。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="comment">//toString is originally defined in Father</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">&quot;\nradius is &quot;</span>+radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该标注表示被标注的方法必须重写父类的一个方法。如果具有该标注的方法没有重写父类的方法，编译器将会报错。</p>
<h1 id="Object类及其toString-方法"><a href="#Object类及其toString-方法" class="headerlink" title="Object类及其toString()方法"></a>Object类及其toString()方法</h1><p>Java中的所有类都继承自<code>java.lang.Object</code>类。</p>
<p>如果在定义一个类时没有指定继承性，那么这个类的父类就被默认为是Object。例如下面两个类的定义是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString()方法的签名是：<code>public String toString()</code></p>
<p>默认情况下，它返回一个由该对象所属的类名、@符号以及该对象十六进制形式的内存地址组成的字符串。但是通常这个结果没什么用。所以考虑重写这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;created on &quot;</span>+dateCreated+<span class="string">&quot;\ncolor: &quot;</span>+color+<span class="string">&quot; and filled: &quot;</span>+filled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object hahaha=<span class="keyword">new</span> Object();</span><br><span class="line">		System.out.println(hahaha); <span class="comment">//或System.out.println(hahaha.toString());</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：java.lang.Object@dcf3e99</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态意味着父类的变量可以指向子类对象。</p>
<p>首先定义两个属于：子类型和父类型。一个类实际上定义了一种类型，子类定义的类型称为子类型（subtype），父类定义的称为父类型（supertype）。</p>
<p>继承关系使一个子类继承父类的特征，并且附加一些新特征。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">preccrep</p>
  <div class="site-description" itemprop="description">serial processing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">preccrep</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
