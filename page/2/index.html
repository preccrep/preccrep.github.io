<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"preccrep.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="serial processing">
<meta property="og:type" content="website">
<meta property="og:title" content="Serial">
<meta property="og:url" content="https://preccrep.github.io/page/2/index.html">
<meta property="og:site_name" content="Serial">
<meta property="og:description" content="serial processing">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="preccrep">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://preccrep.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Serial</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Serial" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Serial</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">of or relating to the sequential performance of multiple operations</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">80</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/02/10/I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/I/" class="post-title-link" itemprop="url">Note for Computer Networking, Chapter I</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-10 20:19:16" itemprop="dateCreated datePublished" datetime="2021-02-10T20:19:16+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-16 23:53:40" itemprop="dateModified" datetime="2021-02-16T23:53:40+08:00">2021-02-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="What-is-the-Internet"><a href="#What-is-the-Internet" class="headerlink" title="What is the Internet"></a>What is the Internet</h1><blockquote>
<p>主机（host）和端系统（end system）有什么区别？列举几种不同类型的端系统。Web服务器是一种端系统吗？</p>
</blockquote>
<p>没有不同，只是两种不同的叫法。<br>智能手机、电脑、电视、WEB服务器、游戏机等等。<br>如上所述，WEB服务器也是一种端系统。</p>
<h2 id="从硬件和软件组件的角度描述因特网"><a href="#从硬件和软件组件的角度描述因特网" class="headerlink" title="从硬件和软件组件的角度描述因特网"></a>从硬件和软件组件的角度描述因特网</h2><blockquote>
<p>端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起</p>
</blockquote>
<p><strong>通信链路</strong>有许多类型，它们由不同类型的物理媒体组成。这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输数据，链路的<strong>传输速率</strong>（transmission rate）以比特/秒（bit/s, or bps）度量。当一台端系统要向另一台端系统发送数据时，<em>发送端系统（sending end system）</em>将数据分段，并为每段加上首部字节（When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment.）。由此形成的信息包成为<strong>分组</strong>（packet）。这些分组通过网络发送到<em>目的端系统（destination end system）</em>，在那里被装配成初始数据。</p>
<p><strong>分组交换机</strong>从它的一条<em>入通信链路（incoming communication links）</em>接收到达的分组，并从它的一条<em>出通信链路（outgoing communication links）</em>转发该分组。分组交换机类型很多，最著名的是<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。</p>
<p>链路层交换机通常用于<em>接入网（access networks）</em>中，而路由器通常用于<em>网络核心（network core）</em>中。</p>
<p>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机成为通过该网络的<strong>路径</strong>（route or path）。</p>
<blockquote>
<p>泽字节：zettabyte，10^21字节</p>
</blockquote>
<p>端系统通过<strong>因特网服务提供商</strong>（Internet Service Provider, ISP）接入因特网。较低层的ISP通过国家的、国际的较高层ISP（如Level 3 Communications、AT&amp;T、Sprint和NTT）互联起来。较高层ISP是由通过高速光纤链路互联的高速路由器组成的。无论是较高层还是较低层ISP网络，它们每个都是独立管理的，运行着IP协议（详情见后），遵从一定的命名和地址规则。</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），这些协议控制因特网中信息的接收和发送。<strong>TCP</strong>（Transmission Control Protocol，传输控制协议）和<strong>IP</strong>（Internet Protocol，网际协议）是因特网中两个最为重要的协议。</p>
<p>IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p>
<p><strong>因特网标准</strong>（Internet standard）由因特网工程任务组（Internet Engineering Task Force, IETF）研发。IETF的标准文档称为<strong>请求评论</strong>（Request For Comment, RFC）。RFC最初只是普通的请求评论（因此而得名），目的是解决因特网先驱者们面临的网络和协议问题。RFC文档往往是技术性很强并相当详细的。它们定义了TCP、IP、HTTP（用于Web）和SMTP（用于电子邮件）等协议。</p>
<h2 id="从为应用程序提供服务的基础设施的角度描述因特网"><a href="#从为应用程序提供服务的基础设施的角度描述因特网" class="headerlink" title="从为应用程序提供服务的基础设施的角度描述因特网"></a>从为应用程序提供服务的基础设施的角度描述因特网</h2><blockquote>
<p>涉及多个相互交换数据的端系统的的应用程序称为<strong>分布式应用程序</strong>（distributed application）。</p>
<p>因特网应用程序运行在端系统上，即它们并不运行在网络核心中的分组交换机中。分组交换机能够加速端系统之间的数据交换，并不在意应用程序。</p>
<p>运行在一个端系统上的应用程序如何让因特网向运行在另一个端系统上的软件发送数据？</p>
<p>与因特网相连的端系统提供了一个<strong>套接字接口</strong>（socket interface），该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。</p>
</blockquote>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><strong>协议</strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事物所采取的动作。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>端系统位于因特网的边缘，包括桌面计算机、服务器（Web和电子邮件）和移动计算机。</p>
<p>端系统也称为主机，因为它们容纳（即运行）应用程序，如Web浏览器程序、Web服务器程序、电子邮件客户程序或电子邮件服务器程序等。</p>
<p>主机有时又被进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。客户通常是桌面PC、移动PC和智能手机等；服务器通常是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等。如今大部分提供搜索结果、电子邮件、Web页面和视频的服务器都属于大型<strong>数据中心</strong>（data center）。</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网是将端系统物理连接到其<strong>边缘路由器</strong>（edge router）的网络。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h4 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h4><p>宽带住宅接入有两种最流行的类型：<strong>数字用户线</strong>（Digital Subscriber Line, DSL）和<strong>电缆</strong>。住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。例如，每个用户的DSL调制解调器使用现有的电话线（即双绞铜线）与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的DSL调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在DSLAM处被转换回数字形式。</p>
<p>家庭电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码：</p>
<ul>
<li>高速下行信道，位于50kHz到1MHz频段；</li>
<li>中速上行信道，位于4kHz到50kHz频段；</li>
<li>普通的双向电话信道，位于0到4kHz频段.</li>
</ul>
<p>这种方法使单根DSL线路看起来就像有3根单独的线路一样，因此一个电话呼叫和一个因特网连接能够同时共享DSL线路。在用户一侧，一个分配器把到达家庭的数据信号和电话信号分隔开，并将数据信号转发给DSL调制解调器。在电话公司一侧，在CO中，DSLAM把数据和电话信号分隔开，并将数据送往因特网。数百甚至上千个家庭与同一个DSLAM相连。</p>
<p>DSL利用电话公司现有的本地电话基础设施，而<strong>电缆因特网接入</strong>（cable Internet access）利用了有线电视公司现有的有线电视基础设施。住宅从提供有线电视的公司获得了电缆因特网接入。</p>
<p>在<strong>混合光纤同轴</strong>（Hybrid Fiber Coax, HFC）系统中，光缆将电缆头端连接到地区枢纽，从这里使用传统的同轴电缆到达各家各户和公寓。</p>
<p>电缆因特网接入需要特殊的调制解调器，称为<em>电缆调制解调器（cable modem）</em>。</p>
<p>电缆因特网接入的一个重要特征是共享广播媒体。</p>
<p>还有一种更高速率的接入方式是<strong>光纤到户</strong>（Fiber To The Home, FTTH），即从本地中心局直接到家庭连一条光线路径。</p>
<h3 id="企业（和家庭）接入：以太网和WiFi"><a href="#企业（和家庭）接入：以太网和WiFi" class="headerlink" title="企业（和家庭）接入：以太网和WiFi"></a>企业（和家庭）接入：以太网和WiFi</h3><p>使用局域网（LAN）将端系统连接到边缘路由器。</p>
<p>以太网用户使用双绞铜线与一台以太网交换机相连，以太网交换机或这样相连的交换机网络，则再与更大的因特网相连。</p>
<h3 id="广域无线接入：3G和LTE"><a href="#广域无线接入：3G和LTE" class="headerlink" title="广域无线接入：3G和LTE"></a>广域无线接入：3G和LTE</h3><p>电信公司已经在所谓第三代（3G）无线技术中进行了大量投资，3G为分组交换广域无线因特网接入提供了超过1Mbps的速率。甚至更高速率的广域接入技术即第四代（4G）广域无线网络也已经被部署了。</p>
<p>LTE（长期演进，Long-Term Evolution）来源于3G技术，它能够取得超过10Mbps的速率。</p>
<h2 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h2><blockquote>
<p>前面提到的物理媒体：</p>
<p>HFC使用光缆和同轴电缆，DSL和以太网使用双绞铜线，移动接入网使用无线电频谱</p>
</blockquote>
<p>对于每个发射器-接收器对，通过跨越一种<strong>物理媒体</strong>（physical medium）传播电磁波或光脉冲来发送该比特。该物理媒体可具有多种形状和形式，并且对沿途的每个发射器-接收器对不必具有相同的类型。</p>
<blockquote>
<p>物理媒体分为<strong>导引型媒体</strong>（guided media）和<strong>非导引型媒体</strong>（unguided media）。对于导引型媒体，电波沿着固体媒体前行，如光缆、双铜绞线或同轴电缆。对于非引导型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中。</p>
</blockquote>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心是由互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>（store-and-forward transmission）机制。</p>
<blockquote>
<p>在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
</blockquote>
<p>该分组的比特缓存在路由器中，直到该分组的所有比特全部到达路由器才会向目的地传输。</p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer，也成为<strong>输出队列</strong>），它用于存储路由器准备发往那条链路的分组。如果到达的分组发现要走的链路还在传输其他分组，那么该分组就必须等待。因此，除了存储转发时延，还有输出缓存的<strong>排队时延</strong>（queuing delay）。</p>
<p>这些时延是变化的，变化程度取决于网络的拥塞程度。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现<strong>分组丢失（丢包）</strong>（packet loss），到达的分组或已经排队的分组之一将被丢弃。</p>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>每个端系统都有一个IP地址。源在该分组的首部包含了目的地IP地址。</p>
<p>当一个分组到达路由器时，路由器检查目的地址那部分，并向一台相邻路由器转发该分组。每台路由器具有一个<strong>转发表</strong>（forwarding table）。</p>
<p>因特网具有一些特殊的<strong>路由选择协议</strong>（routing protocol），用于自动地设置这些转发表。例如，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>（circuit switching）和<strong>分组交换</strong>（packet switching）。</p>
<p>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。也就是说原则上是不需要等待的。</p>
<h5 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h5><p>链路中的电路是通过<strong>频分复用</strong>（Frequency-Division Multiplexing, FDM）或<strong>时分复用</strong>（Time-Division Multiplexing, TDM）来实现的。对于FDM，链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段。在电话网络中，这个频段的宽度通常为4kHz（即每秒4000周期）。该频段的宽度称为<strong>带宽</strong>（bandwidth）。调频无线电台也使用FDM来共享88MHz~108MHz的频谱，其中每个电台被分配一个特定的频段。</p>
<p>对于一条TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙，这些时隙由该连接专门使用，一个时隙（在每个帧内）可用于传输该连接的数据。</p>
<blockquote>
<p>考虑从主机A到主机B经一个电路交换网络发送一个640000比特的文件需要多长时间。假如在该网络中所有链路使用具有24时隙的TDM，比特速率为1.536Mbps。同时假定在主机A能够开始传输该文件之前，需要500ms创建一条端到端电路。它需要多长时间才能发送该文件？每条链路具有的传输速率是1. 536Mbps/24 = 64kbps，因此传输该文件需要（640kb）/（64kbps） =10s。这个10s，再加上电路创建时间，这样就需要10.5s发送该文件。值得注意的是，该传输时间与链路数量无关：端到端电路不管是通过一条链路还是100条链路，传输时间都将是10s。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/01/23/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/23/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">最大流问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-23 11:02:48 / Modified: 12:09:10" itemprop="dateCreated datePublished" datetime="2021-01-23T11:02:48+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>最大流问题</strong></p>
<p>以V为节点集，A为弧集，有向图G = ( V, A ).</p>
<p>L( i, j )是( i, j )的容量下界，U( i, j )是( i, j )的容量上界。节点 i 对应的权d(i)是顶点 i 的供需量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/01/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">旋转数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-08 19:53:01 / Modified: 19:56:06" itemprop="dateCreated datePublished" datetime="2021-01-08T19:53:01+08:00">2021-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">source</a></p>
<p>题目不难，但是我觉得很有用。</p>
<p><strong>方法1 — 使用额外数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/26/IA-32-Linux%E4%B8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/IA-32-Linux%E4%B8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/" class="post-title-link" itemprop="url">IA-32/Linux下逻辑地址-线性地址-物理地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-26 11:02:29 / Modified: 11:04:18" itemprop="dateCreated datePublished" datetime="2020-12-26T11:02:29+08:00">2020-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NEMU/" itemprop="url" rel="index"><span itemprop="name">NEMU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CPU内部的存储器就是寄存器</p>
<p>分层存储器存在的意义：让存储器又快又大</p>
<p>存储器越靠近CPU速度越大，容量越小</p>
<p>局部性原理达到分层的效果</p>
<p>英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。</p>
<p>IA-32架构属于复杂指令集，由英特尔公司开发，1985年，随着Intel 80386的上市，被公之于世。接下来20年的时间，虽然后继的新型芯片运算速度不断增加，但IA-32架构大体上都没有改变。对许多编程语言来说，IA-32与i386是同义词。</p>
<p>英特尔也是世界上最大的IA-32芯片供应商，AMD则是第二大的供应商。2011年，英特尔与AMD同时采用了新的x86-64架构，但是x86架构仍然被应用在如Intel Atom（N2xx与Z5xx系列）、AMD Geode等芯片上。威盛电子生产的VIA C3/C7，也仍然采用IA-32架构。</p>
<p>IA-32微处理器支持实模式和保护模式。</p>
<p><strong>实模式</strong></p>
<p>相当于高性能的16位8086微处理器，但进行了功能扩充，能够使用8086所没有的寻址方式和32位通用寄存器以及大部分指令。不具有保护机制，不能使用部分特权指令。实模式下只有20条地址线有效，存储空间为1MB。</p>
<p><strong>保护模式</strong></p>
<p>充分发挥IA-32微处理器的存储管理功能和硬件支持的保护机制，为多任务操作系统设计提供支持。该模式下每个任务的存储空间为4GB。</p>
<p>在保护模式下还具有一种子模式——虚拟8086模式（V86模式），可以在保护模式的多任务环境中以类似实模式的方式运行16位8086软件。</p>
<p>按字节编址（通用计算机大都是）</p>
<p>在<strong>保护模式</strong>下，IA-32采用<strong>段页式虚拟存储</strong>管理方式</p>
<p>逻辑地址和线性地址是虚拟地址，是编程用的地址；描述的都是4GB虚拟地址空间中的一个存储地址。</p>
<p>物理地址是访问存储器的地址，是真实地址。</p>
<blockquote>
<p>逻辑地址：48位，包含16位段选择符和32位段内偏移量（即<strong>有效地址</strong>）</p>
<p>线性地址：32位（其位数由虚拟地址空间大小决定）</p>
<blockquote>
<p>32位处理器，所以虚拟成32位</p>
</blockquote>
<p>物理地址：32位（其位数由存储器总线中的地址线条数决定）</p>
<blockquote>
<p>对于物理地址：（实际的不知道）假设就是32位，那外面的物理存储器可能就是4GB(2^32B=4GB)</p>
</blockquote>
</blockquote>
<p><strong><em>分段过程实现   逻辑地址 —&gt; 线性地址</em></strong></p>
<p><strong><em>分页过程实现    线性地址—&gt;物理地址</em></strong></p>
<h1 id="逻辑地址到线性地址（分段）"><a href="#逻辑地址到线性地址（分段）" class="headerlink" title="逻辑地址到线性地址（分段）"></a>逻辑地址到线性地址（分段）</h1><p><em>8086处理器的所有内部寄存器都是16位（AX, BX, CX, DX, SP, BP, SI, <strong>CS</strong>, <strong>DS</strong>）</em></p>
<p>（CS、DS是段寄存器）</p>
<p><em>8086处理器支持的存储器寻址方式有哪些？</em></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">位移</td>
<td style="text-align:center">EA = A</td>
</tr>
<tr>
<td style="text-align:center">基址寻址</td>
<td style="text-align:center">EA = (B)</td>
</tr>
<tr>
<td style="text-align:center">基址加位移</td>
<td style="text-align:center">EA = (B) + A</td>
</tr>
<tr>
<td style="text-align:center">比例变址加位移</td>
<td style="text-align:center">EA = (I) * S + A</td>
</tr>
<tr>
<td style="text-align:center">基址加变址加位移</td>
<td style="text-align:center">EA = (B) + (I) + A</td>
</tr>
<tr>
<td style="text-align:center">基址加比例变址加位移</td>
<td style="text-align:center">EA = (B) + (I) * S + A</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>A — 地址段偏移量</p>
<p>B — 基址寄存器</p>
<p>I — 变址寄存器（除SP）</p>
<p>S — 比例因子</p>
<p>EA — 有效地址</p>
</blockquote>
<p>8086指令（AT&amp;T格式）举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw 8(%bp, %dx, 4), %ax   &#x2F;&#x2F;R[ax] &lt;-- M[R[bp] + R[dx]*4 + 8]</span><br></pre></td></tr></table></figure>
<p>此时的寻址空间是 2^16B = 64KB，太小了！</p>
<p>于是8086引入段寄存器开辟更大的寻址空间：</p>
<blockquote>
<p>16位段寄存器（CS, SS, DS, ES等）</p>
<p>物理访存地址 = (段寄存器 &lt;&lt; 4) + 有效地址</p>
</blockquote>
<p>于是寻址空间变为 1MB了（2^16&lt;&lt; 4 B = 2^20 B = 1MB）</p>
<p>此时的物理地址称为<strong>线性地址</strong>。</p>
<p>于是就变成了：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">位移</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + A</td>
</tr>
<tr>
<td style="text-align:center">基址寻址</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + (B)</td>
</tr>
<tr>
<td style="text-align:center">基址加位移</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + A</td>
</tr>
<tr>
<td style="text-align:center">比例变址加位移</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + (I) * S + A</td>
</tr>
<tr>
<td style="text-align:center">基址加变址加位移</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + (I) + A</td>
</tr>
<tr>
<td style="text-align:center">基址加比例变址加位移</td>
<td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + (I) * S + A</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw [ds:8(%bp, %dx, 4)], %ax   &#x2F;&#x2F;R[ax] &lt;-- M[R[ds]&lt;&lt;4 + R[bp] + R[dx]*4 + 8]</span><br></pre></td></tr></table></figure>
<p>访问数据段就是和DS绑定的，访问代码段就是和CS绑定的。取指令要用到CS和IP，访问堆栈用到SS，等等。</p>
<p>物理访存地址 = (段寄存器 &lt;&lt; 4) + 有效地址—<strong>这个访问模式称为实模式！</strong></p>
<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>8086处理器在实模式下工作：</p>
<blockquote>
<p>物理地址直接访存</p>
<p>可访问 1MB 主存空间</p>
<p>需要20根地址线（2^20，因为加上了(SR&gt;&gt;4)）</p>
<p>每次访存必须和某个段寄存器绑定</p>
</blockquote>
<p>存在的问题：</p>
<blockquote>
<p>寻址空间有限</p>
<p>存在安全隐患</p>
</blockquote>
<p>IA-32，即80386，标志着32位计算机的时代到来。</p>
<p>所有通用寄存器都是32位，寻址空间达到4GB！</p>
<p>正式支持虚拟存储器的概念，采用虚拟地址访存。</p>
<blockquote>
<p>寻址空间已经达到4GB，是否可以去掉段寄存器？</p>
<p>不能。考虑兼容性！</p>
</blockquote>
<p>于是IA-32处理器支持两种工作模式：</p>
<blockquote>
<p>实模式：IA-32处理器加电或复位时处于这一模式，此时相当于8086/8088处理器，32位地址线中的A31~A20不起作用，所有访存地址都是物理地址（实地址）。</p>
<p>保护模式：完成系统初始化后，进入该模式，此时32位地址线全部起作用，访存地址为逻辑地址（虚拟地址），进入虚拟存储器管理方式。</p>
</blockquote>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>IA-32有一个”开关”，决定处理器处于哪种模式下：</p>
<p>CR0寄存器与通用寄存器不同，是另外一种寄存器。它叫控制状态寄存器。</p>
<blockquote>
<p>对实模式和保护模式来说看哪一位呢？</p>
<p><strong>最后一位。（第0位，即PE位）</strong></p>
</blockquote>
<p>计算机加电或复位时，PE = 0，IA-32处理器处于实模式。</p>
<p>PE = 1时，处于保护模式，并且一旦进入保护模式就不能再切换回到实模式了，除非…重启（重新开机复位）。</p>
<p>（所以只能从实模式进保护模式）</p>
<p><em>为什么IA-32分段机制更复杂？</em></p>
<blockquote>
<p>与历史遗留问题有关：</p>
<p>寻址空间有限，仅1MB.</p>
<p>存在安全隐患。</p>
<p>段大小固定(64KB(2^16 B))</p>
<p>不灵活，无法设置访问权限。</p>
<p>……</p>
</blockquote>
<p>进入IA-32时代，我们希望段地址也是32位的，还可以灵活设置各种段属性，但段寄存器只有16位，连32位段基址也放不下，怎么办？</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p><strong>段描述符</strong>是用来描述一个段所有属性的数据结构。</p>
<p>每个段对应一个段描述符。</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201225173007530.png" alt="image-20201225173007530"></p>
<p>一个段描述符占8个字节（64位），包括：</p>
<p>B31~B0：32位基地址</p>
<p>L19~L0：20位限界，表示段的大小</p>
<p>G：粒度。G = 1以页（4KB）为单位，G = 0以字节为单位。因为界限为20位，故当G = 0时最大的段为1MB；当G = 1时，最大段为4KB*2^20=4GB。</p>
<p>D：D = 1表示段内偏移量为32位宽，D = 0表示段内偏移量为16位宽。</p>
<p>P：present. P = 1表示段在主存里，P = 0表示段不在主存里。Linux总把P置1，不会以段为单位淘汰，因为Linux以页为单位。</p>
<p>S：S = 0表示系统控制描述符，S = 1表示普通的代码段或数据段描述符。</p>
<p>TYPE：段的访问权限或系统控制描述符类型。</p>
<p>A：A = 1表示已被访问过，A = 0表示未被访问过（TYPE一般是4位，A是其中的1位）</p>
<p>DPL：权限位。</p>
<h3 id="段描述符的组织"><a href="#段描述符的组织" class="headerlink" title="段描述符的组织"></a><strong>段描述符的组织</strong></h3><blockquote>
<p>（Q represents question, P represents preccrep）</p>
<p>Q：<em>段描述符占64位，段寄存器才16位，根本放不下，怎么办？</em></p>
<p>P：放到主存中。</p>
<p>Q：<em>可是怎么在主存中找到一个段描述符？</em></p>
<p>P：利用指针。</p>
<p>Q：<em>IA-32中涉及到地址的，还是32位。所以段描述符的地址也一定是32位的，段寄存器放不下，只能放到主存里。IA-32中的指针也是32位的，段寄存器还是放不下；即使能放下，如果想切换到其他段，怎么知道段描述符在什么地方？</em></p>
<p>P：把所有的段描述符组织成一个数组啊。</p>
<p>Q：<em>？</em></p>
<p>P：段描述符只是一个数据结构，一旦找到段描述符，就能把段的基地址读出来，然后就能访问到相应的段了，问题就解决了。所以关键是怎么找到段描述符。没错，段描述符的地址一定是32位地址，因为它们是放在主存里的。在IA-32里，我们把所有段描述符都组成一个数组，数组索引用16位总能放下吧！用数组索引访问！就是——</p>
</blockquote>
<p>IA-32把内存中的某一连续空间解释成一个数组，称为<strong>段描述符表</strong>，简称<strong>段表</strong>。数组中每个元素对应一个段描述符。</p>
<p>段表由OS负责填写。包括3种类型：</p>
<blockquote>
<p>全局描述符表(GDT)：只有一个，是所有进程共享的，用来保存系统中每个任务都可以访问的段描述符，如内核代码段、数据段，用户代码段、数据段等。</p>
<p>局部描述符表(LDT)：存放某一用户进程专用的描述符（其他用户进程是访问不到的），但LDT不是一个独立的段表，它就保存在GDT中，甚至可以看作是GDT里的一个段描述符。</p>
<p>中断描述符表(IDT)：独立于GDT的段表，包含中断门、陷阱门等描述符。例如系统调用的函数入口地址就要从IDT中获取。</p>
</blockquote>
<p>GDT的首地址由<strong>全局描述符表寄存器（GDTR）</strong>提供。</p>
<p>GDTR这个寄存器<strong>只存放</strong>GDT的入口地址！</p>
<p>还有，段表不是一个大数组吗，我们是通过数组索引找到所需的描述符的，而该索引不就保存在段寄存器中吗，它称为<strong>段选择符</strong>。</p>
<h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a><strong>GDTR</strong></h3><p>GDTR的结构长这样：</p>
<p>BASE ADDR(基地址)    |   LIMIT(限界)</p>
<p>32-bit                            |   16-bit</p>
<p>高32位存放GDT的入口地址，低16位存放GDT的大小。</p>
<p>当然，GDTR最大也就64位。这里是48位。</p>
<blockquote>
<p>Q：<em>GDTR中保存的地址是线性地址，为什么不是逻辑地址？</em></p>
<p>P：我们分段机制用它(GDTR)不就是为了把逻辑地址变为线性地址吗。要是GDTR中也是逻辑地址，那这个首地址(GDT的首地址)谁来给它变？</p>
</blockquote>
<p><strong>GDTR对用户进程不可见</strong>，只有OS才能访问。仅可由OS内核通过一条特权指令(lgdt m16&amp;32)将GDT的首地址和限界装载到GDTR中，启动分段机制。</p>
<h3 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a><strong>段选择符和段寄存器</strong></h3><blockquote>
<p>CS(代码段)：程序代码所在段</p>
<p>SS(栈段)：栈区所在段</p>
<p>DS(数据段)：全局静态数据区所在段</p>
<p>其他3个段寄存器ES、GS和FS可指向任意数据段</p>
</blockquote>
<h3 id="段选择符各字段含义"><a href="#段选择符各字段含义" class="headerlink" title="段选择符各字段含义"></a><strong>段选择符各字段含义</strong></h3><p>15   14 … 3  |  2   |  1   0</p>
<p> INDEX         |  TI  |  RPL</p>
<p>TI = 0，选择GDT；TI = 1，选择LDT。</p>
<p>RPL请求特权级。</p>
<p><strong>高13位索引</strong>用来确定当前使用的段描述符在描述表中的位置。</p>
<p>——&gt; <strong>由此可知，GDT中最多可容纳 2^13=8192=8K 个段描述符。</strong></p>
<p>那么整个段表多大？（1个段描述符占8个字节）</p>
<p>8K*8 B = 64KB.</p>
<p>而段寄存器是16位，2^16 = 64K个字节——刚好相等呀！</p>
<p>没错，16位就是这么来的。</p>
<p>于是，回归正题，逻辑地址怎么变到线性地址？</p>
<p>先看TI位。若TI = 0，那就先从GDTR里把GDT首地址读出来，然后加上索引——注意，是索引乘上8！乘上字节的宽度！基地址+索引*8.</p>
<p>GDT和IDT只有一个，GDTR和IDTR指向各自起始处。</p>
<p>LDTR  16-bit</p>
<p>GDTR, IDTR  48-bit</p>
<p>每次段寄存器装入新选择符时，新描述符装入描述符cache，在逻辑地址到线性地址转换时，MMU直接用描述符cache中的信息，不必访问主存段表</p>
<p>LDTR存放LDT描述符的段选择符</p>
<p>LDT描述符在GDT中</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201225200258987.png" alt="image-20201225200258987"></p>
<p>总之，逻辑地址转线性地址的过程就是这样：</p>
<ol>
<li>逻辑地址高16位是段选择符，低32位是段内偏移。</li>
<li>通过段寄存器中的段选择符TI位决定在哪个表中查找。</li>
<li>根据GDTR读出段描述符表的首地址。</li>
<li>根据段寄存器中的段选择符index位在表中进行索引，找到一个段描述符。</li>
<li>在段描述符中读出段的基地址，和逻辑地址相加，得到线性地址。</li>
</ol>
<p>在计算线性地址的过程中，可根据段描述符中的限界和访问权限判断是否“地址越界”或“访问越权”，以实现存储保护。</p>
<blockquote>
<p>Q：<em>索引 为什么乘以8？</em></p>
<p>P：1个段描述符占8个字节。</p>
<p>Q：<em>被选中的段描述符存放在什么地方？</em></p>
<p>P：描述符cache里。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>逻辑地址起作用的<strong>前提</strong>：CR0的PE位为1，进入保护模式，启动分段机制。</li>
<li>根据<strong>段寄存器中的段选择符</strong>的TI位决定查GDT还是LDT</li>
<li>在GDTR中读出GDT首地址</li>
<li>GDT首地址+段选择符中索引*8 — 得到段描述符首地址</li>
<li>在段描述符中读出段基址，和有效地址（逻辑地址后32位，即段内偏移）相加，得到线性地址</li>
</ol>
<p>注意那个前提——否则实模式下有效地址就是线性地址，段寄存器也就用来左移4位加上有效地址得到物理地址了。</p>
<h1 id="IA-32-Linux中的存储保护"><a href="#IA-32-Linux中的存储保护" class="headerlink" title="IA-32/Linux中的存储保护"></a>IA-32/Linux中的存储保护</h1><h2 id="IA-32的权限检查（基于环保护机制）"><a href="#IA-32的权限检查（基于环保护机制）" class="headerlink" title="IA-32的权限检查（基于环保护机制）"></a>IA-32的权限检查（基于环保护机制）</h2><p>DPL：位于段描述符中，表示一个段所在的特权级别。例如，DPL为3说明该段可能是一个用户段，为0可能是内核段。</p>
<p>RPL：位于段选择符中，表示请求者所在的特权级别。</p>
<p>CPL：表示当前进程的特权级别，一般与CS寄存器指向的段描述符的DPL字段相同。</p>
<p>同时满足以下两个条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_descriptor.DPL &gt;= requestor.RPL   <span class="comment">//请求者有权访问目标段</span></span><br><span class="line">target_descriptor.DPL &gt;= CPL             <span class="comment">//当前进程有权访问目标段</span></span><br></pre></td></tr></table></figure>
<p>只要OS将GDT、页表等重要信息放在ring0段中，恶意程序将永远无法篡改它们，除非恶意程序获得了OS权限。</p>
<h2 id="IA-32-Linux中的分段机制"><a href="#IA-32-Linux中的分段机制" class="headerlink" title="IA-32/Linux中的分段机制"></a>IA-32/Linux中的分段机制</h2><p>为能被移植到绝大多数流行处理器平台，Linux简化了分段机制。</p>
<p>RISC对分段支持非常有限，因此<strong>Linux仅使用IA-32的分页机制</strong>，而对于分段，则通过<strong>在初始化时将所有段描述符的基址设为”0”来简化</strong>。</p>
<p>每个段都被初始化在 0~4GB 的线性地址空间中。</p>
<p>PA2中的用户程序都是从 <code>kernel/src/start.S</code> 开始的。PA3也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">#ifndef IA32_SEG</span><br><span class="line"></span><br><span class="line">	.globl start</span><br><span class="line">	start:</span><br><span class="line">	# Set up a stack for C code.</span><br><span class="line">		movl $0, %ebp</span><br><span class="line">		movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">		jmp init				# never return</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">	# To understand macros here, see i386 manual.</span><br><span class="line">	#define GDT_ENTRY(n) ((n) &lt;&lt; 3)</span><br><span class="line"></span><br><span class="line">	#define MAKE_NULL_SEG_DESC   \</span><br><span class="line">		.word 0, 0;              \</span><br><span class="line">		.byte 0, 0, 0, 0</span><br><span class="line"></span><br><span class="line">	# The 0xC0 means the limit is in 4096-byte units</span><br><span class="line">	# and (for executable segments) 32-bit mode.</span><br><span class="line">	#define MAKE_SEG_DESC(type,base,lim)                        \</span><br><span class="line">		.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span><br><span class="line">		.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span><br><span class="line">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><span class="line"></span><br><span class="line">	#ifdef IA32_PAGE</span><br><span class="line">	#	define KOFFSET 0xc0000000</span><br><span class="line">	#	define va_to_pa(x) (x - KOFFSET)</span><br><span class="line">	#else</span><br><span class="line">	#	define va_to_pa(x) (x)</span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">	.globl start</span><br><span class="line">	start:</span><br><span class="line">		lgdt    va_to_pa(gdtdesc) # See i386 manual for more information</span><br><span class="line">		movl    %cr0, %eax        # %CR0 |&#x3D; PROTECT_ENABLE_BIT</span><br><span class="line">		orl     $0x1, %eax</span><br><span class="line">		movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">	# Complete transition to 32-bit protected mode by using long jmp</span><br><span class="line">	# to reload %CS and %EIP.  The segment descriptors are set up with no</span><br><span class="line">	# translation, so that the mapping is still the identity mapping.</span><br><span class="line">		ljmp    $GDT_ENTRY(1), $va_to_pa(start_cond)</span><br><span class="line"></span><br><span class="line">	start_cond:</span><br><span class="line">	# Set up the protected-mode data segment registers</span><br><span class="line">		movw    $GDT_ENTRY(2), %ax</span><br><span class="line">		movw    %ax, %ds          # %DS &#x3D; %AX</span><br><span class="line">		movw    %ax, %es          # %ES &#x3D; %AX</span><br><span class="line">		movw    %ax, %ss          # %SS &#x3D; %AX</span><br><span class="line"></span><br><span class="line">	# Set up a stack for C code.</span><br><span class="line">		movl $0, %ebp</span><br><span class="line">		movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">		jmp init				# never return</span><br><span class="line"></span><br><span class="line">	# GDT</span><br><span class="line">	.p2align 2                    # force 4 byte alignment</span><br><span class="line">	gdt:</span><br><span class="line">		MAKE_NULL_SEG_DESC                   # empty segment</span><br><span class="line">		MAKE_SEG_DESC(0xA, 0x0, 0xffffffff)  # code</span><br><span class="line">		MAKE_SEG_DESC(0x2, 0x0, 0xffffffff)  # data</span><br><span class="line"></span><br><span class="line">	gdtdesc:                      # descriptor</span><br><span class="line">		.word   (gdtdesc - gdt - 1)    # limit &#x3D; sizeof(gdt) - 1</span><br><span class="line">		.long   va_to_pa(gdt)          # address of GDT</span><br><span class="line"></span><br><span class="line"># end of IA32_SEG</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在来逐段分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef IA32_SEG</span><br></pre></td></tr></table></figure>
<p>这个是分段的宏，PA2里没考虑分段，也就没用到，所以直接跳到内核里去了。但是在PA3中，这个宏就要起作用了。在 <code>kernel/include/common.h</code> 中设置，把 <code>define IA32_SEG</code> 前的注释符号去掉。</p>
<blockquote>
<p>除了 <code>#define</code> 中的 <code>#</code> 外，其他的 <code>#</code> 都是注释！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">	start:</span><br><span class="line">	# Set up a stack for C code.</span><br><span class="line">		movl $0, %ebp</span><br><span class="line">		movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">		jmp init				# never return</span><br></pre></td></tr></table></figure>
<p>PA2没用分段（即没用 IA32_SEG 宏，not define，满足 <code>#ifndef</code>），就执行上面的部分；</p>
<p>PA3用了分段，就执行 <code>#else</code> 的部分.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAKE_NULL_SEG_DESC   \</span><br><span class="line">		.word 0, 0;              \</span><br><span class="line">		.byte 0, 0, 0, 0</span><br></pre></td></tr></table></figure>
<p>这个宏是将 <code>MAKE_NULL_SEG_DESC</code> 替换为下面那两个东西…</p>
<p><code>.word</code> 和 <code>.byte</code> 就是汇编里的声明数据。声明为 <code>.word</code> 就是说那两个0都是 <code>.word</code> 类型，也就是16位宽，所以这里声明了两个16位的0。<code>.byte</code> 声明的是字节，相当于C语言中的 <code>char</code> 类型。2个16位的加上4个8位的，一共就是8个字节。所以——</p>
<p>这就是一个段描述符！只不过这是一个空的段描述符，因为都是0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define MAKE_SEG_DESC(type,base,lim)                        \</span><br><span class="line">		.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span><br><span class="line">		.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span><br><span class="line">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br></pre></td></tr></table></figure>
<p>这个宏还带参数的啊—— <code>type</code> ，<code>base</code> ，<code>lim</code> ——这不就是段描述符里的信息吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef IA32_PAGE</span><br><span class="line">	#	define KOFFSET 0xc0000000</span><br><span class="line">	#	define va_to_pa(x) (x - KOFFSET)</span><br><span class="line">	#else</span><br><span class="line">	#	define va_to_pa(x) (x)</span><br><span class="line">	#endif</span><br></pre></td></tr></table></figure>
<p>定没定义PAGE，自己决定用哪个函数。</p>
<p>最核心的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">	start:</span><br><span class="line">		lgdt    va_to_pa(gdtdesc) # See i386 manual for more information</span><br><span class="line">		movl    %cr0, %eax        # %CR0 |&#x3D; PROTECT_ENABLE_BIT</span><br><span class="line">		orl     $0x1, %eax</span><br><span class="line">		movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>再来看这个——<code>lgdt</code> ，将全局描述符表的首地址和大小加载到了GDTR里。这里 <code>va_to_pa</code> 只有1个参数 <code>gdtdesc</code> ，这是一个地址，而由 <code>#define va_to_pa(x) (x)</code> 得知，这不就是 <code>gdtdesc</code> 本身吗。那这到底是什么东西呢，看下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdtdesc:                      # descriptor</span><br><span class="line">		.word   (gdtdesc - gdt - 1)    # limit &#x3D; sizeof(gdt) - 1</span><br><span class="line">		.long   va_to_pa(gdt)          # address of GDT</span><br></pre></td></tr></table></figure>
<p>嗯，不就是把 <code>gdtdesc</code> 里面的 <code>.word</code> 和 <code>.long</code> 加载过去吗？ <code>.word</code> 是16位的， <code>.long</code> 是32位的。它们是什么注释里都写清楚了，要强调的是 <code>gdtdesc - gdt - 1</code> 的这个减一。</p>
<p>当然，再看看这个 <code>gdtdesc</code> ，不就刚好是48位吗？没错，<code>lgdt</code> 就是把48位的逻辑地址加载到GDTR中去。</p>
<p>继续看start的代码。先把CR0的值放到EAX里，然后EAX与1进行OR，再把得到的值放回CR0。我们分析一下，当 “CR0最低位” = 0时，这一番操作使得 “CR0最低位” = 1，这就是实模式 —&gt; 保护模式。</p>
<h1 id="线性地址到物理地址（分页）"><a href="#线性地址到物理地址（分页）" class="headerlink" title="线性地址到物理地址（分页）"></a>线性地址到物理地址（分页）</h1><h2 id="IA-32中的控制寄存器"><a href="#IA-32中的控制寄存器" class="headerlink" title="IA-32中的控制寄存器"></a>IA-32中的控制寄存器</h2><p>控制寄存器保存机器的各种控制和状态信息，操作系统进行任务控制或存储管理时使用控制寄存器。</p>
<p><strong>CR0</strong>：PG位：</p>
<p>1 - 启用分页</p>
<p>0 - 禁止分页，此时线性地址被直接作为物理地址使用。</p>
<p>若启用分页机制，PE和PG位都要置1.</p>
<p><strong>CR2</strong>：页故（page fault）障线性地址寄存器</p>
<p>当要访问的页不在主存里时，触发了缺页中断，中断处的线性地址保存在CR2里，等到页面被调入后再继续从这里开始执行。</p>
<p><strong>CR3</strong>：页目录基址寄存器</p>
<p>保存页目录表的起始地址。</p>
<p>当然，CR2和CR3有效的前提都是PG = 1。</p>
<p>Linux中线性地址空间划分：4GB = 1K个子空间 <em> 1K个页面/子空间 </em> 4KB/页</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201226101431856.png" alt="image-20201226101431856"></p>
<p>每一个页表就是一个子空间，页表中有1K项，每一项对应一个物理页；</p>
<p>页目录表只有1张，里面有1K个页目录项，每一项对应一个页表。</p>
<blockquote>
<p>每1K个页面用一个页表进行组织，每个页表有1K个项，每项对应一个物理页（页框）</p>
<p>线性地址由3个字段组成，分别是10位页目录索引，10位页表索引，12位页内偏移</p>
</blockquote>
<p>CR3中存放的就是页目录表的基地址，拿到基地址后加上DIR*4（为什么乘以4？因为一个页目录项是32位，即4字节），得到相应页表项的首地址。再加上PAGE*4，得到物理页的首地址。物理页首地址再加上页内偏移量，就是真正的物理地址。</p>
<h2 id="页目录项和页表项的格式"><a href="#页目录项和页表项的格式" class="headerlink" title="页目录项和页表项的格式"></a>页目录项和页表项的格式</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201226105427190.png" alt="image-20201226105427190"></p>
<p>CPU发出地址先送到MMU，MMU完成分段和分页再送到cache。MMU中的分段解决逻辑地址到物理地址的变换，分页解决线性地址到物理地址的变换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">分治算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-23 22:19:38" itemprop="dateCreated datePublished" datetime="2020-12-23T22:19:38+08:00">2020-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 13:19:02" itemprop="dateModified" datetime="2020-12-24T13:19:02+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(tr,tc)是棋盘左上角的方格坐标</span></span><br><span class="line"><span class="comment">(dr,dc)是特殊方格所在坐标</span></span><br><span class="line"><span class="comment">size是棋盘的行数和列数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1025</span></span><br><span class="line"><span class="keyword">int</span> board[N][N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tile = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr, <span class="keyword">int</span> tc, <span class="keyword">int</span> dr, <span class="keyword">int</span> dc, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">int</span> t = tile++; <span class="comment">//L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s = size/<span class="number">2</span>; <span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="comment">//覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        ChessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">//覆盖其余方格</span></span><br><span class="line">        ChessBoard(tr, tc, tr + s - <span class="number">1</span>, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        Chessboard(tr, tc + s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖左下角子棋盘 </span></span><br><span class="line">	<span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">		ChessBoard(tr + s, tc, dr, dc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右上角</span></span><br><span class="line">		board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">		<span class="comment">//覆盖其余方格 </span></span><br><span class="line">		ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//覆盖右下角子棋盘 </span></span><br><span class="line">	<span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &gt;= t c+ s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">		ChessBoard(tr + s, tc + s, dr, dc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖左上角 </span></span><br><span class="line">		board[tr + s][tc + s] = t;</span><br><span class="line">		<span class="comment">//覆盖其余方格 </span></span><br><span class="line">		ChessBoard(tr + s, tc + s, tr + s, tc + s, s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k) &#123;  <span class="comment">//k cases</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        board[x][y] = <span class="number">0</span>;</span><br><span class="line">        ChessBoard(<span class="number">0</span>, <span class="number">0</span>, x, y, size);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; board[i][j] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span>^k</span><br><span class="line">需(n-<span class="number">1</span>)/<span class="number">3</span>个L型骨牌填满</span><br><span class="line">算法的时间复杂度: t(n)=<span class="number">4</span>t(n/<span class="number">4</span>)+c</span><br><span class="line">Master <span class="function"><span class="keyword">Method</span>求解得到:</span> t(n)=Theta(n)</span><br></pre></td></tr></table></figure>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/merge-sort/">source</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program for Merge Sort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merges two subarrays of arr[].</span></span><br><span class="line"><span class="comment">// First subarray is arr[l..m]</span></span><br><span class="line"><span class="comment">// Second subarray is arr[m+1..r]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n1 = m - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n2 = r - m;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create temp arrays</span></span><br><span class="line">	<span class="keyword">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy data to temp arrays L[] and R[]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">		L[i] = arr[l + i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">		R[j] = arr[m + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Merge the temp arrays back into arr[l..r]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of first subarray</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of second subarray</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of merged subarray</span></span><br><span class="line">	<span class="keyword">int</span> k = l;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">			arr[k] = L[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			arr[k] = R[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the remaining elements of</span></span><br><span class="line">	<span class="comment">// L[], if there are any</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">		arr[k] = L[i];</span><br><span class="line">		i++;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the remaining elements of</span></span><br><span class="line">	<span class="comment">// R[], if there are any</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">		arr[k] = R[j];</span><br><span class="line">		j++;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l is for left index and r is</span></span><br><span class="line"><span class="comment">// right index of the sub-array</span></span><br><span class="line"><span class="comment">// of arr to be sorted */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//returns recursively</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (l+r<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	mergeSort(arr,l,m);</span><br><span class="line">	mergeSort(arr,m+<span class="number">1</span>,r);</span><br><span class="line">	merge(arr,l,m,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UTILITY FUNCTIONS</span></span><br><span class="line"><span class="comment">// Function to print an array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> arr_size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Given array is \n&quot;</span>;</span><br><span class="line">	printArray(arr, arr_size);</span><br><span class="line"></span><br><span class="line">	mergeSort(arr, <span class="number">0</span>, arr_size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSorted array is \n&quot;</span>;</span><br><span class="line">	printArray(arr, arr_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by Mayank Tyagi</span></span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    QuickSort(a, l, j - <span class="number">1</span>);</span><br><span class="line">    QuickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找第-k-小的元素"><a href="#寻找第-k-小的元素" class="headerlink" title="寻找第 k 小的元素"></a>寻找第 k 小的元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">select</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, j + <span class="number">1</span>, r, k - j + l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> select(a, l, j - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="距离最接近的点对"><a href="#距离最接近的点对" class="headerlink" title="距离最接近的点对"></a>距离最接近的点对</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35678407/article/details/82874216">source</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    point() &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(A.x - B.x, <span class="number">2</span>) + <span class="built_in">pow</span>(A.y - B.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* function: 合并，同第三区域最近点距离比较</span></span><br><span class="line"><span class="comment">* param: points 点的集合</span></span><br><span class="line"><span class="comment">*        dis 左右两边集合的最近点距离</span></span><br><span class="line"><span class="comment">*        mid x坐标排序后，点集合中中间点的索引值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points, <span class="keyword">double</span> dis, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; left, right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].x - points[mid].x &lt;= <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &gt; -dis)</span><br><span class="line">            left.push_back(points[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(points[i].x - points[mid].x &gt; <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &lt; dis)</span><br><span class="line">            right.push_back(points[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(right.begin(), right.end(), cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, index; i &lt; left.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; right.size() &amp;&amp; left[i].y &lt; right[index].y; index++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span> &amp;&amp; index + j &lt; right.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(left[i], right[j + index]) &lt; dis)</span><br><span class="line">                dis = distance(left[i], right[j + index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">2</span>) <span class="keyword">return</span> distance(points[<span class="number">0</span>], points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">3</span>) <span class="keyword">return</span> min(distance(points[<span class="number">0</span>], points[<span class="number">1</span>]), min(distance(points[<span class="number">0</span>], points[<span class="number">2</span>]), distance(points[<span class="number">1</span>], points[<span class="number">2</span>])));</span><br><span class="line">    <span class="keyword">int</span> mid = (points.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d1, d2, d;</span><br><span class="line">    vector&lt;point&gt; left(mid + 1), right(points.size() - mid - 1);</span><br><span class="line">    copy(points.begin(), points.begin() + mid + <span class="number">1</span>, left.begin()); <span class="comment">//左边区域点集合</span></span><br><span class="line">    copy(points.begin() + mid + <span class="number">1</span>, points.end(), right.begin()); <span class="comment">//右边区域点集合</span></span><br><span class="line">    d1 = closest(left);</span><br><span class="line">    d2 = closest(right);</span><br><span class="line">    d = min(d1, d2);</span><br><span class="line">    <span class="keyword">return</span> merge(points, d, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;点个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; points;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个点&quot;</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        points.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(points.begin(), points.end(), cmp_x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最近点对值：%lf&quot;</span>, closest(points));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 <code>n*n</code> 的矩阵 A 与 B 的乘积是另一个 <code>n*n</code> 的矩阵 C，则：进行了 n^3 次乘法和 n^2(n-1) 次加法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/18/Directory-Symbolic-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/18/Directory-Symbolic-Link/" class="post-title-link" itemprop="url">Directory-Symbolic-Link</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-18 21:37:42" itemprop="dateCreated datePublished" datetime="2020-12-18T21:37:42+08:00">2020-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-19 12:42:42" itemprop="dateModified" datetime="2020-12-19T12:42:42+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>In the context of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>:</p>
<p><code>MKLINK [[/D] | [/H] | [/J]] Link Target</code></p>
<pre><code>    /D      创建目录符号链接。默认为文件
            符号链接。
    /H      创建硬链接而非符号链接。
    /J      创建目录联接。
    Link    指定新的符号链接名称。
    Target  指定新链接引用的路径
            (相对或绝对)。
</code></pre><ol>
<li><p>Isn’t a <strong>directory junction</strong> the exact same thing as a <strong>directory symbolic link</strong>?</p>
<p>What’s the difference between <code>mklink /D f1 f2</code> and <code>mklink /J f1 f2</code> ?</p>
</li>
<li><p>Since a “directory” is actually just a <em>file</em>, what would be the difference between a directory symbolic link and a file symbolic link?</p>
</li>
</ol>
<p>A junction is definitely not the same thing as a directory symbolic link, although they behave similarly. The main difference is that, if you are looking at a remote server, <strong>junctions are processed at the server</strong> and <strong>directory symbolic links are processed at the client</strong>. Also see Matthew’s comment on the fact that this means symbolic links on the local file system can point to remote file systems.</p>
<p>Suppose that on a machine named Alice you were to put a junction point <code>c:\myjp</code> and a directory symbolic link <code>c:\mysymlink</code>, both pointing to <code>c:\targetfolder</code>. While you’re using Alice you won’t notice much difference between them. But if you’re using another machine named Bob, then the junction point</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\m</span>yjp` will point to `<span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\t</span>argetfolder</span><br></pre></td></tr></table></figure>
<p>but the symbolic link</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\m</span>ysymlink` will point to `<span class="symbol">\\</span>Bob<span class="symbol">\c</span>$<span class="symbol">\t</span>argetfolder</span><br></pre></td></tr></table></figure>
<p>(Caveat: by default, the system doesn’t follow symlinks on remote volumes, so in most cases the second example will actually result in either <em>“File Not Found”</em> or <em>“The symbolic link cannot be followed because its type is disabled.”</em>)</p>
<p>The difference between a directory symbolic link and a file symbolic link is simply that one represents a directory and one represents a file. Since the target of the link doesn’t need to exist when the link is created, the file system needs to know whether to tell applications that it is a directory or not.</p>
<p>It should also be noted that creating a symbolic link requires special privilege (by default, only available to elevated processes) whereas creating a junction only requires access to the file system.</p>
<p><a target="_blank" rel="noopener" href="https://superuser.com/questions/343074/directory-junction-vs-directory-symbolic-link/343079#343079">source</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">动态规划练习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 10:42:20" itemprop="dateCreated datePublished" datetime="2020-12-17T10:42:20+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 21:11:06" itemprop="dateModified" datetime="2020-12-28T21:11:06+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>此文会不定期更新</p>
</blockquote>
<h1 id="购买股票问题"><a href="#购买股票问题" class="headerlink" title="购买股票问题"></a>购买股票问题</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode714.买卖股票的最佳时机含手续费</a></p>
<blockquote>
<p>给定一个整数数组 prices，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8</p>
<ul>
<li><code>0 &lt; prices.length &lt;= 50000</code>.</li>
<li><code>0 &lt; prices[i] &lt; 50000</code>.</li>
<li><code>0 &lt;= fee &lt; 50000</code>.</li>
</ul>
<p><code>dp[i][0]</code> 表示第 <code>i</code> 天未持有股票的最大利润，<code>dp[i][1]</code> 表示第 <code>i</code>天持有股票的最大利润。</p>
<p>那么对于 <code>dp[i][0]</code> ，它的来源有两种：第一种是在第 <code>i - 1</code> 天时手中就没有股票，到了第 <code>i</code> 天仍然没有；第二种是在第 <code>i - 1</code> 天手中有股票，到了第 <code>i</code> 天就卖出了。因此得到递推关系式：</p>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)</code></p>
<p>对于 <code>dp[i][1]</code> ，它的来源也有两种：第一种是在第 <code>i - 1</code> 天手中就有股票，第 <code>i</code> 天也没有抛售出去；第二种是在第 <code>i - 1</code> 天未持有股票，在第 <code>i</code> 天购入。递推关系式为：</p>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<p>初始条件为：</p>
<p><code>dp[0][0] = 0</code> ：第 0 天什么也没买</p>
<p><code>dp[0][1] = -prices[0]</code> ：第 0 天买了，那么就只可能买 prices[0] 的股票。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> dp[<span class="number">50010</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode188.买卖股票的最佳时机</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/11/%E8%99%9A%E6%8B%9F-%E9%80%BB%E8%BE%91-%E7%BA%BF%E6%80%A7-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/11/%E8%99%9A%E6%8B%9F-%E9%80%BB%E8%BE%91-%E7%BA%BF%E6%80%A7-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">虚拟/逻辑/线性/物理地址到底是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-11 19:08:04 / Modified: 19:15:36" itemprop="dateCreated datePublished" datetime="2020-12-11T19:08:04+08:00">2020-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>指的是由程序产生的由<code>段选择符</code>和<code>段内偏移地址</code>两个部分组成的地址。为什么叫它是虚拟的地址呢？因为这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换机构处理或映射后才会对应到相应的物理内存地址。</p>
<h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>指由程序产生的与段相关的偏移地址部分。不过有些资料是直接把逻辑地址当成虚拟地址，两者并没有明确的界限。</p>
<h1 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h1><p>指的是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。</p>
<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>指的是现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/42a4c21bcef4">参考来源</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/26/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 08:11:40 / Modified: 09:35:20" itemprop="dateCreated datePublished" datetime="2020-11-26T08:11:40+08:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索以达到目标。当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术称为回溯法，而满足回溯条件的某个状态的点称为回溯点。</p>
<p>许多复杂的、规模较大的问题都可以使用回溯法，有“通用解题方法”之称。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度优先搜索解空间树。当探索到某一结点时，要先判断节点是否包含问题的解，如果包含，就从该节点出发继续探索下去，如果不包含，则逐层向其祖先节点回溯。</p>
<p>用回溯法求解问题的所有解时，要回溯到根，且根节点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若用回溯法求任意一个解时，只要搜索到问题的一个可行解就可以结束。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><blockquote>
<p>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>确定结点的扩展搜索规则</p>
<p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p>
</blockquote>
<p><strong>子集树</strong>：当所给问题是从 n 个元素的集合 S 中找出 S 满足的某种性质的子集时，相应的解空间树称为子集树。例如，0-1背包问题，要求在n个物品的集合S中，选出几个物品，使物品在背包容积C的限制下，总价值最大（即集合S的满足条件 &lt;容积C下价值最大&gt; 的某个子集）。</p>
<p>子集树是从集合S中选出符合限定条件的子集，故每个集合元素只需判断是否（0,1）入选，因此解空间应是一颗满二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123; <span class="comment">//子集树是从集合S中，选出符合限定条件的子集，故每个元素判断是（1）否（0）选入即可（二叉树），因此i定义域为&#123;0,1&#125;</span></span><br><span class="line">            x[t] = i; <span class="comment">//x[]表示是否加入点集，1表示是，0表示否</span></span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t)) <span class="comment">//constraint(t)和bound(t)分别是约束条件和限定函数 </span></span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排列树</strong>：当问题是确定n个元素满足某种性质的排列时，相应的解空间称为排列树。排列树与子集树最大的区别在于，排列树的解包括整个集合S的元素，而子集树的解则只包括符合条件的集合S的子集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            swap(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">            swap(x[i], x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非子集树，非排列数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = f(n, t); i &lt;= g(n, t); i++) &#123;</span><br><span class="line">            x[t] = h[i];</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="货箱装船问题"><a href="#货箱装船问题" class="headerlink" title="货箱装船问题"></a>货箱装船问题</h1><p>有两艘船，载重量为c1、c2，有n个货箱，重量分别为w1, w2, …, wn。</p>
<p>基本思路： 容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。<br>(1)首先将第一艘轮船尽可能装满；<br>(2)将剩余的集装箱装上第二艘轮船。</p>
<p>将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于特殊的0-1背包问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;       <span class="comment">//货箱数目</span></span><br><span class="line"><span class="keyword">int</span> w[maxn]; <span class="comment">//货箱重量数组</span></span><br><span class="line"><span class="keyword">int</span> c;       <span class="comment">//第1艘船的载重量</span></span><br><span class="line"><span class="keyword">int</span> cw;      <span class="comment">//当前装载的重量</span></span><br><span class="line"><span class="keyword">int</span> bestw;   <span class="comment">//目前最优装载的重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxLoading</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//从第i层节点搜索</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; bestw) bestw = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cw + w[i] &lt;= c) &#123; <span class="comment">//尝试x[i] = 1</span></span><br><span class="line">        cw += w[i];</span><br><span class="line">        maxLoading(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i]; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxLoading(i + <span class="number">1</span>); <span class="comment">//尝试x[i] = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/21/5%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/5%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0/" class="post-title-link" itemprop="url">5个数排序所需的最少比较次数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-21 10:28:14 / Modified: 10:50:54" itemprop="dateCreated datePublished" datetime="2020-11-21T10:28:14+08:00">2020-11-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若使用插入排序，最坏情况需要10次比较：1 + 2 + 3 + 4</p>
<p>若使用归并排序，最坏情况需要9次比较：nlogn</p>
<p>7次比较：</p>
<ol>
<li>标记待排序元素为A，B，C，D，E。</li>
<li>先将A与B、C与D比较，假设A &lt; B，C &lt; D，再将A与C比较，不妨设A &lt; C，则A &lt; C &lt; D，当前共3次比较。（若A &gt; C，那就C &lt; A &lt; B，两种情况等价）</li>
<li>再将E折半插入A &lt; C &lt; D，最多需要2次比较（E先与C比较，若与C相等则只需1次比较，若小于C就再和A比较，若大于C就再和D比较）。</li>
<li>假设结果为A &lt; C &lt; D &lt; E，再将B插入A &lt; C &lt; D &lt; E，因为已有A &lt; B，所以只需要将B插入C &lt; D &lt; E中，折半最多需要2次比较。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">preccrep</p>
  <div class="site-description" itemprop="description">serial processing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">preccrep</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
