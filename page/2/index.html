<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"preccrep.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="serial processing">
<meta property="og:type" content="website">
<meta property="og:title" content="Serial">
<meta property="og:url" content="https://preccrep.github.io/page/2/index.html">
<meta property="og:site_name" content="Serial">
<meta property="og:description" content="serial processing">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="preccrep">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://preccrep.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Serial</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Serial" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Serial</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">of or relating to the sequential performance of multiple operations</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">76</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">分治算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-23 22:19:38" itemprop="dateCreated datePublished" datetime="2020-12-23T22:19:38+08:00">2020-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 13:19:02" itemprop="dateModified" datetime="2020-12-24T13:19:02+08:00">2020-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(tr,tc)是棋盘左上角的方格坐标</span></span><br><span class="line"><span class="comment">(dr,dc)是特殊方格所在坐标</span></span><br><span class="line"><span class="comment">size是棋盘的行数和列数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1025</span></span><br><span class="line"><span class="keyword">int</span> board[N][N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tile = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr, <span class="keyword">int</span> tc, <span class="keyword">int</span> dr, <span class="keyword">int</span> dc, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">int</span> t = tile++; <span class="comment">//L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s = size/<span class="number">2</span>; <span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="comment">//覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        ChessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">//覆盖其余方格</span></span><br><span class="line">        ChessBoard(tr, tc, tr + s - <span class="number">1</span>, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        Chessboard(tr, tc + s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖左下角子棋盘 </span></span><br><span class="line">	<span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">		ChessBoard(tr + s, tc, dr, dc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右上角</span></span><br><span class="line">		board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">		<span class="comment">//覆盖其余方格 </span></span><br><span class="line">		ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//覆盖右下角子棋盘 </span></span><br><span class="line">	<span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &gt;= t c+ s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">		ChessBoard(tr + s, tc + s, dr, dc, s);</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖左上角 </span></span><br><span class="line">		board[tr + s][tc + s] = t;</span><br><span class="line">		<span class="comment">//覆盖其余方格 </span></span><br><span class="line">		ChessBoard(tr + s, tc + s, tr + s, tc + s, s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k) &#123;  <span class="comment">//k cases</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        board[x][y] = <span class="number">0</span>;</span><br><span class="line">        ChessBoard(<span class="number">0</span>, <span class="number">0</span>, x, y, size);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; board[i][j] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span>^k</span><br><span class="line">需(n-<span class="number">1</span>)/<span class="number">3</span>个L型骨牌填满</span><br><span class="line">算法的时间复杂度: t(n)=<span class="number">4</span>t(n/<span class="number">4</span>)+c</span><br><span class="line">Master <span class="function"><span class="keyword">Method</span>求解得到:</span> t(n)=Theta(n)</span><br></pre></td></tr></table></figure>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/merge-sort/">source</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program for Merge Sort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merges two subarrays of arr[].</span></span><br><span class="line"><span class="comment">// First subarray is arr[l..m]</span></span><br><span class="line"><span class="comment">// Second subarray is arr[m+1..r]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n1 = m - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n2 = r - m;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create temp arrays</span></span><br><span class="line">	<span class="keyword">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy data to temp arrays L[] and R[]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">		L[i] = arr[l + i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">		R[j] = arr[m + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Merge the temp arrays back into arr[l..r]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of first subarray</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of second subarray</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial index of merged subarray</span></span><br><span class="line">	<span class="keyword">int</span> k = l;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">			arr[k] = L[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			arr[k] = R[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the remaining elements of</span></span><br><span class="line">	<span class="comment">// L[], if there are any</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">		arr[k] = L[i];</span><br><span class="line">		i++;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the remaining elements of</span></span><br><span class="line">	<span class="comment">// R[], if there are any</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">		arr[k] = R[j];</span><br><span class="line">		j++;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l is for left index and r is</span></span><br><span class="line"><span class="comment">// right index of the sub-array</span></span><br><span class="line"><span class="comment">// of arr to be sorted */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//returns recursively</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (l+r<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	mergeSort(arr,l,m);</span><br><span class="line">	mergeSort(arr,m+<span class="number">1</span>,r);</span><br><span class="line">	merge(arr,l,m,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UTILITY FUNCTIONS</span></span><br><span class="line"><span class="comment">// Function to print an array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> arr_size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Given array is \n&quot;</span>;</span><br><span class="line">	printArray(arr, arr_size);</span><br><span class="line"></span><br><span class="line">	mergeSort(arr, <span class="number">0</span>, arr_size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSorted array is \n&quot;</span>;</span><br><span class="line">	printArray(arr, arr_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by Mayank Tyagi</span></span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    QuickSort(a, l, j - <span class="number">1</span>);</span><br><span class="line">    QuickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找第-k-小的元素"><a href="#寻找第-k-小的元素" class="headerlink" title="寻找第 k 小的元素"></a>寻找第 k 小的元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">select</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, j + <span class="number">1</span>, r, k - j + l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> select(a, l, j - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="距离最接近的点对"><a href="#距离最接近的点对" class="headerlink" title="距离最接近的点对"></a>距离最接近的点对</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35678407/article/details/82874216">source</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    point() &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(A.x - B.x, <span class="number">2</span>) + <span class="built_in">pow</span>(A.y - B.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* function: 合并，同第三区域最近点距离比较</span></span><br><span class="line"><span class="comment">* param: points 点的集合</span></span><br><span class="line"><span class="comment">*        dis 左右两边集合的最近点距离</span></span><br><span class="line"><span class="comment">*        mid x坐标排序后，点集合中中间点的索引值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points, <span class="keyword">double</span> dis, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; left, right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].x - points[mid].x &lt;= <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &gt; -dis)</span><br><span class="line">            left.push_back(points[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(points[i].x - points[mid].x &gt; <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &lt; dis)</span><br><span class="line">            right.push_back(points[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(right.begin(), right.end(), cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, index; i &lt; left.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; right.size() &amp;&amp; left[i].y &lt; right[index].y; index++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span> &amp;&amp; index + j &lt; right.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(left[i], right[j + index]) &lt; dis)</span><br><span class="line">                dis = distance(left[i], right[j + index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">2</span>) <span class="keyword">return</span> distance(points[<span class="number">0</span>], points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">3</span>) <span class="keyword">return</span> min(distance(points[<span class="number">0</span>], points[<span class="number">1</span>]), min(distance(points[<span class="number">0</span>], points[<span class="number">2</span>]), distance(points[<span class="number">1</span>], points[<span class="number">2</span>])));</span><br><span class="line">    <span class="keyword">int</span> mid = (points.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d1, d2, d;</span><br><span class="line">    vector&lt;point&gt; left(mid + 1), right(points.size() - mid - 1);</span><br><span class="line">    copy(points.begin(), points.begin() + mid + <span class="number">1</span>, left.begin()); <span class="comment">//左边区域点集合</span></span><br><span class="line">    copy(points.begin() + mid + <span class="number">1</span>, points.end(), right.begin()); <span class="comment">//右边区域点集合</span></span><br><span class="line">    d1 = closest(left);</span><br><span class="line">    d2 = closest(right);</span><br><span class="line">    d = min(d1, d2);</span><br><span class="line">    <span class="keyword">return</span> merge(points, d, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;点个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; points;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个点&quot;</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        points.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(points.begin(), points.end(), cmp_x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最近点对值：%lf&quot;</span>, closest(points));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 <code>n*n</code> 的矩阵 A 与 B 的乘积是另一个 <code>n*n</code> 的矩阵 C，则：进行了 n^3 次乘法和 n^2(n-1) 次加法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/18/Directory-Symbolic-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/18/Directory-Symbolic-Link/" class="post-title-link" itemprop="url">Directory-Symbolic-Link</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-18 21:37:42" itemprop="dateCreated datePublished" datetime="2020-12-18T21:37:42+08:00">2020-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-19 12:42:42" itemprop="dateModified" datetime="2020-12-19T12:42:42+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>In the context of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>:</p>
<p><code>MKLINK [[/D] | [/H] | [/J]] Link Target</code></p>
<pre><code>    /D      创建目录符号链接。默认为文件
            符号链接。
    /H      创建硬链接而非符号链接。
    /J      创建目录联接。
    Link    指定新的符号链接名称。
    Target  指定新链接引用的路径
            (相对或绝对)。
</code></pre><ol>
<li><p>Isn’t a <strong>directory junction</strong> the exact same thing as a <strong>directory symbolic link</strong>?</p>
<p>What’s the difference between <code>mklink /D f1 f2</code> and <code>mklink /J f1 f2</code> ?</p>
</li>
<li><p>Since a “directory” is actually just a <em>file</em>, what would be the difference between a directory symbolic link and a file symbolic link?</p>
</li>
</ol>
<p>A junction is definitely not the same thing as a directory symbolic link, although they behave similarly. The main difference is that, if you are looking at a remote server, <strong>junctions are processed at the server</strong> and <strong>directory symbolic links are processed at the client</strong>. Also see Matthew’s comment on the fact that this means symbolic links on the local file system can point to remote file systems.</p>
<p>Suppose that on a machine named Alice you were to put a junction point <code>c:\myjp</code> and a directory symbolic link <code>c:\mysymlink</code>, both pointing to <code>c:\targetfolder</code>. While you’re using Alice you won’t notice much difference between them. But if you’re using another machine named Bob, then the junction point</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\m</span>yjp` will point to `<span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\t</span>argetfolder</span><br></pre></td></tr></table></figure>
<p>but the symbolic link</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>Alice<span class="symbol">\c</span>$<span class="symbol">\m</span>ysymlink` will point to `<span class="symbol">\\</span>Bob<span class="symbol">\c</span>$<span class="symbol">\t</span>argetfolder</span><br></pre></td></tr></table></figure>
<p>(Caveat: by default, the system doesn’t follow symlinks on remote volumes, so in most cases the second example will actually result in either <em>“File Not Found”</em> or <em>“The symbolic link cannot be followed because its type is disabled.”</em>)</p>
<p>The difference between a directory symbolic link and a file symbolic link is simply that one represents a directory and one represents a file. Since the target of the link doesn’t need to exist when the link is created, the file system needs to know whether to tell applications that it is a directory or not.</p>
<p>It should also be noted that creating a symbolic link requires special privilege (by default, only available to elevated processes) whereas creating a junction only requires access to the file system.</p>
<p><a target="_blank" rel="noopener" href="https://superuser.com/questions/343074/directory-junction-vs-directory-symbolic-link/343079#343079">source</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">动态规划练习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 10:42:20" itemprop="dateCreated datePublished" datetime="2020-12-17T10:42:20+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-28 21:11:06" itemprop="dateModified" datetime="2020-12-28T21:11:06+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>此文会不定期更新</p>
</blockquote>
<h1 id="购买股票问题"><a href="#购买股票问题" class="headerlink" title="购买股票问题"></a>购买股票问题</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode714.买卖股票的最佳时机含手续费</a></p>
<blockquote>
<p>给定一个整数数组 prices，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8</p>
<ul>
<li><code>0 &lt; prices.length &lt;= 50000</code>.</li>
<li><code>0 &lt; prices[i] &lt; 50000</code>.</li>
<li><code>0 &lt;= fee &lt; 50000</code>.</li>
</ul>
<p><code>dp[i][0]</code> 表示第 <code>i</code> 天未持有股票的最大利润，<code>dp[i][1]</code> 表示第 <code>i</code>天持有股票的最大利润。</p>
<p>那么对于 <code>dp[i][0]</code> ，它的来源有两种：第一种是在第 <code>i - 1</code> 天时手中就没有股票，到了第 <code>i</code> 天仍然没有；第二种是在第 <code>i - 1</code> 天手中有股票，到了第 <code>i</code> 天就卖出了。因此得到递推关系式：</p>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)</code></p>
<p>对于 <code>dp[i][1]</code> ，它的来源也有两种：第一种是在第 <code>i - 1</code> 天手中就有股票，第 <code>i</code> 天也没有抛售出去；第二种是在第 <code>i - 1</code> 天未持有股票，在第 <code>i</code> 天购入。递推关系式为：</p>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<p>初始条件为：</p>
<p><code>dp[0][0] = 0</code> ：第 0 天什么也没买</p>
<p><code>dp[0][1] = -prices[0]</code> ：第 0 天买了，那么就只可能买 prices[0] 的股票。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> dp[<span class="number">50010</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode188.买卖股票的最佳时机</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/12/11/%E8%99%9A%E6%8B%9F-%E9%80%BB%E8%BE%91-%E7%BA%BF%E6%80%A7-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/11/%E8%99%9A%E6%8B%9F-%E9%80%BB%E8%BE%91-%E7%BA%BF%E6%80%A7-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">虚拟/逻辑/线性/物理地址到底是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-11 19:08:04 / Modified: 19:15:36" itemprop="dateCreated datePublished" datetime="2020-12-11T19:08:04+08:00">2020-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>指的是由程序产生的由<code>段选择符</code>和<code>段内偏移地址</code>两个部分组成的地址。为什么叫它是虚拟的地址呢？因为这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换机构处理或映射后才会对应到相应的物理内存地址。</p>
<h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>指由程序产生的与段相关的偏移地址部分。不过有些资料是直接把逻辑地址当成虚拟地址，两者并没有明确的界限。</p>
<h1 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h1><p>指的是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。</p>
<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>指的是现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/42a4c21bcef4">参考来源</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/26/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 08:11:40 / Modified: 09:35:20" itemprop="dateCreated datePublished" datetime="2020-11-26T08:11:40+08:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索以达到目标。当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术称为回溯法，而满足回溯条件的某个状态的点称为回溯点。</p>
<p>许多复杂的、规模较大的问题都可以使用回溯法，有“通用解题方法”之称。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度优先搜索解空间树。当探索到某一结点时，要先判断节点是否包含问题的解，如果包含，就从该节点出发继续探索下去，如果不包含，则逐层向其祖先节点回溯。</p>
<p>用回溯法求解问题的所有解时，要回溯到根，且根节点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若用回溯法求任意一个解时，只要搜索到问题的一个可行解就可以结束。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><blockquote>
<p>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>确定结点的扩展搜索规则</p>
<p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p>
</blockquote>
<p><strong>子集树</strong>：当所给问题是从 n 个元素的集合 S 中找出 S 满足的某种性质的子集时，相应的解空间树称为子集树。例如，0-1背包问题，要求在n个物品的集合S中，选出几个物品，使物品在背包容积C的限制下，总价值最大（即集合S的满足条件 &lt;容积C下价值最大&gt; 的某个子集）。</p>
<p>子集树是从集合S中选出符合限定条件的子集，故每个集合元素只需判断是否（0,1）入选，因此解空间应是一颗满二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123; <span class="comment">//子集树是从集合S中，选出符合限定条件的子集，故每个元素判断是（1）否（0）选入即可（二叉树），因此i定义域为&#123;0,1&#125;</span></span><br><span class="line">            x[t] = i; <span class="comment">//x[]表示是否加入点集，1表示是，0表示否</span></span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t)) <span class="comment">//constraint(t)和bound(t)分别是约束条件和限定函数 </span></span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排列树</strong>：当问题是确定n个元素满足某种性质的排列时，相应的解空间称为排列树。排列树与子集树最大的区别在于，排列树的解包括整个集合S的元素，而子集树的解则只包括符合条件的集合S的子集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            swap(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">            swap(x[i], x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非子集树，非排列数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = f(n, t); i &lt;= g(n, t); i++) &#123;</span><br><span class="line">            x[t] = h[i];</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="货箱装船问题"><a href="#货箱装船问题" class="headerlink" title="货箱装船问题"></a>货箱装船问题</h1><p>有两艘船，载重量为c1、c2，有n个货箱，重量分别为w1, w2, …, wn。</p>
<p>基本思路： 容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。<br>(1)首先将第一艘轮船尽可能装满；<br>(2)将剩余的集装箱装上第二艘轮船。</p>
<p>将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于特殊的0-1背包问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;       <span class="comment">//货箱数目</span></span><br><span class="line"><span class="keyword">int</span> w[maxn]; <span class="comment">//货箱重量数组</span></span><br><span class="line"><span class="keyword">int</span> c;       <span class="comment">//第1艘船的载重量</span></span><br><span class="line"><span class="keyword">int</span> cw;      <span class="comment">//当前装载的重量</span></span><br><span class="line"><span class="keyword">int</span> bestw;   <span class="comment">//目前最优装载的重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxLoading</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//从第i层节点搜索</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; bestw) bestw = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cw + w[i] &lt;= c) &#123; <span class="comment">//尝试x[i] = 1</span></span><br><span class="line">        cw += w[i];</span><br><span class="line">        maxLoading(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i]; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxLoading(i + <span class="number">1</span>); <span class="comment">//尝试x[i] = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/21/5%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/5%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0/" class="post-title-link" itemprop="url">5个数排序所需的最少比较次数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-21 10:28:14 / Modified: 10:50:54" itemprop="dateCreated datePublished" datetime="2020-11-21T10:28:14+08:00">2020-11-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若使用插入排序，最坏情况需要10次比较：1 + 2 + 3 + 4</p>
<p>若使用归并排序，最坏情况需要9次比较：nlogn</p>
<p>7次比较：</p>
<ol>
<li>标记待排序元素为A，B，C，D，E。</li>
<li>先将A与B、C与D比较，假设A &lt; B，C &lt; D，再将A与C比较，不妨设A &lt; C，则A &lt; C &lt; D，当前共3次比较。（若A &gt; C，那就C &lt; A &lt; B，两种情况等价）</li>
<li>再将E折半插入A &lt; C &lt; D，最多需要2次比较（E先与C比较，若与C相等则只需1次比较，若小于C就再和A比较，若大于C就再和D比较）。</li>
<li>假设结果为A &lt; C &lt; D &lt; E，再将B插入A &lt; C &lt; D &lt; E，因为已有A &lt; B，所以只需要将B插入C &lt; D &lt; E中，折半最多需要2次比较。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">字符串哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-20 19:54:19 / Modified: 21:39:12" itemprop="dateCreated datePublished" datetime="2020-11-20T19:54:19+08:00">2020-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是字符串哈希"><a href="#什么是字符串哈希" class="headerlink" title="什么是字符串哈希"></a>什么是字符串哈希</h1><p>字符串Hash可以通俗的理解为，<strong>把一个字符串转换为一个整数</strong>。</p>
<p>如果我们通过某种方法，将字符串转换为一个整数，就可以便的确定某个字符串是否重复出现过，这是最简单的字符串Hash应用情景了。</p>
<p>当然也不难想到，如果有不同的两个字符串同时Hash到一个整数，这样就比较麻烦了。我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。</p>
<h1 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h1><blockquote>
<p>给定字符串 s，则 asc[s[i]] = s[i] - ‘a’ + 1.</p>
</blockquote>
<h2 id="自然溢出方法"><a href="#自然溢出方法" class="headerlink" title="自然溢出方法"></a>自然溢出方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> Hash[n];</span><br><span class="line">Hash[i] = Hash[i - <span class="number">1</span>] * p + asc[s[i]]</span><br></pre></td></tr></table></figure>
<p>利用unsigned long long的范围自然溢出，相当于自动对 2^64 -1 取模。</p>
<h2 id="单哈希方法"><a href="#单哈希方法" class="headerlink" title="单哈希方法"></a>单哈希方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash[i] = (Hash[i - <span class="number">1</span>] * p + asc[s[i]]) % MOD</span><br></pre></td></tr></table></figure>
<p>其中 p 和 MOD 均为质数，且有 p &lt; MOD。</p>
<p>对于此种Hash方法，将 p 和 MOD 尽量取大即可，这种情况下，冲突的概率是很低的。</p>
<blockquote>
<p>如取 p = 13, MOD = 101, 对字符串 “abc” 进行Hash。这里注意asc[s[i]]是s[i]的ascii码加1.</p>
<p>Hash[0] = 1;</p>
<p>Hash[1] = (Hash[0] * 13 + 2) % 101 = 15;  // s[i] = ‘b’, asc[s[i]] = ‘b’ - ‘a’ + 1 = 2</p>
<p>Hash[2] = (Hash[1] * 13 + 3) % 101 = 97;</p>
<p>结果是Hash[n]，即Hash[2]。所以此时认为 97 就是字符串”abc”的值。</p>
</blockquote>
<h2 id="双哈希方法"><a href="#双哈希方法" class="headerlink" title="双哈希方法"></a>双哈希方法</h2><p>将一个字符串用不同的MOD Hash两次，将这两个结果用一个二元组表示，作为Hash结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1[i] = (Hash[i - <span class="number">1</span>] * p + asc[s[i]]) % MOD1;</span><br><span class="line">Hash2[i] = (Hash[i - <span class="number">1</span>] * p + asc[s[i]]) % MOD2;</span><br></pre></td></tr></table></figure>
<p>Hash的结果为 <code>&lt; Hash1[n], Hash2[n] &gt;</code>。</p>
<p>这种Hash很安全。</p>
<h1 id="求子串公式"><a href="#求子串公式" class="headerlink" title="求子串公式"></a>求子串公式</h1><p>假设有一个∣S∣=5 的字符串，设 Si 为第 i 个字符，其中 1 ≤ i ≤ 5。</p>
<p>根据定义分别求出hash[i]：</p>
<p>hash[1] = s1;</p>
<p>hash[2] = s1 ∗ p + s2;</p>
<p>hash[3] = s1 ∗ p^2 + s2 ∗ p + s3;</p>
<p>hash[4] = s1 ∗ p^3 + s2 ∗ p^2 + s3 ∗ p + s4;</p>
<p>hash[5] = s1 ∗ p^4 + s2 ∗ p^3 + s3 ∗ p^2 + s4 ∗ p + s5;</p>
<p>现在要求子串 s3s4 的hash值，不难得出为s3 ∗ p + s4。<br><code>Hash[4] - Hash[2] * pow(p, 4 - 3 + 1)</code></p>
<p>所以公式如下：</p>
<p><code>Hash[l~r] = Hash[r] - Hash[l - 1] * pow(p, r - l + 1)</code></p>
<p>考虑到取模：</p>
<p><code>Hash[l~r] = ((Hash[r] - Hash[l - 1] * pow(p, r - l + 1)) % MOD + MOD) % MOD</code></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2774">POJ2774</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 131</span></span><br><span class="line"><span class="comment">// #define INF 0x3f3f3f3f</span></span><br><span class="line"><span class="comment">// #define MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash1和Hash2存储两个字符串的哈希值，</span></span><br><span class="line"><span class="comment">// po记录p的乘方(相当于转化为p进制)，tmp用于比较(后面会讲解)</span></span><br><span class="line">ull Hash1[maxn], Hash2[maxn], po[maxn], tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> len1, len2;  <span class="comment">// 两字符串的长度</span></span><br><span class="line"><span class="keyword">char</span> s1[maxn], s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求h的子串s[l~r](包括s[l]和s[r])的Hash值</span></span><br><span class="line"><span class="function">ull <span class="title">getHash</span><span class="params">(ull* h, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * po[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">check函数用来判断是否有长度为len的相同子串</span></span><br><span class="line"><span class="comment">先将Hash1的长度为len的子串的Hash值依次求出，存入tmp数组中</span></span><br><span class="line"><span class="comment">将tmp由小到大排序(这里排序只是为了便于Hash2的二分查找)</span></span><br><span class="line"><span class="comment">因为二分查找要求数组有序！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= len1; i++)</span><br><span class="line">		tmp[cnt ++] = getHash(Hash1, i, i + len - <span class="number">1</span>);</span><br><span class="line">	sort(tmp, tmp + cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= len2; i++) &#123;</span><br><span class="line">		ull x = getHash(Hash2, i, i + len - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(binary_search(tmp, tmp + cnt, x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 这里用到了&lt;algorithm&gt;中的binary_search函数，这是一个bool类型函数，</span></span><br><span class="line">		<span class="comment">// 是在[tmp, tmp + cnt)，即[tmp, tmp + cnt - 1]范围内</span></span><br><span class="line">		<span class="comment">// 二分查找x，如果找到了就返回true，否则返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_po</span><span class="params">()</span> </span>&#123;  <span class="comment">// 将p的乘方都算出来，打表</span></span><br><span class="line">	po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">		po[i] = po[i - <span class="number">1</span>] * p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	init_po();</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>)) &#123;  <span class="comment">// s1和s2都从索引1开始存储</span></span><br><span class="line">		len1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">		len2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算s1和s2的Hash值</span></span><br><span class="line">		Hash1[<span class="number">0</span>] = Hash2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">			Hash1[i] = Hash1[i - <span class="number">1</span>] * p + (s1[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; i++)</span><br><span class="line">			Hash2[i] = Hash2[i - <span class="number">1</span>] * p + (s2[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 二分查找最大长度</span></span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = min(len1, len2);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  <span class="comment">// 移位更快</span></span><br><span class="line">			<span class="keyword">if</span>(check(m)) &#123;  <span class="comment">// 如果m满足长度为m的子串相等</span></span><br><span class="line">				l = m + <span class="number">1</span>;  <span class="comment">// 就增大左边界l，看看有没有更大的长度</span></span><br><span class="line">				ans = m;    <span class="comment">// ans更新为当前的最大值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r = m - <span class="number">1</span>;  <span class="comment">// 没有找到，那就先减小右边界看看有没有符合的m</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/15/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/" class="post-title-link" itemprop="url">最大公共子序列和最大公共子串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-15 11:21:26 / Modified: 11:24:54" itemprop="dateCreated datePublished" datetime="2020-11-15T11:21:26+08:00">2020-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大公共子序列"><a href="#最大公共子序列" class="headerlink" title="最大公共子序列"></a>最大公共子序列</h1><h1 id="最大公共子串"><a href="#最大公共子串" class="headerlink" title="最大公共子串"></a>最大公共子串</h1><h2 id="动态规划（未优化）"><a href="#动态规划（未优化）" class="headerlink" title="动态规划（未优化）"></a>动态规划（未优化）</h2><h2 id="动态规划（一级空间优化）"><a href="#动态规划（一级空间优化）" class="headerlink" title="动态规划（一级空间优化）"></a>动态规划（一级空间优化）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000001</span>], s2[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1), len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">	<span class="keyword">int</span> i, j, cur = <span class="number">1</span>, pre = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(len2 &gt; len1) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len2; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					dp[cur][j] = dp[pre][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">					cnt = max(cnt, dp[cur][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[cur][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(cur, pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len1; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len2; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= len1; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(s2[i - <span class="number">1</span>] == s1[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					dp[cur][j] = dp[pre][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">					cnt = max(cnt, dp[cur][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[cur][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(cur, pre);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s1, s2)) &#123;</span><br><span class="line">		<span class="keyword">int</span> ans = lcs();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划（二级空间优化）"><a href="#动态规划（二级空间优化）" class="headerlink" title="动态规划（二级空间优化）"></a>动态规划（二级空间优化）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000001</span>], s2[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1), len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">	<span class="keyword">int</span> i, j, tmp, old, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(len2 &gt; len1) &#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len2; i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">			old = dp[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">				tmp = dp[j];</span><br><span class="line">				<span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					dp[j] = old + <span class="number">1</span>;</span><br><span class="line">					cnt = max(cnt, dp[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[j] = <span class="number">0</span>;</span><br><span class="line">				old = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len1; i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len2; i++) &#123;</span><br><span class="line">			old = dp[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= len1; j++) &#123;</span><br><span class="line">				tmp = dp[j];</span><br><span class="line">				<span class="keyword">if</span>(s2[i - <span class="number">1</span>] == s1[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					dp[j] = old + <span class="number">1</span>;</span><br><span class="line">					cnt = max(cnt, dp[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[j] = <span class="number">0</span>;</span><br><span class="line">				old = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s1, s2)) &#123;</span><br><span class="line">		<span class="keyword">int</span> ans = lcs();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/11/14/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">后缀数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-14 23:01:06" itemprop="dateCreated datePublished" datetime="2020-11-14T23:01:06+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 09:12:08" itemprop="dateModified" datetime="2020-11-19T09:12:08+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>对于待排序的数组a，在排序时逐个遍历数组a，将数组a的值作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> bucket[maxn]; <span class="comment">// maxn是a[]的最大值</span></span><br><span class="line">    <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(bucket));</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        bucket[a[i]]++;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>((bucket[i]--) &gt; <span class="number">0</span>)</span><br><span class="line">            a[j++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>桶排序的扩展。它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">10</span> * base(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket[maxn];</span><br><span class="line">    <span class="keyword">int</span> tmp[n];</span><br><span class="line">    <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="keyword">sizeof</span>(bucket));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        bucket[(a[i] / base(bit)) % <span class="number">10</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">        bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp[bucket[(a[i] / base(bit)) % <span class="number">10</span>] - <span class="number">1</span>] = a[i];</span><br><span class="line">        bucket[(a[i] / base(bit)) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit = getbit();  <span class="comment">//获取数组a的位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; i++)</span><br><span class="line">        bucket_sort(i);</span><br><span class="line">    print();  <span class="comment">//已排好序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Str</span>: 需要处理的字符串(长度为<span class="symbol">Len</span>)</span><br><span class="line"><span class="symbol">Suffix</span>[i]: <span class="symbol">Str</span>下标为i~<span class="symbol">Len</span>的连续子串(例如<span class="symbol">Str</span>=<span class="string">&quot;abcdef&quot;</span>, <span class="symbol">Suffix</span>[<span class="number">3</span>]=<span class="string">&quot;def&quot;</span>)</span><br><span class="line"><span class="symbol">Rank</span>[i]: <span class="symbol">Suffix</span>[i]在所有后缀中的排名</span><br><span class="line"><span class="symbol">SA</span>[i]: 排名为i的后缀的起始下标，即排名为i的后缀为<span class="symbol">Suffix</span>[<span class="symbol">SA</span>[i]]，与<span class="symbol">Rank</span>是互逆运算</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>后缀数组</strong>指的就是这个<strong>SA[i]</strong>,有了它，我们就可以实现一些很强大的功能(如不相同子串个数、连续重复子串等)。如何快速的到它，便成为了这个算法的<strong>关键</strong>。而<strong>SA</strong>和<strong>Rank</strong>是互逆的，只要求出任意一个，另一个就可以O(Len)得到。<br>现在比较主流的算法有两种，<strong>倍增</strong>和<strong>DC3</strong>，在这里，就主要讲一下稍微慢一些，但比较好实现以及理解的倍增算法(虽说慢，但也是<strong>O(Len logLen)</strong>)的。</p>
</blockquote>
<h2 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h2><h2 id="Height数组"><a href="#Height数组" class="headerlink" title="Height数组"></a>Height数组</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Height<span class="comment">[i]</span>: 表示Suffix<span class="comment">[SA<span class="comment">[i]</span>]</span>和Suffix<span class="comment">[SA<span class="comment">[i-1]</span>]</span>的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀</span><br><span class="line">H<span class="comment">[i]</span>: 等于Height<span class="comment">[Rank<span class="comment">[i]</span>]</span>，即Height<span class="comment">[i]</span>=H<span class="comment">[SA<span class="comment">[i]</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>H[i] &gt;= H[i-1] - 1</code></p>
<blockquote>
<p>证明：设<strong>Suffix[k]</strong>是排在<strong>Suffix[i - 1]</strong>前一名的后缀，则它们的最长公共前缀是<strong>H[i - 1]</strong>。都<strong>去掉第一个字符</strong>，就变成<strong>Suffix[k + 1]</strong>和<strong>Suffix[i]</strong>。<strong>如果H[i - 1] = 0或1</strong>,那么<strong>H[i] ≥ 0</strong>显然成立。<strong>否则</strong>，<strong>H[i] ≥ H[i - 1] - 1(去掉了原来的第一个,其他前缀一样相等)</strong>，所以<strong>Suffix[i]</strong>和在它前一名的后缀的最长公共前缀<strong>至少是H[i - 1] - 1。</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2020/10/24/Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/24/Analysis/" class="post-title-link" itemprop="url">Analysis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-24 00:15:23 / Modified: 01:03:20" itemprop="dateCreated datePublished" datetime="2020-10-24T00:15:23+08:00">2020-10-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>It’s a specific analysis of the nemu code. To make typing easier I use English.</p>
<p>First, I really need to know how make_helper and make_helper_v work.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &#x27;nemu/include/cpu/helper.h&#x27;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HELPER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HELPER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;nemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cpu/decode/operand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All function defined with &#x27;make_helper&#x27; return the length of the operation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_helper(name) int name(swaddr_t eip)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">swadrr_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> swaddr_read(addr, len);  <span class="comment">// instr_fetch equals swaddr_read, read memory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idex</span><span class="params">(<span class="keyword">swaddr_t</span> eip, <span class="keyword">int</span> (*decode)(<span class="keyword">swaddr_t</span>), <span class="keyword">void</span> (*execute)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* eip is pointing to the opcode */</span></span><br><span class="line">    len = decode(eip + <span class="number">1</span>);</span><br><span class="line">    execute();</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>; <span class="comment">// &quot;1&quot; for opcode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in &#x27;nemu/include/cpu/exec/helper.h&#x27; there is a reference of idex:</span></span><br><span class="line"><span class="comment">   idex(eip, concat4(decode_, type, _, SUFFIX), do_execute);</span></span><br><span class="line"><span class="comment">do_execute is a self-defined function, defined in every instruction&#x27;s .h template files.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">see what&#x27;s concat4:</span></span><br><span class="line"><span class="comment">in &#x27;nemu/include/macro.h&#x27;:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define str_temp(x) #x</span></span><br><span class="line"><span class="comment">#define str(x) str_temp(x)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define concat_temp(x, y) x ## y</span></span><br><span class="line"><span class="comment">#define concat(x, y) concat_temp(x, y)</span></span><br><span class="line"><span class="comment">#define concat3(x, y, z) concat(concat(x, y), z)</span></span><br><span class="line"><span class="comment">#define concat4(x, y, z, w) concat3(concat(x, y), z, w)</span></span><br><span class="line"><span class="comment">#define concat5(x, y, z, v, w) concat4(concat(x, y), z, v, w)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">It remains to be a problem.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_instr_len</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Operands ops_decoded;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> op_src (&amp;ops_decoded.src)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> op_src2 (&amp;ops_decoded.src2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> op_dest (&amp;ops_decoded.dest)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">So what&#x27;s Operands?</span></span><br><span class="line"><span class="comment">in &#x27;nemu/include/cpu/decode/operand.h&#x27;:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">	uint32_t opcode;</span></span><br><span class="line"><span class="comment">	bool is_data_size_16;</span></span><br><span class="line"><span class="comment">	Operand src, dest, src2;</span></span><br><span class="line"><span class="comment">&#125; Operands;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">About the use of is_data_size_16:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">I guess it probably be like this: ops_decoded.is_data_size_16 ? concat(name, _w) : concat(name, _l).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">And src and dest and src2... it seems reasonable now.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Here is Operand:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> type;</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">uint32_t</span> reg;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">swaddr_t</span> addr;</span><br><span class="line">			<span class="keyword">uint8_t</span> sreg;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">uint32_t</span> imm;</span><br><span class="line">		<span class="keyword">int32_t</span> simm;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">uint32_t</span> val;</span><br><span class="line">	<span class="keyword">char</span> str[OP_STR_SIZE];</span><br><span class="line">&#125; Operand;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">preccrep</p>
  <div class="site-description" itemprop="description">serial processing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">preccrep</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
