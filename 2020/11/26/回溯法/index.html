<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>回溯法 | Serial | of or relating to the sequential performance of multiple operations</title>

  
  <meta name="author" content="preccrep">
  

  
  <meta name="description" content="serial processing">
  

  
  
  <meta name="keywords" content="算法分析">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="回溯法"/>

  <meta property="og:site_name" content="Serial"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Serial" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Serial</a>
    </h1>
    <p class="site-description">of or relating to the sequential performance of multiple operations</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>回溯法</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/11/26/回溯法/" rel="bookmark">
        <time class="entry-date published" datetime="2020-11-26T00:11:40.000Z">
          2020-11-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索以达到目标。当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术称为回溯法，而满足回溯条件的某个状态的点称为回溯点。</p>
<p>许多复杂的、规模较大的问题都可以使用回溯法，有“通用解题方法”之称。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度优先搜索解空间树。当探索到某一结点时，要先判断节点是否包含问题的解，如果包含，就从该节点出发继续探索下去，如果不包含，则逐层向其祖先节点回溯。</p>
<p>用回溯法求解问题的所有解时，要回溯到根，且根节点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若用回溯法求任意一个解时，只要搜索到问题的一个可行解就可以结束。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><blockquote>
<p>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>确定结点的扩展搜索规则</p>
<p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p>
</blockquote>
<p><strong>子集树</strong>：当所给问题是从 n 个元素的集合 S 中找出 S 满足的某种性质的子集时，相应的解空间树称为子集树。例如，0-1背包问题，要求在n个物品的集合S中，选出几个物品，使物品在背包容积C的限制下，总价值最大（即集合S的满足条件 &lt;容积C下价值最大&gt; 的某个子集）。</p>
<p>子集树是从集合S中选出符合限定条件的子集，故每个集合元素只需判断是否（0,1）入选，因此解空间应是一颗满二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123; <span class="comment">//子集树是从集合S中，选出符合限定条件的子集，故每个元素判断是（1）否（0）选入即可（二叉树），因此i定义域为&#123;0,1&#125;</span></span><br><span class="line">            x[t] = i; <span class="comment">//x[]表示是否加入点集，1表示是，0表示否</span></span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t)) <span class="comment">//constraint(t)和bound(t)分别是约束条件和限定函数 </span></span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>排列树</strong>：当问题是确定n个元素满足某种性质的排列时，相应的解空间称为排列树。排列树与子集树最大的区别在于，排列树的解包括整个集合S的元素，而子集树的解则只包括符合条件的集合S的子集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//t是当前层数</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">            swap(x[t], x[i]);</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">            swap(x[i], x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非子集树，非排列数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n) output(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = f(n, t); i &lt;= g(n, t); i++) &#123;</span><br><span class="line">            x[t] = h[i];</span><br><span class="line">            <span class="keyword">if</span>(constraint(t) &amp;&amp; bound(t))</span><br><span class="line">                backtrack(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="货箱装船问题"><a href="#货箱装船问题" class="headerlink" title="货箱装船问题"></a>货箱装船问题</h1><p>有两艘船，载重量为c1、c2，有n个货箱，重量分别为w1, w2, …, wn。</p>
<p>基本思路： 容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。<br>(1)首先将第一艘轮船尽可能装满；<br>(2)将剩余的集装箱装上第二艘轮船。</p>
<p>将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于特殊的0-1背包问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;       <span class="comment">//货箱数目</span></span><br><span class="line"><span class="keyword">int</span> w[maxn]; <span class="comment">//货箱重量数组</span></span><br><span class="line"><span class="keyword">int</span> c;       <span class="comment">//第1艘船的载重量</span></span><br><span class="line"><span class="keyword">int</span> cw;      <span class="comment">//当前装载的重量</span></span><br><span class="line"><span class="keyword">int</span> bestw;   <span class="comment">//目前最优装载的重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxLoading</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//从第i层节点搜索</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; bestw) bestw = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cw + w[i] &lt;= c) &#123; <span class="comment">//尝试x[i] = 1</span></span><br><span class="line">        cw += w[i];</span><br><span class="line">        maxLoading(i + <span class="number">1</span>);</span><br><span class="line">        cw -= w[i]; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxLoading(i + <span class="number">1</span>); <span class="comment">//尝试x[i] = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















































































































































































































































      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法/">算法</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法分析/">算法分析</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 preccrep
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>