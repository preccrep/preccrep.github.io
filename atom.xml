<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serial</title>
  
  <subtitle>of or relating to the sequential performance of multiple operations</subtitle>
  <link href="https://preccrep.github.io/atom.xml" rel="self"/>
  
  <link href="https://preccrep.github.io/"/>
  <updated>2021-06-13T14:42:08.968Z</updated>
  <id>https://preccrep.github.io/</id>
  
  <author>
    <name>preccrep</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIPS汇编语言编程</title>
    <link href="https://preccrep.github.io/2021/06/13/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    <id>https://preccrep.github.io/2021/06/13/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</id>
    <published>2021-06-13T13:35:27.000Z</published>
    <updated>2021-06-13T14:42:08.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIPS下各个寄存器编号及描述"><a href="#MIPS下各个寄存器编号及描述" class="headerlink" title="MIPS下各个寄存器编号及描述"></a>MIPS下各个寄存器编号及描述</h1><div class="table-container"><table><thead><tr><th>寄存器编号</th><th>寄存器名</th><th>寄存器用途</th></tr></thead><tbody><tr><td>0</td><td>zero</td><td>永远返回0</td></tr><tr><td>1</td><td>$at</td><td>汇编保留寄存器（不可用作其他用途）</td></tr><tr><td>2-3</td><td>$v0-$v1</td><td>(value的简写)存储表达式或者函数的返回值</td></tr><tr><td>4-7</td><td>$a0-$a3</td><td>(Argument简写)存储子程序的前4个参数，在子程序调用过程中释放</td></tr><tr><td>8-15</td><td>$t0-$t7</td><td>(temp简写)临时变量，同上调用时不保存</td></tr><tr><td>16-23</td><td>$s0-$s7</td><td>(Save or Static简写？)静态变量？调用时保存</td></tr><tr><td>24-25</td><td>$t8-$t9</td><td>(Temp简写)算是前面$0-$7的继续，属性同$t0-$t7</td></tr><tr><td>26-27</td><td>$k0-$k1</td><td>(break off简写?)中断函数返回值，不可做其他用途</td></tr><tr><td>28</td><td>gp\</td><td>(GlobalPointer简写)指向64k(gp\</td><td>(GlobalPointer简写)指向64k(2^{16}$)大小的静态数据块的中间地址</td><td></td></tr><tr><td>29</td><td>$sp</td><td>(Stack Pointer简写)栈指针，指向栈顶</td></tr><tr><td>30</td><td>$s8/$fp</td><td>(Save / Frame Pointer)帧指针</td></tr><tr><td>31</td><td>$ra</td><td>返回地址，目测不可用作其他用途</td></tr></tbody></table></div><h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><p>数据声明 + 普通文本 + 程序编码（文件后缀是 .s 或 .asm）</p><p>数据声明在代码段之后（在之前也没什么问题）</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><ul><li>数据段以 <code>.data</code> 为开始标志</li><li>声明变量后，即在主存中分配空间</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li>代码段以 <code>.text</code> 为开始标志</li><li>各项指令操作</li><li>程序入口标志：<code>main:</code></li><li>程序结束标志</li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>同C系语言。</p><p>基本模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Comment giving name of program and description of function</span><br><span class="line"># ...</span><br><span class="line"># Template.s</span><br><span class="line">.data # variable declarations follow this line</span><br><span class="line"># 数据变量声明</span><br><span class="line"># ...</span><br><span class="line">.text # instructions follow this line</span><br><span class="line"># 代码段</span><br><span class="line">main:# indicates start of code (first instruction to execute)</span><br><span class="line"># 主程序</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># End of program, leave a blank line</span><br></pre></td></tr></table></figure><h1 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h1><p>声明的格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">变量名: 数据类型 变量值</span></span><br></pre></td></tr></table></figure><p>冒号不可缺少。</p><p>通常给变量赋一个初始值，对于 <code>.space</code>，要指明需要多少大小的空间(bytes)。</p><h1 id="加载-保存-指令集"><a href="#加载-保存-指令集" class="headerlink" title="加载/保存 指令集"></a>加载/保存 指令集</h1><ul><li>如果要访问内存，只能使用 <code>load/store</code> 指令</li><li>其他的只能是寄存器操作</li></ul><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><h3 id="lw"><a href="#lw" class="headerlink" title="lw"></a>lw</h3><p><code>lw register_dest, RAM_src</code></p><p>从内存中复制RAM_src的内容到对应的寄存器中(w即word，一个字长，4个字节，因此该数据大小为4个字节)</p><h3 id="lb"><a href="#lb" class="headerlink" title="lb"></a>lb</h3><p><code>lb register_dest, RAM_src</code></p><p>同上，lb为load byte.</p><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><h3 id="sw"><a href="#sw" class="headerlink" title="sw"></a>sw</h3><p><code>sw register_src, RAM_dest</code></p><p>指将指定寄存器中的数据写入到特定的内存中。</p><h2 id="sb"><a href="#sb" class="headerlink" title="sb"></a>sb</h2><p><code>sb register_src, RAM_dest</code></p><p>同上，但数据大小为1字节。</p><h2 id="load-imm"><a href="#load-imm" class="headerlink" title="load imm"></a>load imm</h2><h3 id="li"><a href="#li" class="headerlink" title="li"></a>li</h3><p><code>li register_dest, value</code></p><p>加载立即数。</p><h1 id="立即与间接寻址"><a href="#立即与间接寻址" class="headerlink" title="立即与间接寻址"></a>立即与间接寻址</h1><h2 id="la"><a href="#la" class="headerlink" title="la"></a>la</h2><p>Load address 直接给地址</p><p>例如，<code>la $t0, var1</code> 将 var1 (表示的是内存地址)放到 $t0 中。</p><p>如果变量var1不是内存地址，就成 <code>li</code> 指令了。</p><h2 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h2><p><code>lw</code>: 寄存器中存储的是内存地址，需要访问该内存地址得到数据再放到目的寄存器中。</p><p><code>lw $t2,($t0)</code> load word at RAM address contained in $t0 into $t2<br><code>sw $t2,($t0)</code> store word in register $t2 into RAM at address contained in $t0</p><h2 id="加偏移量"><a href="#加偏移量" class="headerlink" title="加偏移量"></a>加偏移量</h2><p><code>lw $t2,4($t0)</code> load word at RAM address ($t0+4) into register $t2, ”4” gives offset from address in register $t0<br><code>sw $t2,-12($t0)</code> store word in register $t2 into RAM at address ($t0 - 12),negative offsets are fine</p><h2 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h2><ul><li>最多3个操作数</li><li>操作数只能是寄存器，不允许出现地址</li><li>所有指令统一是32位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add $t0,$t1,$t2 # $t0 &#x3D; $t1 + $t2; add as signed (2&#39;s complement) integers</span><br><span class="line">sub $t2,$t3,$t4#  $t2 &#x3D; $t3 - $t4</span><br><span class="line">addi    $t2,$t3, 5  #  $t2 &#x3D; $t3 + 5;   &quot;add immediate&quot; (no sub immediate)</span><br><span class="line">addu    $t1,$t6,$t7#  $t1 &#x3D; $t6 + $t7;   add as unsigned integers</span><br><span class="line">subu    $t1,$t6,$t7#  $t1 &#x3D; $t6 - $t7;   subtract as unsigned integers</span><br><span class="line">mult    $t3,$t4        #  multiply 32-bit quantities in $t3 and $t4, and store 64-bit</span><br><span class="line">                    #  result in special registers Lo and Hi:  (Hi,Lo) &#x3D; $t3 * $t4</span><br><span class="line">　　　　　　　　　　　　#　　　　　　　　　　　　　运算结果存储在hi,lo（hi高位数据， lo低位数据）</span><br><span class="line">div $t5,$t6        #  Lo &#x3D; $t5 &#x2F; $t6   (integer quotient)</span><br><span class="line">                    #  Hi &#x3D; $t5 mod $t6   (remainder)</span><br><span class="line">　　　　　　　　　　　　#　　　　　　　　　　　　　商数存放在 lo, 余数存放在 hi</span><br><span class="line">mfhi    $t0#  move quantity in special register Hi to $t0:   $t0 &#x3D; Hi</span><br><span class="line">　　　　　　　　#　　　　　　　　　　　　　　　　  不能直接获取 hi 或 lo中的值， 需要mfhi, mflo指令传值给寄存器</span><br><span class="line">mflo    $t1#  move quantity in special register Lo to $t1:   $t1 &#x3D; Lo</span><br><span class="line">                    #  used to get at result of product or quotient</span><br><span class="line"></span><br><span class="line">move    $t2,$t3    #  $t2 &#x3D; $t3</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="分支（if-else系列）"><a href="#分支（if-else系列）" class="headerlink" title="分支（if else系列）"></a>分支（if else系列）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b   target      #  unconditional branch to program label target</span><br><span class="line">beq $t0,$t1,target #  branch to target if  $t0 &#x3D; $t1</span><br><span class="line">blt $t0,$t1,target #  branch to target if  $t0 &lt; $t1</span><br><span class="line">ble $t0,$t1,target #  branch to target if  $t0 &lt;&#x3D; $t1</span><br><span class="line">bgt $t0,$t1,target #  branch to target if  $t0 &gt; $t1</span><br><span class="line">bge $t0,$t1,target #  branch to target if  $t0 &gt;&#x3D; $t1</span><br><span class="line">bne $t0,$t1,target #  branch to target if  $t0 &lt;&gt; $t1</span><br></pre></td></tr></table></figure><h2 id="跳转（while-for-goto系列）"><a href="#跳转（while-for-goto系列）" class="headerlink" title="跳转（while, for, goto系列）"></a>跳转（while, for, goto系列）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j   target  　　　　#  unconditional jump to program label target</span><br><span class="line">                   # 看到就跳， 不用考虑任何条件</span><br><span class="line">jr  $t3#  jump to address contained in $t3 (&quot;jump register&quot;)</span><br><span class="line">　　　　　　#  类似相对寻址，跳到该寄存器给出的地址处</span><br></pre></td></tr></table></figure><h2 id="子程序调用"><a href="#子程序调用" class="headerlink" title="子程序调用"></a>子程序调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jal sun_label   # &quot;jump and link&quot;</span><br></pre></td></tr></table></figure><p>将当前程序计数器保存在 <code>$ra</code> 中，通过上面保存在 <code>$ra</code> 中的计数器返回到调用前。</p><p><strong>如果调用的子程序中有调用了其他的子程序，如此往复，则返回地址的标记就用栈来存储。</strong></p><h2 id="系统调用与输入-输出（主要针对SPIM模拟器）"><a href="#系统调用与输入-输出（主要针对SPIM模拟器）" class="headerlink" title="系统调用与输入/输出（主要针对SPIM模拟器）"></a>系统调用与输入/输出（主要针对SPIM模拟器）</h2><ul><li>使用syscall，以下指令应该是通用的。</li><li>参数使用的寄存器：<code>$v0, $a0, $a1</code>.</li><li>返回值使用：<code>$v0</code>.</li></ul><div class="table-container"><table><thead><tr><th>Service</th><th>Code in $v0 对应功能的调用码</th><th>Arguemnts 所需参数</th><th>Results 返回值</th></tr></thead><tbody><tr><td>打印一个整型</td><td>$v0=1</td><td>将要打印的整型赋值给$a0</td><td></td></tr><tr><td>打印一个浮点数</td><td>$v0=2</td><td>将要打印的浮点数赋值给$f12</td><td></td></tr><tr><td>打印双精度浮点数</td><td>$v0=3</td><td>将要打印的双精度浮点数赋值给$f12</td><td></td></tr><tr><td>打印字符串</td><td>$v0=4</td><td>将要打印的字符串的地址赋值给$a0</td><td></td></tr><tr><td>读取一个整型</td><td>$v0=5</td><td></td><td>将读取的整型赋值给$v0</td></tr><tr><td>读取浮点数</td><td>$v0=6</td><td></td><td>将读取的浮点数赋值给$v0</td></tr><tr><td>读取双精度浮点数</td><td>$v0=7</td><td></td><td>将读取的双精度浮点数赋值给$v0</td></tr><tr><td>读取字符串</td><td>$v0=8</td><td>将读取字符串地址赋值给$a0，将读取字符串的长度赋值给$a1</td><td></td></tr><tr><td>sbrk(应该同C中的sbrk()函数一样) 动态分配内存</td><td>$v0=9</td><td>$a0=amount 需要分配的空间大小，单位目测是字节</td><td>将分配好的空间首地址给$a0</td></tr><tr><td>退出</td><td>\v0=10</td><td>退出</td></tr></tbody></table></div><ul><li>打印的字符串应该有一个终止符(‘\0’)，声明字符串为 <code>.asciiz</code> 类型即可。</li><li>对于读取整型，浮点数，双精度浮点数等数据操作，系统会读取一整行（以’\n’为结束）</li><li>读取字符串时，输入过长就截短，短了不补，最后会加上终止符</li><li>The sbrk service returns the address to a block of memory containing n additional bytes. This would be used for dynamic memory allocation.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MIPS下各个寄存器编号及描述&quot;&gt;&lt;a href=&quot;#MIPS下各个寄存器编号及描述&quot; class=&quot;headerlink&quot; title=&quot;MIPS下各个寄存器编号及描述&quot;&gt;&lt;/a&gt;MIPS下各个寄存器编号及描述&lt;/h1&gt;&lt;div class=&quot;table-con</summary>
      
    
    
    
    
    <category term="MIPS" scheme="https://preccrep.github.io/tags/MIPS/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://preccrep.github.io/2021/06/13/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://preccrep.github.io/2021/06/13/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-06-13T09:32:30.000Z</published>
    <updated>2021-06-13T09:32:30.697Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>约束与触发器</title>
    <link href="https://preccrep.github.io/2021/05/10/%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://preccrep.github.io/2021/05/10/%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2021-05-10T11:33:19.000Z</published>
    <updated>2021-05-10T23:50:19.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h1><p>删除/更新具有引用关系的表时，有以下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 被引用的行禁止删除</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联，被引用行删除时，引用行也一起删除；即子表里的行跟着父表里相应的行一起删除</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行删除时，引用行不做什么处理</span></span><br><span class="line"><span class="keyword">no</span> action</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行禁止更新</span></span><br><span class="line"><span class="keyword">on</span> update restrict</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 被引用行更新时，引用行自动更新</span></span><br><span class="line"><span class="keyword">on</span> update cascade</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id) <span class="keyword">on</span> <span class="keyword">delete</span> restrict,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id) <span class="keyword">on</span> <span class="keyword">delete</span> cascade,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>外键约束的几种方法：</p><p>方法1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_headers(</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    customer_id <span class="type">int</span>,</span><br><span class="line">    ship_to <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在创建表时，作为外键的列后面直接依赖父表列</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span> <span class="keyword">references</span> so_headers(id),</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时，在末尾指定外键约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span>,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id),</span><br><span class="line">    <span class="keyword">foreign</span> key(so_id) <span class="keyword">references</span> so_headers(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 【注】：如果没有指定外键别名，则默认的外键别名为：&quot;表名_列名_fkey&quot;</span></span><br></pre></td></tr></table></figure><p>方法3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时，在末尾指定外键约束，并且指定外键别名；so_id_fkey</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> so_items(</span><br><span class="line">    item_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    so_id <span class="type">int</span>,</span><br><span class="line">    product_id <span class="type">int</span>,</span><br><span class="line">    net_price <span class="type">numeric</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(item_id,so_id),</span><br><span class="line">    <span class="keyword">constraint</span> so_id_fkey <span class="keyword">foreign</span> key(so_id) <span class="keyword">references</span> so_headers(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个主键建立外键约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> child_table(</span><br><span class="line">    c1 <span class="type">int</span> primady key,</span><br><span class="line">    c2 <span class="type">int</span>,</span><br><span class="line">    c3 <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(c2,c3) <span class="keyword">references</span> 父表(p1,p2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>方法4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键别名 <span class="keyword">foreign</span> key(列名) <span class="keyword">references</span> 父表(列名);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> 外键别名;</span><br></pre></td></tr></table></figure><h2 id="DEFERRABLE"><a href="#DEFERRABLE" class="headerlink" title="DEFERRABLE"></a>DEFERRABLE</h2><p>推迟约束</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器(trigger)是用户定义在关系表上的由事件驱动调用函数的机制。</p><p>触发器比CHECK更灵活，可以实施各种复杂的检查和操作，具有更精细和更强大的数据保护能力。</p><p>在创建触发器之前，必须首先创建触发器函数，触发器函数的语法格式是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> 变量声明;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数执行代码</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><p>触发器中有两对<script type="math/tex">，第一对</script>前是函数头部。触发器函数定义的头部RETURNS后面只能是TRIGGER，并且触发器函数不能带任何参数。</p><p>两对$$之间是函数体。包括DECLARE部分的变量声明以及BEGIN和END之间的函数执行代码。DECLARE部分是可选的。</p><p>由于PG允许使用各种语言比如PL/pgSQL，C，Python来编写函数，所以第二对$$之后是对函数编写语言的说明。这里是PL/pgSQL。</p><p>触发器函数创建后，使用<code>CREATE TRIGGER</code>命令创建触发器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER name &#123;BEFORE|AFTER&#125; &#123;event [OR...]&#125;</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> YYY</span><br><span class="line">[FOR [EACH] &#123;ROW|STATEMENT&#125;]</span><br><span class="line">[WHEN &#123;condition&#125;]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name();</span><br></pre></td></tr></table></figure><p>{event [OR…]}中，{}里面是一个或多个用OR分隔的事件列表。这里的事件包括数据库的数据修改操作，比如INSERT、DELETE或UPDATE等命令。</p><p>BEFORE|AFTER的意思是触发器可以分为BEFORE和AFTER触发器，分别在操作完成前和操作完成后执行触发器函数。</p><p>ON TABLE后面给出触发器所在表的表名。</p><p>触发器可以按行或按语句触发，也就是行级触发器和语句级触发器。</p><p>行级：<code>[FOR [EACH] &#123;ROW|STATEMENT&#125;]</code></p><p>语句级：<code>[FOR [EACH] &#123;STATEMENT&#125;]</code></p><p>行级触发器的触发器函数为触发语句影响的每一行执行一次。</p><p>语句级触发器的触发器函数为每条触发语句执行一次。</p><p>假设表examiner有10000行，定义了如下的UPDATE触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE examiner <span class="keyword">SET</span> erage <span class="operator">=</span> erage <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果是语句级触发器，则执行完该语句后，触发动作只发生1次；如果是行级触发器，则执行10000次。</p><p>触发器必须返回一个NULL或者一个元组类型的变量。</p><p>语句级触发器应返回NULL。</p><p>行级after触发器的值总是被忽略，可以返回null。</p><p>行级before触发器的返回值不同，对触发器操作的影响也不同。</p><p>如果返回NULL则忽略该触发器的行级操作，其后的触发器也不会执行。</p><p>如果返回非NULL，则返回的行将成为被插入或更新的行。</p><p>如果是行级触发器，可以在触发器函数中使用NEW和OLD引用UPDATE/INSERT事件之后的新值和UPDATE/DELETE事件之前的旧值。</p><p>插入examinee表的考号长度必须为10位：</p><p>创建触发器函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> examineeid() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $examineeid$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">IF(<span class="keyword">CHAR_LENGTH</span>(new.eeid)<span class="operator">&lt;&gt;</span><span class="number">10</span>) <span class="keyword">THEN</span></span><br><span class="line">RAISE EXCEPTION <span class="string">&#x27;格式错误&#x27;</span>;</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$examinee$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><p>NEW代表INSERT或UPDATE操作产生的新的数据行</p><p>创建触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> examineeid_insert BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> examinee</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> examineeid();</span><br></pre></td></tr></table></figure><p>三种：</p><p>1.DEFERRABLE INITIALLY DEFERRED</p><p>2.DEFERRABLE INITIALLY IMMEDIATE</p><p>3.NOT DEFERRABLE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span>&quot;subject_iddddd&quot; <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> &quot;Subjects&quot; (&quot;id&quot;) DEFERRABLE INITIALLY IMMEDIATE</span><br></pre></td></tr></table></figure><blockquote><p>注1：<strong><code>IMMEDIATE</code> 会在每一个语句执行后进行约束检查，<code>DEFERRED</code> 则只会在事务结束时才检查约束。（DEFERRED 只是推迟检查而不是不检查）</strong></p><p>注2：此设置仅影响 <strong>UNIQUE，PRIMARY KEY，REFERENCES （外键）和 EXCLUDE 约束</strong></p></blockquote><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET CONSTRAINTS &#123; <span class="built_in">ALL</span> | <span class="keyword">name</span> [, ...] &#125; &#123; <span class="keyword">DEFERRED</span> | IMMEDIATE &#125;</span><br></pre></td></tr></table></figure><p>注1：<strong>对 <code>NOT DEFERRABLE</code> 来说，<code>SET CONSTRAINTS</code> 不生效。</strong></p><p>注2：<code>SET CONSTRAINTS ALL</code> 更改所有 DEFERRABLE 约束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完整性约束&quot;&gt;&lt;a href=&quot;#完整性约束&quot; class=&quot;headerlink&quot; title=&quot;完整性约束&quot;&gt;&lt;/a&gt;完整性约束&lt;/h1&gt;&lt;p&gt;删除/更新具有引用关系的表时，有以下操作：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DataBase" scheme="https://preccrep.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://preccrep.github.io/2021/05/09/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://preccrep.github.io/2021/05/09/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-05-09T10:43:29.000Z</published>
    <updated>2021-05-22T17:11:57.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h1><p>从发送主机向接收主机传送数据段</p><p>发送主机：将数据段封装到数据报中。</p><p>接收主机：向传输层交付数据段。</p><p>每个主机和路由器都运行网络层协议。</p><p>路由器检验所有穿越它的IP数据报的头部域。</p><h2 id="网络层核心功能"><a href="#网络层核心功能" class="headerlink" title="网络层核心功能"></a>网络层核心功能</h2><h3 id="转发与路由"><a href="#转发与路由" class="headerlink" title="转发与路由"></a>转发与路由</h3><p>转发(forwarding)：将分组从路由器的输入端口转移到合适的输出端口。</p><blockquote><p>每个路由器维护一张转发表，转发表确定本路由器如何转发分组。</p><p>转发表的内容：地址-输出链路，如0100-3, 0101-2, 0111-2, 1001-1.</p><p>取出收到的数据报的地址信息，然后查转发表得到输出链路。</p></blockquote><p>路由(routing)：确定分组从源到目的经过的路径。</p><p><strong>如何得到路由信息？</strong></p><p>网络层设备都会运行一些路由协议，或路由算法(routing algorithms)，根据路由算法确定通过网络的端到端路径。</p><h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p>数据分组传输之前两端主机需要首先建立虚拟/逻辑连接，网络设备（如路由器）参与连接的建立。</p><p>网络层连接与传输层连接的对比：</p><ul><li>网络层连接：两个主机之间的连接，并且在路径上的每个网络层设备都要参与建立连接。</li><li>传输层连接：两个应用进程之间的连接（端到端的连接，对中间网络设备透明）。</li></ul><blockquote><p><strong>网络层为发送端（主机）到接收端（主机）的数据报传送”通道(channel)”提供怎样的服务模型(service model)？</strong></p><p>不同的网络架构(Network Architecture)提供的服务模型是不一样的。例如Internet提供的是best effort服务模型，不保障Bandwidth, Loss, Order或Timing，通过数据是否丢失来判断拥塞(congestion)。ATM的服务模型有CBR，VBR，ABR，UBR。</p></blockquote><p><strong>网络层服务模型</strong></p><ul><li>无连接服务(connection-less service)：<ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li><li>数据报网络(datagram network)</li></ul></li><li>连接服务(connection service)：<ul><li>首先为系列分组的传输确定从源到目的经过的路径（建立连接）</li><li>然后沿该路径（连接）传输系列分组</li><li>系列分组传输路径相同</li><li>分组传输顺序可以保证</li><li>传输结束后拆除连接</li><li>虚电路网络(virtual-circuit network)</li></ul></li></ul><h1 id="虚电路网络和数据报网络"><a href="#虚电路网络和数据报网络" class="headerlink" title="虚电路网络和数据报网络"></a>虚电路网络和数据报网络</h1><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>数据报网络和虚电路网络是典型的两类<strong>分组交换网络</strong>。</p><p>数据报网络提供网络层无连接服务。</p><p>虚电路网络提供网络层连接服务。</p><p>类似于传输层的无连接服务（UDP）和面向连接服务（TCP），但是网络层服务：</p><ol><li>是主机到主机的服务</li><li>网络核心实现（传输层是端到端实现）</li></ol><p>虚电路：一条从源主机到目的主机，类似于电路的路径（逻辑连接）。</p><ul><li>分组交换</li><li>每个分组的传输利用链路的全部带宽</li><li><p>源到目的路径经过的网络层设备共同完成虚电路功能</p></li><li><p>通信过程：呼叫建立(call setup)——数据传输——拆除呼叫</p></li><li>每个分组携带虚电路标识(VCID)，而不是目的主机地址</li><li>虚电路经过的每个网络设备（如路由器），都要维护每条经过它的虚电路的连接状态</li><li>链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配<ul><li>预分配资源 = 可预期服务性能</li><li>如ATM的电路仿真(CBR)</li></ul></li></ul><p>每条虚电路包括：</p><ol><li><p>从源主机到目的主机到一条路径</p></li><li><p>虚电路号(VCID)，沿路每段链路一个编号</p><blockquote><p>链路带宽越大，允许建立的虚电路的数量就越大。</p><p>同一条虚电路在每一段链路上的VCID可能是不一样的。</p></blockquote></li><li><p>沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路。</p></li></ol><p>沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址。</p><p>同一条VC，在每段链路上的VCID通常不同：</p><ul><li>路由器转发分组时依据转发表改写/替换虚电路号</li></ul><p><strong>虚电路信令协议(signaling protocols)</strong></p><p>用于VC的建立、维护与拆除：路径选择</p><p>应用于虚电路网络：如ATM、帧中继(frame-relay)网络等</p><p>目前的Internet不采用。</p><p>初识呼叫——呼叫到达——接受呼叫——呼叫建立——数据流开始——接收数据</p><p>通信结束后，也通过虚电路信令协议进行呼叫的拆除。</p><h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>网络层无连接</p><p>每个分组携带目的地址</p><p>路由器根据分组的目的地址转发分组：</p><ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路</li><li>每个分组走的路径可能不一样，因为如果在传输过程中路由器更新了转发表，那么后面的分组就会走新的路径</li></ul><p>数据报中含有目的主机的IP地址。但是IP地址是32位的二进制数，一共有2^32种不同情况，严重降低了传输效率。解决方法是：转发表中的目的地址不是一个明确的地址，而是一个地址范围。这样就将许多具有共同列表地址的转发表进行了聚合。</p><p>目的地址范围的匹配采用<strong>最长前缀匹配优先</strong>（在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口[entry]）。</p><p><strong>Internet（数据报网络）</strong></p><ul><li>计算机之间的数据交换：”弹性”服务，没有严格时间需求。</li><li>链路类型众多：特点、性能各异，统一服务困难。</li><li>“智能”端系统：可以自适应、性能控制、差错恢复</li><li>简化网络，复杂”边缘”</li></ul><p><strong>ATM（VC网络）</strong></p><ul><li>电话网络演化而来</li><li>核心业务是实时对话：严格的时间、可靠性需求，需要有保障的服务。</li><li>“哑”端系统（非智能）：电话机、传真机</li><li>简化”边缘”，复杂网络</li></ul><h1 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h1><h2 id="Internet网络层"><a href="#Internet网络层" class="headerlink" title="Internet网络层"></a>Internet网络层</h2><p>主要功能就是路由和转发。</p><p>主机、路由器网络层主要功能：</p><ul><li>路由协议：路径选择，如RIP，OSPF，BGP</li><li>转发表（路由表）</li><li>IP协议：寻址规约(conventions)，数据报（分组）格式，分组处理规约</li><li>ICMP协议（互联网控制报文协议）：差错报告，路由器”信令协议”</li><li>实现IP协议，通常也要实现ICMP协议。后者可以看做是前者的一个伴随协议。</li></ul><h2 id="IP数据报（分组）格式"><a href="#IP数据报（分组）格式" class="headerlink" title="IP数据报（分组）格式"></a>IP数据报（分组）格式</h2><p>IP数据报格式：首部 + 数据(e.g. TCP, UDP段)</p><p>数据报长度是32位，即从0到31位。</p><blockquote><p>首部（固定部分5行、可变部分1行）</p><p>数据（1行）</p></blockquote><p>首部分为固定部分和可变部分。</p><p>固定部分：</p><p>版本号(4位，0~3)，首部长度，服务类型(TOS)，总长度</p><p>标识，标识位，片偏移</p><p>生存时间(TTL)，协议，首部检验和</p><p>源IP地址</p><p>目的IP地址</p><p>可变部分：</p><p>选项字段（长度可变），填充</p><ol><li><p>版本号：4位，如果是IPv4就是4，如果是IPv6就是6。</p></li><li><p>首部长度：4位。是IP分组的首部长度。</p><ul><li>以4字节为单位（1行32比特，刚好4字节）</li><li>IP固定部分首部长度为5*4=20字节</li><li>最典型的，例如是IPv4协议，那么版本号是0100(4d)，首部长度0101(5d)。</li></ul></li><li>服务类型(TOS)：8位，指示期望获得哪种类型的服务。<ul><li>1998年这个字段改名为<em>区分服务</em></li><li>只有在网络提供区分服务(DiffServ)时使用</li><li>一般情况下不使用，通常IP分组的该字段（第2字节）的值为00H</li></ul></li><li>总长度：16位，是IP分组的总字节数（首部+数据）<ul><li>最大IP分组的总长度：65535B</li><li>最小的IP分组首部：20B（可变部分为0）</li><li>IP分组可以封装的最大数据：65535-20=65515B</li><li>当然在实际中不会达到最大数据，因为一定会将它切分的。</li></ul></li><li>生存时间(TTL)：8位，是IP分组在网络中可以通过的路由器数（或跳步数）<ul><li>路由器转发一次分组，TTL减一</li><li>如果TTL=0，则路由器丢弃该IP分组</li></ul></li><li>协议：8位，指示IP分组封装的是哪个协议的数据包<ul><li>实现复用/分解</li><li>6为TCP，表示封装的是TCP段；17为UDP，表示封装的是UDP数据报</li></ul></li><li>首部校验和：16位，实现对IP分组首部的差错检测<ul><li>计算校验和时，该字段置为全0</li><li>采用反码算数运算求和，和的反码作为首部校验和字段</li><li>逐跳计算、逐跳检验</li></ul></li><li>源IP地址、目的IP地址字段各占32位</li></ol><h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>网络链路存在MTU（最大传输单元）——链路层数据可封装数据的上限。不同链路的MTU不同。</p><p>大IP分组向较小MTU链路转发时，可以被”分片”(fragmented)。</p><p>IP分片到达目的主机后进行”重组”(reassembled)。</p><p>路由器对IP分组只分片不重组。</p><p>如果此路由器不让分片，那么就把这个IP分组丢掉，一般地会再发一个ICMP的分组（具体是怎样再查查，这里只是粗略记录）。</p><p>IP首部中的总长度、标识、标识位和片偏移用来标识分片以及确定分片的相对顺序。</p><p>标识字段：16位，用于标识一个IP分组</p><ul><li>IP协议利用一个计数器，每产生一个IP分组，计数器就加一，利用此时计数器的值和其他一些信息唯一标识该IP分组</li></ul><p>标识位：3位</p><h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p>接口：主机/路由器与物理链路的连接</p><ul><li>实现网络层功能</li><li>路由器通常有多个接口</li><li>主机通常只有一个或两个接口（有线的以太网接口，无限的802.11接口）</li></ul><p>IP地址：32比特(IPv4)编号用于标识主机、路由器的<strong>接口</strong></p><p>一般用点分十进制的方式表示。</p><p>11011111 00000001 00000001 00000001 = 233.1.1.1</p><p>一个IP地址唯一标识一个接口。</p><p>IP地址与每个接口关联。</p><h3 id="IP子网-subnets"><a href="#IP子网-subnets" class="headerlink" title="IP子网(subnets)"></a>IP子网(subnets)</h3><p>IP地址：</p><ul><li>网络号(NetID) - 高位比特</li><li>主机号(HostID) - 低位比特</li></ul><p>NetID           HostID</p><p>233.1.1        .1</p><p>相同的网络号构成IP子网。</p><p>IP子网：</p><ul><li>IP地址具有相同网络号的设备接口</li><li><strong>不跨越路由器</strong>（第三及以上层网络设备）可以彼此<strong>物理联通</strong>的接口</li></ul><p>“有类”编址：</p><p>A类地址，50%：NetID(8位) + HostID(24位)</p><p>0.0.0.0 ~ 127.255.255.255</p><p>B类地址，25%：NetID(16位) + HostID(16位)</p><p>128.0.0.1 ~ 191.255.255.255</p><p>C类地址，12.5%：NetID(24位) + HostID(8位)</p><p>192.0.0.0 ~ 223.255.255.255</p><p>D类地址，6.25%：32位，1110</p><p>224.0.0.0～239.255.255.255</p><p>E类地址，6.25%：32位，1111</p><p>240.0.0.0～255.255.255.255</p><h2 id="IP子网划分与子网掩码"><a href="#IP子网划分与子网掩码" class="headerlink" title="IP子网划分与子网掩码"></a>IP子网划分与子网掩码</h2><p>子网划分：</p><p>IP地址——网络号(NetID) + 子网号(SubID) + 主机号(HostID)</p><p>就是将刚才的主机号划分为了：子网号(SubID) + 主机号(HostID)。即 子网号是原主机号的部分比特。</p><p>子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台主机，它们处于同一广播域。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。可以把基于每类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址，子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。</p><p>比如，当一组IP地址指定给一个公司时，公司可能将该网络“分割成”小的网络，每个部门一个。这样，技术部门和管理部门都可以有属于它们的小网络。通过划分子网，我们可以按照我们的需要将网络分割成小网络。这样也有助于降低流量和隐藏网络的复杂性。</p><p>子网掩码：</p><p>形如IP地址：32位，点分十进制形式</p><p>取值：NetID, SubID位全取1，HostID全取0</p><p>例如：</p><p>A网的默认子网掩码为：255.0.0.0</p><p>B网的默认子网掩码为：255.255.0.0</p><p>C网的默认子网掩码为：255.255.255.0</p><p>借用3比特划分子网的B网的子网掩码为：255.255.224.0 （224就是11100000）</p><p><strong>子网地址+子网掩码</strong> —— 准确确定子网大小</p><p>将IP分组的目的IP地址与子网掩码<strong>按位与</strong>运算，提取子网地址。</p><h1 id="CIDR与路由聚集"><a href="#CIDR与路由聚集" class="headerlink" title="CIDR与路由聚集"></a>CIDR与路由聚集</h1><p>无类域间路由(CIDR: Classless InterDomain Routing)</p><ul><li><p>消除传统的A、B、C类地址界限：将NetID和SubID合在一起变成Network Prefix(Prefix)，即统称为网络前缀，并且可以任意长度</p></li><li><p>融合子网地址与子网掩码，方便子网划分</p><p>无类地址格式：a.b.c.d/x，其中x为前缀长度</p></li></ul><p>11001000 00010111 0001000<strong>0 00000000</strong></p><p>前面是前缀（长为8+8+7=23），后面是主机号HostID。</p><p>写成CIDR地址形式就是200.23.16.0/23。</p><p><strong>优势</strong></p><ul><li>提高IPv4地址空间分配效率</li><li>提高路由效率<ul><li>将多个子网聚合为一个较大的子网</li><li>构成超网</li><li>路由聚合(route aggregation)</li></ul></li></ul><h1 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h1><p>如何获得IP地址？</p><ul><li><p>“硬编码”：静态配置</p></li><li><p>动态主机配置协议 - DHCP：Dynamic Host Configuration Protocol</p><p>从服务器动态获取：IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址</p><p>“即插即用”</p><p>允许地址重用</p><p>支持在用地址续租</p><p>支持移动用户加入网络</p></li></ul><p><strong>动态主机配置协议DHCP</strong></p><ol><li>主机广播”DHCP discover”（发现报文）等待是否有DHCP服务器响应</li><li>DHCP服务器利用”DHCP offer”（提供报文）进行响应，告诉客户端自己可以提供的一个IP地址</li><li>主机请求IP地址：客户端向服务器发送”DHCP request”（请求报文）表示愿意接受这个IP地址同时请求服务器将它真正分配给自己</li><li>DHCP服务器分配IP地址：服务器向客户端发送”DHCP ack”（确认报文）表示确认分配</li></ol><p>DHCP协议在应用层实现：</p><ul><li>请求报文封装到UDP数据报中</li><li>IP广播</li><li>链路层广播（例如，以太网广播）</li></ul><p>DCHP服务器内建于服务器中。</p><p>DHCP服务器构造ACK报文，包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址。</p><h1 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h1><p>本地网络内通信的IP数据报的源与目的IP地址均在子网10.0.0/24（显然这是一个私有地址，比如说是家庭网络）内。</p><p>所有离开本地网络去往Internet的数据报的源IP地址需要替换为相同的NAT IP地址（例如138.76.29.7）以及不同的端口号。</p><p>动机：</p><ul><li>只需从ISP申请一个IP地址，因此面临IPv4地址耗尽</li><li>本地网络设备IP地址的变更，无需通告外界网络</li><li>变更ISP时，无需修改内部网络设备IP地址</li><li>内部网络设备对外界网络不可见，即不可直接寻址</li></ul><p>实现：</p><ul><li>替换：利用(NAT IP地址，新端口号)替换每个外出IP数据报的(源IP地址，源端口号)</li><li>记录：将每对(NAT IP地址，新端口号)与(源IP地址，源端口号)的替换信息存储到NAT转换表中</li><li>根据NAT转换表，用(源IP地址，源端口号)替换每个进入内网IP数据报的(目的IP地址，目的端口号)</li></ul><p>NAT转换表包含：WAN端地址、LAN端地址。</p><p>NAT穿透问题：外部设备期望连接内网地址的服务器</p><p>方法1: 静态配置NAT（转换表），将特定端口的连接请求转发给服务器。</p><p>方法2: 利用UPnP(Universal Plug and Play)互联网网关设备协议(IGD-Internet Gateway Device)自动配置：学习到NAT公共IP地址，在NAT转换表中增删端口映射。</p><p>方法3: 中继(如Skype)</p><h1 id="互联网控制报文协议ICMP"><a href="#互联网控制报文协议ICMP" class="headerlink" title="互联网控制报文协议ICMP"></a>互联网控制报文协议ICMP</h1><p>Internet Control Message Protocol支持主机或路由器</p><p>差错或异常报告</p><p>网络探询</p><p>两类ICMP报文：</p><p>差错报文</p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>最初动机：32位IPv4地址空间已分配殆尽</p><p>其他动机：改进首部格式：快速处理/转发数据报，支持QoS</p><p>IPv6数据报格式：</p><ul><li>固定长度的40字节基本首部</li><li>不允许分片</li></ul><p>虽然首部没有可选项、是固定长度，但是有可选的扩展首部。</p><p>IPv6数据报格式：</p><p>基本首部，扩展首部1，扩展首部2，…，扩展首部N，数据部分（例如TCP段）</p><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><p>路由算法（协议）确定最佳路径，转发表确定在本路由器如何转发分组。</p><h2 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h2><h3 id="静态路由-amp-动态路由"><a href="#静态路由-amp-动态路由" class="headerlink" title="静态路由&amp;动态路由"></a>静态路由&amp;动态路由</h3><p>静态路由：</p><ul><li>手工配置</li><li>路由更新慢</li><li>优先级高</li></ul><p>动态路由：</p><ul><li>路由更新快<ul><li>定期更新</li><li>及时响应链路费用或网络拓扑结构变化</li></ul></li><li>由路由算法计算出来的</li></ul><h3 id="全局信息-amp-分散信息"><a href="#全局信息-amp-分散信息" class="headerlink" title="全局信息&amp;分散信息"></a>全局信息&amp;分散信息</h3><p>全局信息：</p><ul><li>所有路由器掌握完整的网络拓扑和链路费用信息。</li><li>链路状态（LS）路由算法</li></ul><p>分散信息：</p><ul><li>路由器只掌握物理相连的邻居以及链路费用。</li><li>距离向量（DV）路由算法</li></ul><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p>Dijkstra算法</p><ul><li><p>c(x, y): 结点x到结点y的链路费用；如果x和y不直接相连，则为∞。</p></li><li><p>D(v): 从源到目的v的当前路径费用值。</p></li><li>p(v): 沿从源到v的当前路径，v的前序结点集合。</li><li>N’: 已经找到最小费用路径的结点集合。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">N&#x27;= &#123;u&#125;</span><br><span class="line"><span class="keyword">for</span> 所有结点v</span><br><span class="line"><span class="keyword">if</span> v nextTo u</span><br><span class="line"><span class="constructor">D(<span class="params">v</span>)</span> = c(u, v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="constructor">D(<span class="params">v</span>)</span> = ∞</span><br><span class="line"></span><br><span class="line">循环：</span><br><span class="line">找出不在N&#x27;中的结点w，使得<span class="constructor">D(<span class="params">w</span>)</span>最小</span><br><span class="line">将w加入N&#x27;</span><br><span class="line">更新w的所有不在N&#x27;中的邻居v的<span class="constructor">D(<span class="params">v</span>)</span>: <span class="constructor">D(<span class="params">v</span>)</span> = min&#123;c(v, w)+<span class="constructor">D(<span class="params">w</span>)</span>, <span class="constructor">D(<span class="params">v</span>)</span>&#125;</span><br><span class="line">until 所有结点都在N&#x27;中</span><br></pre></td></tr></table></figure><p>但是存在振荡现象。</p><h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>Bellman-Ford方程（动态规划）</p><ul><li>Dx(y) := 从x到y最短路径的费用（距离）</li><li>Dx(y) = min{c(x, v) + Dv(y)}</li></ul><p>异步迭代：</p><ul><li>引发每次局部迭代的因素：<ul><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul></li></ul><p>分布式：</p><ul><li>每个结点只当DV变化时才通告给邻居</li></ul><p>无穷计数问题</p><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>将任意规模网络抽象为一个图计算路由——过于理想化。</p><p>标识所有路由器</p><p>“扁平”网络</p><p>网络规模巨大时，交换量会占用所有网络带宽。</p><p>聚合路由器为一个区域：自治系统AS</p><h2 id="Internet路由"><a href="#Internet路由" class="headerlink" title="Internet路由"></a>Internet路由</h2><p>AS内部路由：</p><ul><li>Internet采用层次路由</li><li>AS内部路由协议也称为内部网络协议IGP(interior gateway protocol)</li><li>最常见的AS内部路由协议：<ul><li>路由信息协议：RIP(Routing Information Protocol)</li><li>开放最短路径优先：OSPF(Open Shortest Path First)</li><li>内部网关路由协议：IGRP(Interior Gateway Routing Protocol)<ul><li>Cisco私有协议</li></ul></li></ul></li></ul><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>早于1982年随BSD- UNIX操作系统发布</p><p>跳数指从<strong>源端口到达目的端口所经过的路由个数，</strong>每经过一个路由器，跳数加1 。数据包经过一台路由器就是一跳，经过的路由器数量，就是它的跳数。</p><p>距离向量路由算法：</p><ul><li>距离度量：跳步数(max = 15hops)，每条链路1个跳步</li><li>每隔30秒，邻居之间交换一次DV，成为通告(advertisement)</li><li>每次通告：最多25个目的子网(IP地址形式)</li></ul><p><a href="https://zhuanlan.zhihu.com/p/138122809#:~:text=%E8%B7%B3%E6%95%B0%E6%8C%87%E4%BB%8E%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%80%E7%BB%8F%E8%BF%87%E7%9A%84%E8%B7%AF%E7%94%B1%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%AF%8F%E7%BB%8F%E8%BF%87%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E8%B7%B3%E6%95%B0%E5%8A%A01%20%E3%80%82.,%E5%9C%A8%E8%BF%99%E7%A7%8D%E7%AE%97%E6%B3%95%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E9%83%BD%E5%BF%85%E9%A1%BB%E5%8F%82%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E4%BA%A4%E6%8D%A2%EF%BC%8C%E4%BB%A5%E4%BF%9D%E8%AF%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E7%BB%93%E7%82%B9%E9%83%BD%E7%9B%91%E5%90%AC%E4%BB%8E%E5%85%B6%E4%BB%96%E7%BB%93%E7%82%B9%E4%BC%A0%E6%9D%A5%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%B8%8B%E5%88%97%E6%83%85%E5%86%B5%E4%B8%8B%E6%9B%B4%E6%96%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E8%A1%A8%EF%BC%9A.%20%E8%A2%AB%E9%80%9A%E5%91%8A%E4%B8%80%E6%9D%A1%E6%96%B0%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%AF%A5%E8%B7%AF%E7%94%B1%E5%9C%A8%E6%9C%AC%E7%BB%93%E7%82%B9%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%85%A5%E8%BF%99%E6%9D%A1%E6%96%B0%E7%9A%84%E8%B7%AF%E7%94%B1%E3%80%82.%20%E5%8F%91%E6%9D%A5%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E4%B8%AD%E6%9C%89%E4%B8%80%E6%9D%A1%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%AA%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%AF%A5%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E7%9B%B8%E6%AF%94%EF%BC%8C%E6%9C%89%E8%BE%83%E7%9F%AD%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%88%E8%BE%83%E5%B0%8F%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%89%E3%80%82.">LINK</a></p><p>OSPF(Open Shortest Path First)协议：</p><ul><li>开放：公众可用</li><li>采用链路状态路由算法</li><li></li></ul><p>Don’t let anyone rush yourself with their timelines.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层服务&quot;&gt;&lt;a href=&quot;#网络层服务&quot; class=&quot;headerlink&quot; title=&quot;网络层服务&quot;&gt;&lt;/a&gt;网络层服务&lt;/h1&gt;&lt;p&gt;从发送主机向接收主机传送数据段&lt;/p&gt;
&lt;p&gt;发送主机：将数据段封装到数据报中。&lt;/p&gt;
&lt;p&gt;接收主机：向传输层交</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://preccrep.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="https://preccrep.github.io/2021/05/03/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://preccrep.github.io/2021/05/03/%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2021-05-03T01:15:47.000Z</published>
    <updated>2021-05-22T08:14:20.281Z</updated>
    
    <content type="html"><![CDATA[<p>传输层服务的基本理论和基本机制：</p><ul><li>多路复用/分用</li><li>可靠数据传输机制</li><li>流量控制机制</li><li>拥塞控制机制</li></ul><p>Internet的传输层协议</p><ul><li>UDP: 无连接传输服务</li><li>TCP: 面向连接的传输服务</li><li>TCP拥塞控制</li></ul><p>主机上运行着五层Internet协议栈，有应用层、传输层、网络层、数据链路层和物理层；路由器上只有三层协议栈，即网络层及以上的是没有的。</p><p>传输层协议为运行在不同host上的进程提供了一种<strong>逻辑通信机制</strong>。</p><blockquote><p>逻辑通信机制，就是指进程之间仿佛是直接连接的，不需要关心有多远的物理距离、经过了多少个路由器、使用的是什么物理媒介。</p></blockquote><p>端系统运行传输层协议：</p><ul><li>发送方：将应用递交的消息分成一个或多个的segment，并向下传给网络层。</li><li>接收方：将接收到的segment组装成消息，并向上交给应用层。</li></ul><p>传输层可以为应用提供多种协议：</p><ul><li>Internet上的TCP</li><li>Internet上的UDP</li></ul><p><strong>比较</strong></p><ul><li><p>网络层：提供<strong>主机</strong>之间的逻辑通信机制</p></li><li><p>传输层：提供<strong>应用进程</strong>之间的逻辑通信机制</p><p>— 位于网络层之上（IP），依赖于网络层服务，对网络层进行（可能的）增强</p></li></ul><h1 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h1><p>可靠、按序的交付服务（TCP）</p><ul><li>拥塞控制</li><li>流量控制</li><li>连接建立</li></ul><p>不可靠的交付服务（UDP）</p><ul><li>基于”尽力而为 (best-effort) “的网络层，没有做（可靠性方面的）扩展</li></ul><p><strong>两种服务均不提供：延迟、带宽</strong></p><h2 id="多路复用和多路分用"><a href="#多路复用和多路分用" class="headerlink" title="多路复用和多路分用"></a>多路复用和多路分用</h2><p>为什么要多路复用/分用？</p><ul><li>如果某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用。</li></ul><p>socket是应用层和传输层之间的”门”。</p><p><strong>接收端进行多路分用</strong>：传输层依据头部信息将收到的segment交给正确的socket，即不同的进程。</p><p><strong>发送端进行多路复用</strong>：从多个socket接收数据，为每块数据封装上头部信息，生成segment，交给网络层。</p><h3 id="分用——如何工作？"><a href="#分用——如何工作？" class="headerlink" title="分用——如何工作？"></a>分用——如何工作？</h3><p>主机接收到 IP 数据报（datagram）</p><ul><li>每个数据报携带源 IP 地址、目的 IP 地址</li><li>每个数据报携带一个传输层的段（segment）</li><li>每个段携带源端口号和目的端口号</li></ul><p>TCP/UDP 段格式：</p><p>|——————- 32 bits ——————-|</p><p>|   源端口号   |  目的端口号  |</p><p>|            其他头部信息            |</p><p>|      应用数据 (message)       |</p><p>主机收到segment后，传输层协议提取IP地址和端口号信息，将segment导向相应的socket。（网络层是不关心端口号信息的）TCP会做更多的处理。</p><p><strong>无连接分用</strong></p><p>UDP的socket用<strong>二元组</strong>标识（目的IP地址，目的端口号）</p><p>主机收到UDP段后：</p><ul><li>检查段中的目的端口号</li><li>将UDP段导向绑定在该端口号的socket</li></ul><p>来自不同源IP地址和/或源端口号的IP数据包被导向同一个socket。</p><p><strong>面向连接分用</strong></p><p>TCP的socket用<strong>四元组</strong>标识：</p><ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul><p>接收端利用所有的4个值将segment导向合适的socket。</p><p>服务器可能同时支持多个TCP socket。每个socket用自己的四元组标识。</p><p>web服务器为每个客户端开不同的socket。</p><blockquote><p>也就是说，例如host B中的进程1向host A发起TCP连接，SP(source port)是9157，DP是80；进程2也发起TCP连接，SP是5775，DP是80；两个进程的S-IP和D-IP相同，都是B和A。但是socket不同，服务器为每个客户端开不同的socket。进程1对应socket1，进程2对应socket2。服务器上的这两个socket的SP相同，都是80，S-IP和D-IP也分别相同，但是DP不同，分别是5775和9157.</p></blockquote><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>User Datagram Protocol [ RFC 768 ]</p><p>基于Internet IP协议：</p><ul><li>复用/分用</li><li>简单的错误校验（因为路由器在存储转发的过程中也可能会出错）</li></ul><p>UDP提供的是”Best effort”服务，所以会丢失、非按序到达。</p><p>每个UDP段的处理独立于其他段。</p><blockquote><p>UDP为什么存在？</p><ul><li>无需建立连接（减少延迟，因此DNS使用的是UDP）</li><li>实现简单：无需维护连接状态</li><li>头部开销少（UDP头部8个字节，而TCP是20个字节）</li><li>没有拥塞控制：应用可以更好地控制发送时间和速率（TCP有拥塞控制，会根据实际情况自动调整发送时间和速率）</li></ul></blockquote><p>常用于流媒体应用：容忍丢失、速率敏感</p><p>UDP还用于：DNS，SNMP</p><p><strong>在UDP上是可以实现可靠数据传输的</strong>——在应用层增加可靠性机制、应用特定的错误恢复机制（即在应用层实现，因此对应用层开发人员来说难度较大）</p><p>UDP segment format:</p><p>[32bits]</p><p>|         sp         |          dp         |</p><p>|     length      |    checksum  |</p><p>| Application data (message)|</p><p>length是UDP段的长度（包含头部），checksum是校验和（实现错误校验功能）。</p><h3 id="UDP-checksum"><a href="#UDP-checksum" class="headerlink" title="UDP checksum"></a>UDP checksum</h3><p>目的：检测UDP段在传输过程中是否发生错误（如位翻转）。</p><p>发生错误是因为传输是端到端的，可能经历了多种物理媒介、多个路由器等等，中途很有可能发生错误。</p><p><strong>发送方</strong>：</p><ul><li>将段的内容视为16-bit整数</li><li>校验和计算：计算所有整数的和，进位单独取出来与剩下的16位相加，将得到的值按位求反，得到校验和</li><li>发送方将校验和放入校验和字段</li></ul><p><strong>接收方</strong>：</p><ul><li>计算所收到的校验和</li><li>将其与校验和字段进行对比，若不相等则检测出错误，若相等则没有检测出错误，但仍然可能有错误</li></ul><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>可靠——不错、不丢、不乱</p><p>可靠数据传输协议：</p><ul><li>可靠数据传输对应用层、传输层、链路层都很重要</li><li>网络top-10问题</li><li>信道的不可靠特性决定了可靠数据传输协议 (rdt) 的复杂性</li></ul><p><strong>可靠数据传输协议基本结构：接口</strong></p><p>rdt_send(): 被上层应用调用，将数据交给rdt (reliable data transfer protocol) 以发送给对方。即发送方向上地响应这样一个rdt_send的调用。</p><p>udt_send(): 被rdt调用，在不可靠信道(unreliable channel)上向接收方传输数据。（所谓的不可靠信道，实际上就是我们所说的网络层的IP协议）</p><p>rdt_rcv(): 当数据包到达接收方信道时被调用。这一调用就会触发接收方的rdt协议对数据包进行处理。</p><p>deliver_data(): 被rdt调用，向上层应用交付数据。</p><p>可以看出，rdt_send()和deliver_send()是单向的。这是因为应用层只需要发数据和收数据，不关心数据是怎么处理和传输的。剩下的所有工作都由下面的层完成。</p><h3 id="可靠数据传输协议"><a href="#可靠数据传输协议" class="headerlink" title="可靠数据传输协议"></a>可靠数据传输协议</h3><p>渐进的设计可靠数据传输协议的发送方和接收方，只考虑单向数据传输，但控制信息双向流动。利用有限状态机(Finite State Machine, FSM)刻画传输协议。</p><p>协议：（逐步贴近真实情况）</p><h4 id="Rdt-1-0-可靠信道上的可靠数据传输"><a href="#Rdt-1-0-可靠信道上的可靠数据传输" class="headerlink" title="Rdt 1.0: 可靠信道上的可靠数据传输"></a>Rdt 1.0: 可靠信道上的可靠数据传输</h4><p>假设底层信道完全可靠：不会发生位错误，不会丢弃分组</p><p>发送方和接收方的FSM独立（因为这是一个可靠信道！发送方和接收方之间就不需要什么交互，全部交给协议处理就行了）</p><h4 id="Rdt-2-0-产生位错误的信道"><a href="#Rdt-2-0-产生位错误的信道" class="headerlink" title="Rdt 2.0: 产生位错误的信道"></a>Rdt 2.0: 产生位错误的信道</h4><p>假设分组不会丢失，只是产生了位错误。</p><p>首先，接收方需要知道分组是否出错。如果错了，就要想办法恢复/重传。</p><p>检测出错已解决——底层信道可能翻转分组中的位(bit)：利用校验和检测位错误</p><p>如何从错误中恢复？这就需要引入新的控制消息来标识——</p><ul><li>确认机制(Acknowledgements, ACK)：接收方显示地告知发送方分组已正确接收。</li><li>NAK：接收方显示地告知发送方分组有错误。</li><li>发送方收到NAK后，<strong>重传</strong>分组。</li></ul><p>基于这种重传机制的rdt协议称为ARQ(Automatic Repeat Request)协议。</p><p>Rdt 2.0中引入的新机制：</p><ul><li>差错检测</li><li>接收方反馈控制消息：ACK/NAK</li><li>重传</li></ul><p>但是有一个致命缺陷：如果ACK/NAK的传输出错怎么办？这里使用的是停-等协议，即stop and wait — sender sends one packet, then waits for receiver response.</p><p>what happens if ACK/NAK corrupted?</p><ul><li><p>sender doesn’t know what happened at receiver!</p></li><li><p>can’t just retransmit: possible duplicate</p></li></ul><p>Handling duplicates:</p><ul><li><p>sender retransmits current pkt if ACK/NAK corrupted</p></li><li><p>sender adds <em>sequence number</em> to each pkt</p></li><li><p>receiver discards (doesn’t deliver up) duplicate pkt</p></li></ul><h4 id="Rdt-2-1-发送方应对ACK-NAK破坏"><a href="#Rdt-2-1-发送方应对ACK-NAK破坏" class="headerlink" title="Rdt 2.1 发送方应对ACK/NAK破坏"></a>Rdt 2.1 发送方应对ACK/NAK破坏</h4><p>增加了两个序列号0和1。</p><p>对于发送方，有等待上层调用的状态和等待ACK/NAK的状态这两种，因此总状态是翻倍了的，即两个0两个1。（等待上层调用序列号0分组的状态，等待序列号0的ACK/NAK的状态，等待上层调用序列号1分组的状态，等待序列号1的ACK/NAK的状态）翻倍是因为必须记住当前分组的序列号。</p><h4 id="Rdt-2-2-无NAK消息协议"><a href="#Rdt-2-2-无NAK消息协议" class="headerlink" title="Rdt 2.2: 无NAK消息协议"></a>Rdt 2.2: 无NAK消息协议</h4><p>接收方通过ACK告知最后一个被正确接收的分组，在ACK中显示地加入被确认分组的序列号。</p><p>发送方接收到重复ACK后，重发当前分组。</p><p>停等操作使得Rdt 3.0的性能很差。</p><h4 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h4><p>允许发送方在收到ACK之前连续发送多个分组。这就需要更大的<strong>序列号范围</strong>，发送方和接收方需要更大的存储空间以<strong>缓存分组</strong>。</p><h4 id="滑动窗口协议-Sliding-window-protocol"><a href="#滑动窗口协议-Sliding-window-protocol" class="headerlink" title="滑动窗口协议 Sliding-window protocol"></a>滑动窗口协议 Sliding-window protocol</h4><p>窗口：允许使用的序列号范围</p><p>窗口尺寸为N，表示最多有N个等待确认的消息。</p><p>滑动窗口：随着协议的<strong>运行</strong>，窗口在序列号空间内<strong>向前滑动</strong>。</p><p>滑动窗口协议：GBN，SR</p><p><strong>GBN协议 (Go-Back-N)</strong></p><p>分组头部包含k-bit序列号</p><p>采用累积确认的机制</p><p>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收。</p><p>超时timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组。</p><p>ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK</p><ul><li>可能产生重复的ACK</li><li>只需要记住唯一的expectedseqnum</li></ul><p>乱序到达的分组：</p><ul><li>直接丢弃——接收方不缓存</li><li>重新确认序列号最大的、按序到达的分组</li></ul><p><strong>SR (Selective Repeat)</strong></p><p>接收方对每个分组单独进行确认</p><ul><li>设置<strong>缓存机制</strong>，缓存乱序到达的分组</li></ul><p>发送方只重传那些没收到ACK的分组</p><ul><li>为每个分组设置定时器</li></ul><p>发送方窗口</p><ul><li>N个连续的序列号</li><li>限制已发送且未确认的分组</li></ul><p>序列号空间大小与窗口尺寸满足的关系：$N_S+N_R\leq2^k$.</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li><p>点对点：一个发送方，一个接收方</p></li><li><p>可靠的、按序的字节流</p></li><li><p>流水线机制：TCP拥塞控制和流量控制机制设置窗口尺寸</p></li><li><p>发送方/接收方缓存</p></li><li><p>全双工 (full-duplex)：统一连接中能够传输双向数据流</p></li><li><p>面向连接：</p><p>通信双方在发送数据之前必须建立连接</p><p>连接状态只在连接的两端中维护，在沿途节点中并不维护状态</p><p>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</p></li><li><p>流量控制机制</p></li></ul><p><strong>序列号</strong></p><ul><li>序列号指的是segment中第一个字节的编号，而不是segment的编号，通常从500开始</li><li>建立TCP连接时，双方随即选择序列号</li></ul><p><strong>ACKs</strong></p><ul><li>希望接收到的下一个字节的序列号</li><li>累积确认：该序列号之前的所有字节均已被正确接收到</li></ul><p>接收方如何处理乱序到达的segment？</p><ul><li>TCP规范中没有规定，由TCP的实现者做出决策</li></ul><p><strong>TCP可靠数据传输</strong></p><ul><li><p>TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务</p></li><li><p>流水线机制</p></li><li><p>累积确认</p></li><li><p>TCP使用单一重传定时器</p></li><li>触发重传的事件：超时，收到重复ACK</li><li>渐进式：暂不考虑重复ACK，暂不考虑流量控制，暂不考虑拥塞控制</li></ul><p><strong>RTT和超时</strong></p><p>如何设置定时器的超时时间？</p><ul><li>大于RTT——但是RTT是变化的</li><li>过短：不必要的重传</li><li>过长：对段丢失时间反应慢</li></ul><p>如何估计RTT？</p><ul><li><p>SampleRTT：测量从段发出去到收到ACK的时间</p></li><li><p>忽略重传</p></li><li><p>SampleRTT变化，就测量多个取平均值</p></li><li><p>指数加权移动平均：</p><p>EstimatedRTT=(1-alpha)*EstimatedRTT+alpha*SampleRTT</p><p>典型值：0.125</p></li></ul><p><strong>TCP发送方要处理的事件</strong></p><p>从应用层收到数据：</p><ul><li>创建segment</li><li>序列号是segment第一个字节的编号</li><li>开启计时器</li><li>设置超时时间TimeoutInterval</li></ul><p>超时：</p><ul><li>重传引起超时的segment</li><li>重启定时器</li></ul><p>收到ACK：</p><p>如果确认此前未确认的segment</p><ul><li>更新SendBase</li><li>如果窗口中还有未被确认的分组，重新启动定时器</li></ul><p><strong>快速重传机制</strong></p><p>TCP实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大，因此重发丢失的分组之前要等待很长时间。</p><p>通过重复ACK检测分组丢失</p><p>如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失，sender重传该分组。</p><p>快速重传：在定时器超时之前即进行重传</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>接收方为TCP连接分配buffer。</p><p>流量控制 (flow control)：发送方不会传输的太多、太快以至于淹没接收方（buffer溢出）。</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP sender和receiver在传输数据前需要建立连接</p><p>client是连接发起者，server等待客户连接请求。</p><h3 id="Three-way-handshake"><a href="#Three-way-handshake" class="headerlink" title="Three way handshake"></a>Three way handshake</h3><ol><li><p>client host sends TCP SYN segment to server</p><p>specifies initial seq</p><p>no data</p></li><li><p>server host receives SYN, replies with SYNACK segment</p><p>server allocates buffers</p><p>specifies server initial seq</p></li><li><p>client receives SYNACK, replies with ACK segment, which may contain data</p></li></ol><h3 id="TCP关闭——4次挥手"><a href="#TCP关闭——4次挥手" class="headerlink" title="TCP关闭——4次挥手"></a>TCP关闭——4次挥手</h3><p>client向server发送FIN</p><p>server收到FIN，回复ACK，关闭连接，发送FIN</p><p>client收到FIN，回复ACK</p><ul><li>进入等待状态，timeout了会重复发送ACK</li></ul><p>server收到ACK，连接关闭</p><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞(congestion)</p><p>表现：</p><ul><li>分组丢失（路由器缓存溢出）</li><li>分组延迟过大（在路由器缓存中排队）</li></ul><p><strong>拥塞控制的方法</strong></p><p>端到端的拥塞控制：</p><ul><li>网络层不需要显式地提供支持</li><li>端系统通过观察loss, delay等网络行为判断是否发生拥塞</li><li>TCP采取这种方法</li></ul><p>网络辅助的拥塞控制：</p><ul><li>路由器向发送方显示地反馈网络拥塞信息</li><li>简单的拥塞只是说</li></ul><p>TCP快速重传为什么3次ACK</p><p>TCP为什么3次握手</p><p>TCP MSS</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传输层服务的基本理论和基本机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多路复用/分用&lt;/li&gt;
&lt;li&gt;可靠数据传输机制&lt;/li&gt;
&lt;li&gt;流量控制机制&lt;/li&gt;
&lt;li&gt;拥塞控制机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Internet的传输层协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP: 无连</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://preccrep.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java复习</title>
    <link href="https://preccrep.github.io/2021/04/10/Java%E5%A4%8D%E4%B9%A0/"/>
    <id>https://preccrep.github.io/2021/04/10/Java%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-04-10T11:38:31.000Z</published>
    <updated>2021-04-10T14:29:38.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h1><blockquote><p>感觉自己没救了😭</p></blockquote><p>路径分隔符：</p><p><code>static String pathSeparator</code></p><p><code>static char pathSeparatorChar</code></p><p>文件名称分隔符：</p><p><code>static String separator</code></p><p><code>static char separatorChar</code></p><p>操作路径：<code>&quot;Code&quot;+File.separator+&quot;Java&quot;+File.separator+&quot;Homework&quot;</code></p><p>String类型和char类型作用完全相同，因为在源码里是这样的：</p><p><code>public static final String pathSeparator=&quot;&quot;+pathSeparatorChar;</code></p><p>路径是不区分大小写的。Unix中文件名称分隔符是<code>/</code>，Windows是<code>\</code>，但是这是转义字符，所以写的时候要写成<code>\\</code>.</p><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>File(String pathname)</code> 通过将给定路径名字符串转换为抽象路径名来创建一个新File实例。路径结尾可以是文件也可以是文件夹。可以是相对路径或绝对路径。路径可以存在也可以不存在。<strong>这是因为创建File对象，只是把字符串路径封装成File对象，不考虑路径的真假情况。</strong></p><p><code>File(String parent, String child)</code></p><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><code>public String getAbsolutePath()</code> 返回此File的绝对路径</li><li><code>public String getPath()</code> 将此File转换为路径名字符串(就是把结果放到这个File对象中返回)</li><li><code>public String getName()</code> 返回此File表示的文件或目录的名称</li><li><code>public long length()</code> 返回由此File表示的文件的长度，以字节为单位。不能是文件夹。若文件不存在，则返回0.</li></ul><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> 此File表示的文件或目录是否实际存在</li><li><code>public boolean isDirectory()</code> 此File表示的是否为目录</li><li><code>public boolean isFile()</code> 此File表示的是否是文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件IO操作&quot;&gt;&lt;a href=&quot;#文件IO操作&quot; class=&quot;headerlink&quot; title=&quot;文件IO操作&quot;&gt;&lt;/a&gt;文件IO操作&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;感觉自己没救了😭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;路径分隔符：&lt;/p&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://preccrep.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习</title>
    <link href="https://preccrep.github.io/2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
    <id>https://preccrep.github.io/2021/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-04-07T13:01:36.000Z</published>
    <updated>2021-06-09T13:01:25.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库使用一个或多个表来存储数据。<br>数学上把一系列域上的笛卡尔积的子集称为关系。</p><p>软件系统无法保证数据的真实正确性，但可以保证数据符合可明确定义的约束。这种约束通常称为完整性约束。它是数据安全性的一部分。<br>常见的简单约束有两种形式，一种是对属性取值范围的确定，比如性别只有男、女两种属性的取值（个人认为应该是三种，男、女、无 :)  ）。另一种是对属性值之间相互关系的限定，最典型的就是关系模型中键的定义，如主键、超键、外键、候选键。<br>超键：在给定关系模式中，能唯一标识出各个元组的属性集合。超键中可能包含无关紧要的属性，也就是说超键的真子集也可能是超键。例如在学生成绩表中有学号、姓名和成绩3个属性，其中学号是超键，而且也是主键，因为姓名和成绩可能重复，但学号是唯一的。{学号，姓名}，{学号，成绩}，{学号，姓名，成绩}也是超键。<br>候选键：在给定关系模式中，能够唯一标识出各个元组的属性集合，并且不含多余属性。候选键是超键，但超键不一定是候选键。只有不存在任何真子集是超键的超键才是候选键。<br>主键：一个关系中可能有多个候选键，通常指定其中一个，并且只能是一个，用来标识元组。由于主键具有唯一性，所以主键是候选键，但候选键不一定是主键。<br>外键：如果关系表S1的一个属性子集A，必须匹配另一个关系表S2中出现的数值，则称A是关系表S1的外键。其中，S1称为引用关系，S2称为被引用关系。外键的值，或与被引用关系中出现的数值对应，或为空值。例如关系表1中有院系这个属性，并且是外键，对应关系表2中的单位这个属性，而院系属性中有工程学院，单位属性中此项为教育学院或为空值，那么就出问题了。如果院系属性也为教育学院，或者院系属性为空而单位属性为教育学院，那么是可以的。</p><p>可以用代数、逻辑等方法描述关系操作，最基本最常用的是代数方法，即关系代数。<br>关系代数也是一门代数，关系代数包括一个运算集合，这些运算以一个或两个关系作为运算数，产生一个新的关系作为结果。<br>关系代数运算包含基本关系代数运算、附加关系代数运算和扩展关系代数运算。其中基本关系代数运算包含选择、投影、集合并、集合差、笛卡尔积和更名运算。</p><p>选择：选择运算是选出满足给定谓词（条件）的元组，结果关系和原关系有着相同的模式。<br>选择运算用 $\sigma$ 表示。将谓词写作 $\sigma$ 的右下标，并在 $\sigma$ 后面的括号中给出作为参数的关系名。例如：</p><script type="math/tex; mode=display">\sigma_{gender=none}(students)</script><p>就是在students关系表中选出gender属性为none的元组。（hhh）<br>投影：投影运算用来从给定关系产生一个只有其部分列的新关系。投影运算用 $\pi$ 表示。所有希望在结果关系中出现的属性作为右下标，作为参数的关系名紧跟在 $\pi$ 后面的括号中。结果关系的模式是 $\pi$ 的下标中列出的所有属性，并按 $\pi$ 下标中列出的顺序出现。例如：</p><script type="math/tex; mode=display">\pi_{id,age}(students)</script><p>于是结果关系中只包含id和age两个属性，并且会去掉结果关系中重复的元组。<br>⚠️ 关系代数把表看作是作为元组集合的关系，既然是集合，就不包括重复元组，也就是说，关系代数每个运算都是去重的。<br>并运算：关系是相容的。两个关系必须是同元的，即它们所包含的属性个数必须相同；两个关系对应属性的域必须相同或相容。<br>例如，找出所有已有考生报考又安排了考官组卷的eid：</p><script type="math/tex; mode=display">\pi_{eid}(eeexam) \bigcup \pi_{eid}(erexam)</script><p>差运算：用来查询在一个关系中而不在另一个关系中的那些元组，和并运算一样，差运算只能在相容的关系间进行。<br>例如，找出所有已有考生报考但没有安排考官组卷的eid：</p><script type="math/tex; mode=display">\pi_{eid}(eeexam)-\pi_{eid}(erexam)</script><p>笛卡尔积运算：结果关系的模式是参与运算的两个关系的模式的串接。运算符左侧关系中的每一个元组与右侧关系的每一个元组拼接，形成结果关系中的一个元组。<br>⚠️ 元组的拼接<br>更名：对给定的关系代数表达式E，表达式 $\rho_X(E)$ 返回表达式E的结果，并把名字X赋给了它。<br>如果关系代数表达式E是n元的，则表达式 $\rho_{X(A_1,A_2,…,A_n)}(E)$ 返回表达式E的结果，并赋给它名字X，同时将E的各属性更名为 $A_1,A_2,…,A_n$。<br>关系运算的运算参数是关系，运算结果也是关系。<br>查询历史学院的考生的姓名：</p><script type="math/tex; mode=display">\sigma_{name}(\pi_{department=history}(contestants))</script><p>关系代数基本运算是完备的，足以表达任何普通的关系代数查询。但是许多查询的表达式复杂、冗长，因此定义附加运算，简化一些查询的表达。<br>常见的附加运算有：集合交、自然联接、属性联接、条件联接和赋值运算。</p><p>集合交：集合交运算的结果是由那些同时在参与运算关系中存在的元组组成，只能在相容的关系间进行，用 $\bigcap$ 表示。</p><p>自然联接：可以将特定选择运算和笛卡尔积合并为一个运算。首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的<strong>所有</strong>同名属性进行属性值相等的选择运算，最后去掉重复列。也就是结果关系模式中相同的属性只保留一列，因为在任何元组中同名属性的值都是相等的。</p><p>例如：</p><p>examinee表：</p><div class="table-container"><table><thead><tr><th>eeid</th><th>eename</th><th>dname</th></tr></thead><tbody><tr><td>123</td><td>A</td><td>历史</td></tr><tr><td>234</td><td>B</td><td>心理</td></tr><tr><td>345</td><td>C</td><td>教育</td></tr></tbody></table></div><p>department表：</p><div class="table-container"><table><thead><tr><th>dname</th><th>dloca</th><th>dtele</th></tr></thead><tbody><tr><td>历史</td><td>46-A</td><td>444</td></tr><tr><td>教育</td><td>45-B</td><td>555</td></tr><tr><td>心理</td><td>44-C</td><td>666</td></tr></tbody></table></div><p>先算笛卡尔积：</p><div class="table-container"><table><thead><tr><th>examinee.eeid</th><th>examinee.eename</th><th>examinee.dname</th><th>department.dname</th><th>department.dloca</th><th>department.dtele</th></tr></thead><tbody><tr><td>123</td><td>A</td><td>历史</td><td>历史</td><td>46-A</td><td>444</td></tr><tr><td>123</td><td>A</td><td>历史</td><td>教育</td><td>45-B</td><td>555</td></tr><tr><td>123</td><td>A</td><td>历史</td><td>心理</td><td>44-C</td><td>666</td></tr><tr><td>234</td><td>B</td><td>心理</td><td>历史</td><td>46-A</td><td>444</td></tr><tr><td>234</td><td>B</td><td>心理</td><td>教育</td><td>45-B</td><td>555</td></tr><tr><td>234</td><td>B</td><td>心理</td><td>心理</td><td>44-C</td><td>666</td></tr><tr><td>345</td><td>C</td><td>教育</td><td>历史</td><td>46-A</td><td>444</td></tr><tr><td>345</td><td>C</td><td>教育</td><td>教育</td><td>45-B</td><td>555</td></tr><tr><td>345</td><td>C</td><td>教育</td><td>心理</td><td>44-C</td><td>666</td></tr></tbody></table></div><p>选择examinee.dname和department.dname相同的元组，最终选出了3组，将examinee.dname和department.dname属性合并后，成为了结果关系。</p><p>属性联接：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的<strong>指定</strong>同名属性进行属性值相等的选择运算，最后去掉重复列。指定同名属性只保留一个。</p><p>自然联接用 $S1 \infty S2$ 表示，属性联接用 $S1 \infty_{attribute} S2$ 表示。<br>例如指定了属性name，那么联接时就只看S1.name和S2.name相等的元组。<br>因此区别就是，当参与联接运算的两个表有多个<strong>同名列</strong>时，自然联接的匹配条件是所有同名列全部取值相等，而属性联接的匹配条件是指定其中的某些同名列取值相等。<br>赋值：赋值运算是将 $\leftarrow$ 右侧的表达式结果赋给其左侧的关系变量，该关系变量可以在后续的表达式中使用。<br>例如：从A中去除属性X</p><script type="math/tex; mode=display">A\leftarrow A-\sigma_{att1=x}(A)</script><p>关系代数运算的进一步扩充：<br>广义投影：允许将算术运算作为投影的一部分<br>聚集：例如计算给定集合元素的总和、平均值等<br>外联接：使得关系代数表达式可以处理缺失信息</p><p>广义投影：允许在投影列表中使用算术表达式。<br>例如 $\pi_{F_1,F_2,…,F_n}(E)$ 中，E是任意关系代数表达式，$F_1,F_2,…,F_n$ 中的每一个都是涉及E的属性的算术表达式，也可以仅仅是单个属性或常量。<br>广义投影的结果是对关系表达式t的每一行分别计算 $F_1,F_2,…,F_n$，<br>聚集函数：sum, avg, count, max, min等。<br>例如：</p><script type="math/tex; mode=display">G_{avg(erage)}(examiner)</script><p>查询结果只包含一个元组，只有单个属性。<br>还可以这样：</p><script type="math/tex; mode=display">_{dname}G_{avg(erage)}(examiner)</script><p>意思是说对元组按dname进行分组。</p><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用系统可能希望在结果中保留悬浮元组，这就有了外联接运算。<br>不考虑悬浮元组的自然联接、属性联接和条件联接都属于内联接。<br>外联接：首先计算内联接，然后加入左侧关系、右侧关系、两侧关系中的悬浮元组，对应称为左外联接(L)、右外联接(R)、全外联接(F)。表示方法：$\infty^R$.</p><h1 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h1><p>实体用方框表示。</p><p>联系用菱形表示。</p><p>实体和实体集统称实体。</p><p>实体通常使用属性来描述。同类实体通常使用相同的属性组来描述。</p><p>属性可能取值的范围成为属性域</p><p>现实生活中经常需要区分同类实体集中一个个不同的实体。例如在考生实体集中，由于可能出现同名同姓的考生，所以用考号来区分。</p><p>能够并且用以区分一个实体集中不同实体的最小属性集称为标识符或主键，组成主键的属性称为标识属性。</p><p>属性用椭圆表示。</p><p><strong>联系也有属性！</strong></p><p><strong>用线段将属性与其相对应的联系或实体连接起来。</strong></p><p><strong>并在那些用于标识实体或联系的属性下面加上下划线</strong></p><h1 id="2021-5-16-add"><a href="#2021-5-16-add" class="headerlink" title="2021/5/16 add"></a>2021/5/16 add</h1><h2 id="候选码-candidate-key-候选键"><a href="#候选码-candidate-key-候选键" class="headerlink" title="候选码(candidate key) / 候选键"></a>候选码(candidate key) / 候选键</h2><p>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。</p><p>关系中可以有多组候选码，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Student</span><span class="params">(S#, Sname, Sage, Sclass, Saddress)</span></span></span><br></pre></td></tr></table></figure><p>S#是候选码，(Sname, Saddress)也是候选码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Employee</span><span class="params">(EmpID, EmpName, MobileNumber)</span></span></span><br></pre></td></tr></table></figure><p>EmpID是候选码，MobileNumber也是候选码。</p><h2 id="主码-primary-key-主键"><a href="#主码-primary-key-主键" class="headerlink" title="主码(primary key) / 主键"></a>主码(primary key) / 主键</h2><p>当有多个候选码时，可以选定一个作为主码。</p><p>DBMS以主码为主要线索管理关系中的各个元组。</p><p>例如可以选定属性 S# 作为 Student 表的主码，也可以选定属性组 (Sname, Saddress) 作为 Student 表的主码。</p><h2 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h2><p>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性。</p><p>最简单的，候选码只包含一个属性。</p><p>最极端的，所有属性构成这个关系的候选码，称为全码(all-key)。</p><h2 id="外码-foreign-key-外键"><a href="#外码-foreign-key-外键" class="headerlink" title="外码(foreign key) / 外键"></a>外码(foreign key) / 外键</h2><p>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的<strong>候选码</strong>相对应，则称这个属性组为R的外码或外键。</p><p>例如”合同”关系中的”客户号”不是候选码，但却是外码，因为它与”客户”关系中的候选码”客户号”相对应。</p><p>两个关系是通过<strong>外键</strong>连接起来的。</p><h2 id="关系模型的完整性"><a href="#关系模型的完整性" class="headerlink" title="关系模型的完整性"></a>关系模型的完整性</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>关系的主码中的属性值不能为空值。</p><p>空值：不知道或无意义的值。</p><p>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不允许的。</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2中某个元组的Pk值，或者为空值。</p><p>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在。</p><h2 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h2><p>用户针对具体的应用环境定义的完整性约束条件。</p><p>例如，S# 要求是10位整数，性别只能是男或女，年龄只能在12到35岁之间。</p><h2 id="DBMS对关系完整性的支持"><a href="#DBMS对关系完整性的支持" class="headerlink" title="DBMS对关系完整性的支持"></a>DBMS对关系完整性的支持</h2><p>实体完整性和参照完整性由DBMS系统自动支持。</p><p>DBMS系统通常提供了如下机制：</p><ul><li>它使用户可以自行定义有关的完整性约束条件</li><li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性。</li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="并相容性"><a href="#并相容性" class="headerlink" title="并相容性"></a>并相容性</h3><p>某些关系代数操作，如并、差、交等，需要满足”并相容性”。</p><p>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性。</p><p>定义：关系R与关系S存在相容性，当且仅当：</p><ol><li>关系R和关系S的属性数目必须相同；</li><li>对于任意 i，关系R的第 i 个属性的域必须和关系S的第 i 个属性的域相同。</li></ol><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student(SID char(<span class="number">10</span>), Sname char(<span class="number">8</span>), Age char(<span class="number">3</span>))</span><br><span class="line">Professor(PID char(<span class="number">10</span>), Pname char(<span class="number">8</span>), Age char(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="并操作-Union"><a href="#并操作-Union" class="headerlink" title="并操作(Union)"></a>并操作(Union)</h3><p>定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：$R \cup S$，它由或者出现在关系R中，或者出现在S中的元组构成。</p><p>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</p><h3 id="theta-join"><a href="#theta-join" class="headerlink" title="theta-join"></a>theta-join</h3><p>投影与选择操作只是对单个关系（表）进行操作，而实际应用中往往涉及多个表之间的操作，这就需要theta-连接操作。</p><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p>数据库完整性(DB Integrity)是指DBMS应保证的DB的一种特性——在任何情况下的正确性、有效性和一致性。</p><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是指向某检索记录集的指针。</p><p>通过这个指针的移动，每次读一行处理一行，直至处理完毕。</p><p><strong>第一范式 1NF</strong></p><p>若关系模式R(U)中关系的每个分量都是不可分的数据项，则称R(U)属于第一范式.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>(<span class="params">street</span>, <span class="params">city</span>)</span>)</span><br></pre></td></tr></table></figure><p>Star不属于1NF，因为属性address仍包含了street, city两个属性，其分量不是原子。</p><p><strong>不符合1NF的处理</strong></p><p>将非1NF转换为1NF：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>(<span class="params">street</span>, <span class="params">city</span>)</span>)</span><br><span class="line">转换为：</span><br><span class="line"><span class="constructor">Star(<span class="params">name</span>, <span class="params">street</span>, <span class="params">city</span>)</span>或<span class="constructor">Star(<span class="params">name</span>, <span class="params">address</span>)</span></span><br></pre></td></tr></table></figure><p><strong>第二范式 2NF</strong></p><p>若R(U)是1NF且U中的每一非主属性完全函数依赖于候选键，则称R(U)属于第二范式。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R(S#, <span class="meta">SN</span>, SD, <span class="meta">CN</span>, G)</span><br><span class="line">其中，S#是学号，<span class="meta">SN</span>是姓名，SD是班级，<span class="meta">CN</span>是课程，G是成绩，</span><br><span class="line">函数依赖：S#-&gt;<span class="meta">SN</span>, S#-&gt;SD, (S#, CD)-&gt;G</span><br><span class="line">候选键包含(S#, <span class="meta">CN</span>)</span><br><span class="line">非主属性包含<span class="meta">SN</span>和SD</span><br><span class="line">因为(S#, <span class="meta">CN</span>) -P-&gt; (<span class="meta">SN</span>, SD)，所以R不属于<span class="number">2</span>NF。</span><br><span class="line">将其分解为<span class="built_in">R1</span>(S#, <span class="meta">SN</span>, SD), <span class="built_in">R2</span>(S#, <span class="meta">CN</span>, G)，则<span class="built_in">R1</span>和<span class="built_in">R2</span>都属于<span class="number">2</span>NF。</span><br></pre></td></tr></table></figure><p>第二范式消除了非主属性对候选键的部分依赖。</p><p><strong>第三范式 3NF</strong></p><p>第三范式是确保每列都和主键列直接相关，而不是间接相关，即限制列的冗余性。 如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。</p><p>第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。</p><p><a href="https://baike.baidu.com/item/关系模式">关系模式</a>R 中若不存在这样的码X、属性组Y及非主属性Z（Z (强制依赖)Y），使得X→Y，Y→Z，成立，Y→X不成立，则称R ∈ 3NF。</p><p>若R∈3NF，则R的每一个非主属性既不<a href="https://baike.baidu.com/item/部分函数依赖">部分函数依赖</a>于候选码也不<a href="https://baike.baidu.com/item/传递函数依赖">传递函数依赖</a>于候选码。</p><p>如果R∈3NF，则R也是2NF。</p><p>采用投影分解法将一个2NF的关系分解为多个3NF的关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。</p><p>将一个2NF关系分解为多个3NF的关系后，并不能完全消除<a href="https://baike.baidu.com/item/关系模式">关系模式</a>中的各种异常情况和数据冗余。</p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h2><p><code>SELECT INTO</code>语句从一个表中选取数据，然后把数据插入另一个表中。</p><p>常用于创建表的备份复件或者用于对记录进行存档。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] <span class="keyword">FROM</span> old_database</span><br></pre></td></tr></table></figure><p>或者只把需要的列插入新表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase]</span><br><span class="line"><span class="keyword">FROM</span> old_table_name</span><br></pre></td></tr></table></figure><h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO INCREMENT"></a>AUTO INCREMENT</h2><p><code>AUTO INCREMENT</code>（自动增长）语句会在新纪录插入表时生成一个唯一的数字。PostgreSQL使用序列来标识字段的自增长，数据类型有smallserial, serial和bigserial。</p><p>使用<code>AUTO INCREMENT</code>的原因：我们通常希望在每次插入新纪录时，自动地创建主键字段的值。因此我们可以在表中创建一个<code>AUTO INCREMENT</code>字段。</p><div class="table-container"><table><thead><tr><th style="text-align:left">伪类型</th><th style="text-align:left">存储大小</th><th style="text-align:left">范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>SMALLSERIAL</code></td><td style="text-align:left">2字节</td><td style="text-align:left">1 到 32,767</td></tr><tr><td style="text-align:left"><code>SERIAL</code></td><td style="text-align:left">4字节</td><td style="text-align:left">1 到 2,147,483,647</td></tr><tr><td style="text-align:left"><code>BIGSERIAL</code></td><td style="text-align:left">8字节</td><td style="text-align:left">1 到 922,337,2036,854,775,807</td></tr></tbody></table></div><p>SERIAL数据类型的基础语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">colName SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假定我们要创建一张 COMPANY 表，并创建下面几个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runoobdb<span class="operator">=</span># <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID  SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   NAME           TEXT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在往表中插入几条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Paul&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">20000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Allen&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="number">15000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Teddy&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Norway&#x27;</span>, <span class="number">20000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Mark&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Rich-Mond &#x27;</span>, <span class="number">65000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;David&#x27;</span>, <span class="number">27</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="number">85000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;Kim&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;South-Hall&#x27;</span>, <span class="number">45000.00</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> COMPANY (NAME,AGE,ADDRESS,SALARY)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Houston&#x27;</span>, <span class="number">10000.00</span> );</span><br></pre></td></tr></table></figure><p>查看 COMPANY 表的记录如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> id | <span class="type">name</span>  | <span class="type">age</span> | <span class="type">address</span>    | <span class="type">salary</span></span><br><span class="line">----+-------+-----+------------+--------</span><br><span class="line">  <span class="number">1</span> | <span class="type">Paul</span>  |  <span class="type">32</span> | <span class="type">California</span> |  <span class="type">20000</span></span><br><span class="line">  <span class="number">2</span> | <span class="type">Allen</span> |  <span class="type">25</span> | <span class="type">Texas</span>      |  <span class="type">15000</span></span><br><span class="line">  <span class="number">3</span> | <span class="type">Teddy</span> |  <span class="type">23</span> | <span class="type">Norway</span>     |  <span class="type">20000</span></span><br><span class="line">  <span class="number">4</span> | <span class="type">Mark</span>  |  <span class="type">25</span> | <span class="type">Rich</span>-Mond  |  <span class="type">65000</span></span><br><span class="line">  <span class="number">5</span> | <span class="type">David</span> |  <span class="type">27</span> | <span class="type">Texas</span>      |  <span class="type">85000</span></span><br><span class="line">  <span class="number">6</span> | <span class="type">Kim</span>   |  <span class="type">22</span> | <span class="type">South</span>-Hall |  <span class="type">45000</span></span><br><span class="line">  <span class="number">7</span> | <span class="type">James</span> |  <span class="type">24</span> | <span class="type">Houston</span>    |  <span class="type">10000</span></span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种由事件自动触发执行的特殊存储过程，这些事件可以是对一个表进行 INSERT、UPDATE、DELETE 等操作。</p><p>触发器经常用于加强数据的完整性约束和业务规则上的约束等。</p><p>在SQL内部把触发器看作是存储过程但是不能传递参数。一般的存储过程通过存储过程名称被直接调用，而触发器主要是通过事件进行触发而被执行。</p><p>在SQL Server里就是对一个表的一定操作触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。</p><ul><li><p>SQL Server为每个触发器都创建了两个专用表﹕Inserted表和Deleted表。这两个表由系统来维护，它们存在于内存中而不是在数据库中。这两个表的结构总是与被该触发器作用的表的结构相同。触发器执行完成后，与该触发器相关的这两个表也被删除。 Deleted表存放由于执行Delete或Update语句而要从表中删除的所有行。 Inserted表存放由于执行Insert或Update语句而要向表中插入的所有行。</p></li><li><p>SQL Server提供了两种触发器：Instead of和After触发器。</p><p>这两种触发器的差别在于它们</p><ul><li>Instead of触发器用于替代引起触发器执行的T-SQL语句。除表之外，Instead of触发器也可以用于视图，用来扩展视图可以支持的更新操作。</li><li>After触发器在一个INSERT, UPDATE或DELETE语句之后执行，约束检查等动作都在After触发器被激活之前发生。After触发器只能用于表。一个表或视图的每一个修改动作(insert,update和delete)都可以有一个instead of 触发器，一个表的每个修改动作都可以有多个After触发器。</li></ul></li><li><p>触发器的执行过程：如果一个INSERT, UPDATE或DELETE语句违反了约束，那么After触发器不会执行，因为对约束的检查是在After触发器被激活之前发生的。所以After触发器不能超越约束。</p></li><li>Instead of 触发器可以取代激发它的操作来执行。它在Inserted表和Deleted表刚刚建立、其它任何操作还没有发生时被执行。因为Instead of 触发器在约束之前执行，所以它可以对约束进行一些预处理。</li></ul><p><strong>触发器创建语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">CONSTRAINT</span> ] <span class="keyword">TRIGGER</span> name</span><br><span class="line">&#123; BEFORE | AFTER | INSTEAD OF &#125; &#123; event [ OR ... ]&#125;</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line">[ FROM referenced_table_name ]&#123; NOT DEFERRABLE | [ DEFEREABLE ] &#123; IINITIALLY IMMEDIATE | INITIALLY DEFERED&#125; &#125;</span><br><span class="line">FOR [ EACH ] &#123; ROW | STATEMENT &#125;</span><br><span class="line">[ WHEN &#123; condition &#125;]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name ( arguments )</span><br></pre></td></tr></table></figure><h1 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h1><p>The general process of assuring that transactions preserve consistency when executing simultaneously is called <em>concurrency control</em>.</p><blockquote><p>The scheduler takes read/write requests from transactions and either executes them in buffers or delays them.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关系模型&quot;&gt;&lt;a href=&quot;#关系模型&quot; class=&quot;headerlink&quot; title=&quot;关系模型&quot;&gt;&lt;/a&gt;关系模型&lt;/h1&gt;&lt;p&gt;关系数据库使用一个或多个表来存储数据。&lt;br&gt;数学上把一系列域上的笛卡尔积的子集称为关系。&lt;/p&gt;
&lt;p&gt;软件系统无法保证数</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Database" scheme="https://preccrep.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog</title>
    <link href="https://preccrep.github.io/2021/04/01/SystemVerilog/"/>
    <id>https://preccrep.github.io/2021/04/01/SystemVerilog/</id>
    <published>2021-04-01T12:01:54.000Z</published>
    <updated>2021-04-03T03:43:21.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于SystemVerilog的测试程序"><a href="#基于SystemVerilog的测试程序" class="headerlink" title="基于SystemVerilog的测试程序"></a>基于SystemVerilog的测试程序</h1><p>电路验证是确认所设计的电路功能正确性的过程，而仿真(simulation)是进行电路验证的主要手段，它可以及早发现所存在的设计问题，降低设计风险，节约设计成本。通常，仿真是通过编写测试程序(testbench)完成的。</p><p>测试程序也称为测试台，它是用于测试待测模块(Device Under Test, DUT)功能是否正确的一段SystemVerilog HDL代码，是不可综合的，由激励信号、DUT和输出响应三部分组成。</p><p>待测模块DUT：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line">                     <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">assign</span> y= ~b &amp; ~c | a &amp; ~b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>测试程序示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns          //预编译指令，定义时间单位和时间精度</span></span><br><span class="line"><span class="keyword">module</span> sillyfunction_tb();  <span class="comment">//测试程序没有输入/输出端口</span></span><br><span class="line">  <span class="keyword">logic</span> a, b, c, y;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.c</span>(c), <span class="variable">.y</span>(y)); <span class="comment">//实例化待测模块</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span>   <span class="comment">//给出激励信号</span></span><br><span class="line">    a = <span class="number">0</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;   <span class="comment">//000</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//001</span></span><br><span class="line">    b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;          <span class="comment">//010</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//011</span></span><br><span class="line">    a = <span class="number">1</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;   <span class="comment">//100</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">10</span>;                 <span class="comment">//101</span></span><br><span class="line">    b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;          <span class="comment">//110</span></span><br><span class="line">    c = <span class="number">1</span>; #<span class="number">50</span>;                 <span class="comment">//111</span></span><br><span class="line">    <span class="built_in">$finish</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span>    <span class="comment">//输出结果，否则只产生波形</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a = %b, b = %b, c = %b, y = %b&quot;</span>, a, b, c, y);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1 id="10-表示延迟10个时间单位，-monitor-time表示系统任务，"><a href="#10-表示延迟10个时间单位，-monitor-time表示系统任务，" class="headerlink" title="10 表示延迟10个时间单位，$monitor, $time表示系统任务，"></a>10 表示延迟10个时间单位，$monitor, $time表示系统任务，</h1><p>测试程序的模板如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> testbench_name();  <span class="comment">//testbench为顶层模块，不会被其他模块实例化，因此不需要任何端口</span></span><br><span class="line">  <span class="comment">//信号定义</span></span><br><span class="line">  <span class="comment">//模块实例化</span></span><br><span class="line">  <span class="comment">//添加激励信号</span></span><br><span class="line">  <span class="comment">//显示输出结果（可以不添加任何显示打印语句，只生成波形图即可）</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>在SystemVerilog中，施加激励就是向DUT添加输入信号（即测试向量），主要有三种方法：</p><ol><li>通过initial过程块施加（线性）激励；</li><li>通过always过程块施加（循环）激励，主要用于产生时钟信号；</li><li>通过文件施加激励。</li></ol><h2 id="通过initial过程块施加激励"><a href="#通过initial过程块施加激励" class="headerlink" title="通过initial过程块施加激励"></a>通过initial过程块施加激励</h2><p>在initial块中施加激励，每个仿真时刻只用列出<strong>值需要改变的信号</strong>。initial块只执行一次。</p><p>在一个测试程序中可以包含多个initial块，并且它们都是<strong>同时并行执行</strong>，因此需要特别注意，不要在多个initial块中，在同一个仿真时刻对同一个信号赋值，否则将产生冲突。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//时刻0发生赋值</span></span><br><span class="line">  data_bus = <span class="number">8&#x27;h00</span>; addr = <span class="number">8&#x27;h3f</span>;</span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>; <span class="comment">//时刻10发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  #<span class="number">15</span> data_bus = <span class="number">8&#x27;hff</span>; <span class="comment">//时刻15发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//时刻0发生赋值</span></span><br><span class="line">  data_bus = <span class="number">8&#x27;h00</span>; addr = <span class="number">8&#x27;h3f</span>;</span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;h45</span>; <span class="comment">//时刻10发生赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  #<span class="number">10</span> data_bus = <span class="number">8&#x27;hff</span>; <span class="comment">//错误，发送冲突</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="通过文件施加激励"><a href="#通过文件施加激励" class="headerlink" title="通过文件施加激励"></a>通过文件施加激励</h2><p>将激励（测试向量）存放在一个文本文件中，测试程序从文件中读取激励，对DUT进行测试。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction_tb();</span><br><span class="line">  <span class="keyword">logic</span> a,b,c,y;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] stim [<span class="number">7</span>:<span class="number">0</span>];  <span class="comment">//声明一个logic类型的数组stim</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a),<span class="variable">.b</span>(b),<span class="variable">.c</span>(c),<span class="variable">.y</span>(y));</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;testvector.txt&quot;</span>,stim); <span class="comment">//将所有激励读入数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      &#123;a,b,c&#125;=stim[i]; #<span class="number">10</span>;  <span class="comment">//依次测试各个激励</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a = %b, b = %b, c = %b, y = %b&quot;</span>, a, b, c, y);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testvector.txt</span><br><span class="line"><span class="number">000</span></span><br><span class="line"><span class="number">001</span></span><br><span class="line"><span class="number">010</span></span><br><span class="line"><span class="number">011</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure><h2 id="输出响应"><a href="#输出响应" class="headerlink" title="输出响应"></a>输出响应</h2><p>在SystemVerilog中，输出响应是指在向DUT的输入端施加激励后，通过观察DUT输出的结果，并与预期结果进行比较，以验证电路功能是否正确。这一过程可通过观测波形图或借助SystemVerilog HDL提供的一系列<strong>系统任务</strong>显示输出结果来实现。</p><p>SystemVerilog HDL中常用的系统任务包括：</p><p>获取仿真时间：$time</p><p>显示信号值：$display, $monitor</p><p>结束/中断仿真：$finish, $stop</p><p>文件输入：$readmemb, $readmmemh</p><p>文件输出：$fopen, $fclose, $fdisplay, $fmonitor</p><h3 id="获取仿真时间"><a href="#获取仿真时间" class="headerlink" title="获取仿真时间"></a>获取仿真时间</h3><p>获取仿真时间的系统任务的返回值使用由<code>`timescale</code>定义的时间单位。如：</p><p><code>`timescale 1ns/1ps</code></p><p><code>`timescale 1ns/1ns</code></p><p>$time返回一个64位的整数时间值</p><p>$stime返回一个32位的整数时间值</p><p>$realtime返回一个实数时间值</p><p>如：<code>$monitor($time,&quot;a=%b b=%b c=%b y=%b&quot;,a,b,c,y)</code></p><h2 id="显示信号值"><a href="#显示信号值" class="headerlink" title="显示信号值"></a>显示信号值</h2><p>显示信号值的系统任务包括：$display和$monitor</p><p><code>$display($time,&quot;a=%b&quot;,a);</code></p><p><code>$monitor($time,&quot;a=%b&quot;,a);</code></p><p>$display和$monitor的区别在于前者只有执行到该语句时才会进行显示操作，而后者是一个监视器，只要输出变量列表中的某个变量发生变化，就执行一次显示操作。后者使用更方便。</p><div class="table-container"><table><thead><tr><th>%h</th><th>%o</th><th>%d</th><th>%b</th><th>%c</th><th>%s</th><th>%t</th><th>%m</th></tr></thead><tbody><tr><td>hexadecimal</td><td>octonary</td><td>decimal</td><td>binary</td><td>ASCII</td><td>字符串</td><td>时间</td><td>模块名</td></tr></tbody></table></div><h2 id="结束-中断仿真"><a href="#结束-中断仿真" class="headerlink" title="结束/中断仿真"></a>结束/中断仿真</h2><p>结束/中断仿真的系统任务包括：$finish和$stop，用于对仿真过程进行控制。</p><p>$finish;</p><p>$finish(n);</p><p>$stop;</p><p>$stop(n);</p><p>参数n可以取0, 1等值，”0”表示不输出任何信息，”1”表示给出仿真时间。</p><h2 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h2><p>在SystemVerilog HDL中文件输入不需要打开文件操作，直接读取文件即可，相关的系统任务包括：$readmemb和$readmemh，前者读取2进制数据，后者读取16进制数据。</p><p>$readmemb(“数据文件名”, 数组(存储器)名, &lt;起始地址&gt;, &lt;结束地址&gt;);<br>$readmemh(“数据文件名”, 数组(存储器)名, &lt;起始地址&gt;, &lt;结束地址&gt;);</p><p>起始地址和结束地址均可缺省。</p><p>文件格式：</p><ul><li><p>可用”_”提高数据可读性</p></li><li><p>可包含单行或多行注释</p></li><li><p>可用<strong>空格</strong>或<strong>换行</strong>来区分单个数据</p></li><li><p>可以设定一个特定地址，规定其后的数据从该地址开始存储，格式如下：</p><p><code>@hex_addr</code></p><p>地址必须是16进制，且大小写不敏感，并且@和地址之间不允许有空格。</p></li></ul><p>例如：</p><p><strong>testmem.txt:</strong></p><p>0000_0000<br>0110_0001 0011_0010<br>//地址3-255没有定义<br>@100     //hex, 256<br>1111_1100<br>//地址257-1022没有定义<br>@3FF<br>1100_0010</p><p><strong>数组stim:</strong><br>0    00000000<br>1    01100001<br>2    00110010<br>3<br>4<br>…<br>255<br>256    11111100<br>257<br>…<br>1022<br>1023    11000010</p><p><strong>code:</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] stim [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//$readmemb(&quot;testmem.txt&quot;,stim);</span></span><br><span class="line">  <span class="built_in">$readmemb</span>(<span class="string">&quot;testmem.txt&quot;</span>,stim,<span class="number">0</span>,<span class="number">1023</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>在SystemVerilog HDL中文件输出需要先打开文件，相应的系统任务为$fopen，然后可以通过系统任务$fdisplay或$fmonitor将需要保存的信息输入到指定文件中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MCD;</span><br><span class="line">MCD = <span class="built_in">$fopen</span>(<span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;操作模式&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(MCD, <span class="string">&quot;显示格式控制符&quot;</span>, &lt;输出变量(信号)列表&gt;);</span><br><span class="line"><span class="built_in">$fmonitor</span>(MCD, <span class="string">&quot;显示格式控制符&quot;</span>, &lt;输出变量(信号)列表&gt;);</span><br><span class="line"><span class="built_in">$fclose</span>(MCD);</span><br></pre></td></tr></table></figure><p>$fopen打开指定文件并返回一个32位整数，若打开失败，则返回0。操作模式为w, w+, a, a+.</p><p>$fclose关闭打开的文件。</p><p>$fdisplay和$fmonitor的用法与$display和$monitor的用法一致。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sillyfunction_tb();</span><br><span class="line">  <span class="keyword">logic</span> a,b,c,y,yexpected;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] stim [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  sillyfunction dut(<span class="variable">.a</span>(a),<span class="variable">.b</span>(b),<span class="variable">.c</span>(c),<span class="variable">.y</span>(y));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;at_vec.txt&quot;</span>,stim);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      &#123;a,b,c,yexpected&#125;=stim[i]; #<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(y==yexpected)</span><br><span class="line">        <span class="built_in">$display</span>(<span class="built_in">$time</span>,<span class="string">&quot;test pass!&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="built_in">$time</span>,<span class="string">&quot;Error: inputs=%b,%b,%b&quot;</span>,&#123;a,b,c&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at_vec.txt</span><br><span class="line"></span><br><span class="line">000_1</span><br><span class="line">001_0</span><br><span class="line">010_0</span><br><span class="line">...</span><br><span class="line">111_0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于SystemVerilog的测试程序&quot;&gt;&lt;a href=&quot;#基于SystemVerilog的测试程序&quot; class=&quot;headerlink&quot; title=&quot;基于SystemVerilog的测试程序&quot;&gt;&lt;/a&gt;基于SystemVerilog的测试程序&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="HDL" scheme="https://preccrep.github.io/categories/HDL/"/>
    
    
    <category term="SystemVerilog" scheme="https://preccrep.github.io/tags/SystemVerilog/"/>
    
  </entry>
  
  <entry>
    <title>pthread多线程编程</title>
    <link href="https://preccrep.github.io/2021/03/18/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://preccrep.github.io/2021/03/18/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-18T13:31:33.000Z</published>
    <updated>2021-03-18T16:26:07.105Z</updated>
    
    <content type="html"><![CDATA[<p>线程函数需要声明为<code>void*</code>类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The function to be executed by the thread should take a</span></span><br><span class="line"><span class="comment"> * void* parameter and return a void* exit status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Cast the parameter into what is needed.</span></span><br><span class="line">  <span class="keyword">int</span> *incoming=(<span class="keyword">int</span>*)arg;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Do whatever is necessary using *incoming as the argument.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The thread terminates when this function returns.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread_ID;</span><br><span class="line">  <span class="keyword">void</span> *exit_status;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Put something meaningful into value.</span></span><br><span class="line">  value=<span class="number">42</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create the thread, passing &amp;value for the argument.</span></span><br><span class="line">  pthread_create(&amp;thread_ID,<span class="literal">NULL</span>,thread_function,&amp;value);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The main program continues while the thread executes.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Wait for the thread to terminate.</span></span><br><span class="line">  pthread_join(thread_ID,&amp;exit_status);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Only the main thread is running now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要函数：</p><ol><li>Create a new thread</li></ol><p><code>pthread_create()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span> *tid,<span class="comment">//thread ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="comment">//thread attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*),<span class="comment">//pointer to function to execute</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *arg<span class="comment">//argument to function</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Return value: 0 if successful. Error code from <errno.h> otherwise.</p><p>Notes: Use a structure to pass multiple arguments to the start routine.</p><ol><li>Wait for a thread to terminate</li></ol><p><code>pthread_join</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span> tid,<span class="comment">//wait for a thread to terminate</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> **status;<span class="comment">//thread ID to wait for</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Return value: 0 for success. Error code from <errno.h> otherwise.</p><p>Notes: Once a thread is joined, the thread no longer exists, its thread ID is no longer valid, and it cannot be joined with any other thread.</p><ol><li>Get my own thread ID</li></ol><p><code>pthread_self</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Return value: The ID of the thread that called this function.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程函数需要声明为&lt;code&gt;void*&lt;/code&gt;类型。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    <category term="并行计算" scheme="https://preccrep.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="pthread" scheme="https://preccrep.github.io/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象</title>
    <link href="https://preccrep.github.io/2021/03/14/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://preccrep.github.io/2021/03/14/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-03-14T05:35:57.000Z</published>
    <updated>2021-03-15T14:56:44.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><p>静态变量被类中的所有对象共享。静态方法不能访问类中的实例成员。</p><p>如果想让一个类中的所有实例共享数据，就要使用<em>静态变量</em>（static variable），也称<em>类变量</em>（class variable）。静态变量将变量值存储在一个公共的内存地址。因为是公共的，所以如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受影响。</p><p>无需创建类的实例就可以调用<em>静态方法</em>（static method）。</p><p>要声明一个静态变量或定义一个静态方法，就需要中声明中加上修饰符static。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numberOfObjects;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumberOfObjects</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> numberOfObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Math类中所有的方法都是静态的。main方法也是静态方法。</p><p>类中的常量是被该类的所有对象所共享的。因此，常量应该声明为<code>final static</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> PI = <span class="number">3.1415</span>;</span><br></pre></td></tr></table></figure><p>实例方法可以调用实例方法和静态方法，访问实例数据域或静态数据域。静态方法只能调用静态方法和访问静态数据域。因为静态方法和静态数据域不属于某个特定的对象。</p><blockquote><p>一个常见的设计错误就是将一个本应该声明为静态的方法声明为实例方法。例如<code>factorial(int n)</code>应该定义为是静态的，因为它不依赖于任何具体的实例。</p></blockquote><h1 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h1><p>可见性修饰符可以用于确定一个类以及它的成员的可见性。</p><p>可以在类、方法和数据域前使用public修饰符，表示它们可以被任何其他的类访问。如果没有可见性修饰符，则默认类、方法和数据域是可以被同一个包中的任何一个类访问的。这称作<em>包私有</em>（package-private）或<em>包内访问</em>（package- access）。</p><blockquote><p>包可以用来组织类。用下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br></pre></td></tr></table></figure><p>如果定义时没有包，就表示把它放在默认包中。</p><p>Java建议最好把类放入包中，而不要使用默认包。</p></blockquote><p>private修饰符限定方法和数据域只能在它自己的类中被访问。</p><p><img src="/Users/preccrep/Desktop/x.png" alt="x"></p><p>如果一个类没有被定义为公共类，则它只能在同一个包内被访问。</p><h1 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h1><blockquote><p>可以定义不可变类来产生不可变对象。不可变对象的内容不能被改变。</p></blockquote><p>通常创建一个对象后，它的内容是允许之后改变的。有时候也需要创建一个一旦创建其内容就不能再改变的对象。我们称这种对象为一个<em>不可变对象</em>（immutable object），而它的类就是<em>不可变类</em>（immutable class）。例如，String类就是不可变的。如果把set方法去掉，也可能变为不可变类。</p><p>如果一个类是不可变的，那么它的所有数据域必须都是私有的，而且没有对任何一个数据域提供公共的set方法。但是这只是充分条件。反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> java.util.Date dateCreated;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> ssn, String newName)</span></span>&#123;</span><br><span class="line">    id=ssn;</span><br><span class="line">    name=newName;</span><br><span class="line">    dateCreated=<span class="keyword">new</span> java.util.Date();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getDateCreated</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dateCreated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDateCreated方法返回的是一个引用。通过这个引用可以改变getDateCreated的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Student student=<span class="keyword">new</span> Student(<span class="number">111222333</span>,<span class="string">&quot;Mika&quot;</span>);</span><br><span class="line">    java.util.Date dateCreated=student.getDateCreated();</span><br><span class="line">    dateCreated.setTime(<span class="number">200000</span>); <span class="comment">//Now dateCreated field is changed!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p><strong>实例变量和静态变量的作用域是整个类，无论变量是在哪里声明的。</strong></p><p>一个类的实例变量和静态变量称为<em>类变量</em>（class’s variables）或<em>数据域</em>（data field）。在方法内部定义的变量是局部变量。</p><p>类变量只能声明一次，但是在一个方法内不同的非嵌套块中，可以多次声明相同的变量名。</p><p>如果一个局部变量和一个类变量具有相同的名字，那么局部变量优先，而同名的类变量被隐藏。</p><h1 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h1><p>关键字this引用对象自身。它也可以在构造方法内部用于调用同一个类的其他构造方法。</p><p><strong>关键字this是指向调用对象本身的引用名。</strong>可以用this关键字引用对象的实例成员。</p><p>在引用隐藏数据域（例如set方法将数据域名作为参数名）以及调用一个重载的构造方法的时候，this引用是必须的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius=radius; <span class="comment">//关键字this可以用于引用隐藏数据域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">1.0</span>); <span class="comment">//关键字this可以用于调用同一个类的另一个构造方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p>面向对象编程允许从已经存在的类中定义新的类，这称为继承。</p><p>继承能够避免冗余并使系统更易于理解和易于维护。</p><h2 id="父类和子类"><a href="#父类和子类" class="headerlink" title="父类和子类"></a>父类和子类</h2><p>如果类C1扩展自另一个类C2，那么称C1为<em>次类</em>（subclass），C2为<em>超类</em>（superclass）。超类也称<em>父类</em>（parent class）或<em>基类</em>（base class），次类又称<em>子类</em>（child class）、<em>扩展类</em>（extended class）或<em>派生类</em>（derived class）。子类从它的父类中继承可访问的数据域或方法，还可添加新数据域和新方法。</p><p>父类中的私有数据域是不能被子类访问的，但是可以用get和set方法。</p><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>一个Java类只可能直接继承自一个父类，这种限制称为单一继承（single inheritence）。如果使用extends关键字来定义一个子类，它只允许有一个父类。然而，多重继承是可以直接通过接口来实现的。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>关键字super指代父类，可以用于调用父类中的普通方法和构造方法。</p><h3 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h3><p>构造方法用于构建一个类的实例。不同于属性和普通方法，父类的构造方法不会被子类继承。它们只能使用关键字super从子类的构造方法中调用。</p><p>调用父类构造方法的语法是：<code>super 或 super(parameters)</code></p><p>语句<code>super()</code>调用父类的无参构造方法，而语句<code>super(arguments)</code>调用与参数匹配的父类的构造方法。它们必须出现在子类构造方法的第一行，这是显示调用父类构造方法的唯一方式。在子类中调用父类构造方法的名字会引起一个语法错误。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleFromSimpleGeometricObject</span><span class="params">(<span class="keyword">double</span> radius,String color,<span class="keyword">boolean</span> filled)</span></span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(color,filled);</span><br><span class="line">  <span class="keyword">this</span>.radius=radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleFromSimple</span><span class="params">(<span class="keyword">double</span> radius,String color, <span class="keyword">boolean</span> filled)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius=radius;</span><br><span class="line">setColor(color);</span><br><span class="line">setFilled(filled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法链（IMPORTANT 354 355）</strong></p><h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><p>语法是：<code>super.methodName(parameters)</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="keyword">super</span>.getDateCreated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>要重写一个方法，需要在子类中使用和父类一样的签名以及一样的返回值类型来对该方法进行定义。</p><p>子类从父类中继承方法，有时子类需要修改父类中定义的方法的实现，这称作<strong>方法重写</strong>（method overriding）。</p><p>例如GeometricObject类中的toString方法返回表示几何对象的字符串。这个方法可以被重写，返回表示圆的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="comment">//toString is originally defined in Father</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">&quot;\nradius is &quot;</span>+radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son使用super.toString()访问Father中的toString方法，但是GrandSon不能使用super.super.toString()访问Father中的toString方法。这是一个语法错误。</p><blockquote><p><strong>值得注意的是：</strong></p><p>仅当实例方法是可访问时，它才可被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法是父类中私有的，那么这两个方法完全没有关系。</p><p>与实例方法一样，静态方法也能被继承。但是静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法名（SuperClassName.staticMethodName）调用隐藏的静态方法。</p></blockquote><p>重载意味着使用同样的名字但是不同的签名来定义多个方法。</p><p>重写意味着在子类中提供一个对方法的新的实现。</p><ul><li>方法重写发生在通过继承而相关的不同类中；方法重载可以发生在同一个类中，也可以发生在由于继承而相关的不同类中。</li><li>方法重写具有相同的签名和返回值类型；方法重载具有相同的名字，但是不同的参数列表。</li></ul><p>为了避免错误，可以使用一个特殊的Java语法，成为重写标注（override annotation），在子类的方法前面放一个@Override。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="comment">//toString is originally defined in Father</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">&quot;\nradius is &quot;</span>+radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该标注表示被标注的方法必须重写父类的一个方法。如果具有该标注的方法没有重写父类的方法，编译器将会报错。</p><h1 id="Object类及其toString-方法"><a href="#Object类及其toString-方法" class="headerlink" title="Object类及其toString()方法"></a>Object类及其toString()方法</h1><p>Java中的所有类都继承自<code>java.lang.Object</code>类。</p><p>如果在定义一个类时没有指定继承性，那么这个类的父类就被默认为是Object。例如下面两个类的定义是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString()方法的签名是：<code>public String toString()</code></p><p>默认情况下，它返回一个由该对象所属的类名、@符号以及该对象十六进制形式的内存地址组成的字符串。但是通常这个结果没什么用。所以考虑重写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;created on &quot;</span>+dateCreated+<span class="string">&quot;\ncolor: &quot;</span>+color+<span class="string">&quot; and filled: &quot;</span>+filled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object hahaha=<span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hahaha); <span class="comment">//或System.out.println(hahaha.toString());</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：java.lang.Object@dcf3e99</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态意味着父类的变量可以指向子类对象。</p><p>首先定义两个属于：子类型和父类型。一个类实际上定义了一种类型，子类定义的类型称为子类型（subtype），父类定义的称为父类型（supertype）。</p><p>继承关系使一个子类继承父类的特征，并且附加一些新特征。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态变量&quot;&gt;&lt;a href=&quot;#静态变量&quot; class=&quot;headerlink&quot; title=&quot;静态变量&quot;&gt;&lt;/a&gt;静态变量&lt;/h1&gt;&lt;p&gt;静态变量被类中的所有对象共享。静态方法不能访问类中的实例成员。&lt;/p&gt;
&lt;p&gt;如果想让一个类中的所有实例共享数据，就要使用&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://preccrep.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="https://preccrep.github.io/2021/03/07/Java%E7%AC%94%E8%AE%B0/"/>
    <id>https://preccrep.github.io/2021/03/07/Java%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-07T02:25:31.000Z</published>
    <updated>2021-03-07T02:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>初学Java，有些东西需要记录一下。</p></blockquote><h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><p>Java的方法只能传值，不能传引用，但是可以用对象来解决这个问题。</p><p>例如swap函数：</p><p>方案1：构造一个新类MyInteger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwapTwoNumbers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyInteger</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(MyInteger a, MyInteger b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a.getValue();</span><br><span class="line">        a.changeValue(b.getValue());</span><br><span class="line">        b.changeValue(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyInteger a = <span class="keyword">new</span> MyInteger(<span class="number">4</span>);</span><br><span class="line">        MyInteger b = <span class="keyword">new</span> MyInteger(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a is &quot;</span>+a.getValue()+<span class="string">&quot; and b is &quot;</span>+b.getValue());</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a is &quot;</span>+a.getValue()+<span class="string">&quot; and b is &quot;</span>+b.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2：利用main所在的类本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t1</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">t1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">t1 x = <span class="keyword">new</span> t1(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;a is &quot;</span>+x.a+<span class="string">&quot; and b is &quot;</span>+x.b);</span><br><span class="line">x.swap();</span><br><span class="line">System.out.println(<span class="string">&quot;a is &quot;</span>+x.a+<span class="string">&quot; and b is &quot;</span>+x.b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案3：利用数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = data[a];</span><br><span class="line">    data[a] = data[b];</span><br><span class="line">    data[b] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><p>求gcd。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if(a &lt;= 0 || b &lt;= 0) return 0;</span></span><br><span class="line"><span class="keyword">if</span>(a%b==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> a = r.nextInt(), b = r.nextInt();</span><br><span class="line">a=Math.abs(a); b=Math.abs(b);</span><br><span class="line">System.out.println(a+<span class="string">&quot; &quot;</span>+b);</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) System.out.println(gcd(b,a));</span><br><span class="line"><span class="keyword">else</span> System.out.println(gcd(a,b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求素数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;初学Java，有些东西需要记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Part-1&quot;&gt;&lt;a href=&quot;#Part-1&quot; class=&quot;headerlink&quot; title=&quot;Part 1&quot;&gt;&lt;/a&gt;Part 1&lt;/h1&gt;&lt;p&gt;J</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://preccrep.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>组合逻辑设计</title>
    <link href="https://preccrep.github.io/2021/03/04/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"/>
    <id>https://preccrep.github.io/2021/03/04/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-04T13:44:43.000Z</published>
    <updated>2021-03-22T09:20:58.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>可以先参考我写的这篇：<a href="https://www.preccrep.com/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/">戳这</a></p><p>数字逻辑电路（logic circuit）是一个可以处理<strong>离散值</strong>变量的网络。</p><p>其中包括：</p><ul><li>一个或多个离散值<strong>输入端</strong>（输入的是离散值）</li><li>一个或多个离散值<strong>输出端</strong>（输出的是离散值）</li><li>描述输入和输出关系的<strong>功能规范</strong></li><li>描述当输入改变时输出响应延迟的<strong>时序规范</strong></li></ul><blockquote><p>3种逻辑运算：<br>与：$A\cdot B$ 或 $AB$.<br>或：$A+B$.<br>非：$\overline{A}$.</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>变量：可以用大小写英文字母表示，取值只能是0或1.</p><p>反变量：即变量的非.</p><p>项：变量或它的反变量.</p><p>布尔表达式适用于描述组合逻辑电路中输入与输出间的功能规范。</p><h2 id="结点和模块"><a href="#结点和模块" class="headerlink" title="结点和模块"></a>结点和模块</h2><p>电路由结点和模块组成。</p><p><img src="https://i.loli.net/2021/03/05/OF7bgqCYQkRndrV.png" alt="电路.png"></p><p>结点是一段导线，通过电压传递离散值变量。</p><ul><li>输入结点：接收外部的值（如A，B，C）</li><li>输出结点：输出值到外部（如Y，Z）</li><li>内部结点：不属于以上两者的结点（如n1）</li></ul><p>模块本身是一个带有输入、输出、功能规范和时序规范的电路。</p><ul><li>每一个模块本身都是一个电路</li><li>图中的E1，E2，E3</li></ul><h2 id="数字逻辑电路的分类"><a href="#数字逻辑电路的分类" class="headerlink" title="数字逻辑电路的分类"></a>数字逻辑电路的分类</h2><p>组合逻辑电路（combinational logic）</p><ul><li>任一时刻的输出仅由该时刻的输入信号决定</li><li>无记忆的，与电路状态无关</li></ul><p>时序逻辑电路（sequential logic）</p><ul><li>任一时刻的输出由该时刻的输入和电路在该时刻的状态共同决定</li><li>有记忆的，与电路状态有关</li></ul><p>即：输入 $\rightarrow$ 功能规范/时序规范 $\rightarrow$ 输出。</p><p>例如计算器就是一个典型的时序逻辑电路。输入为1+1=时，得到输出为2，但是按=得到的输出并不总是为2，而是要看当前的状态。</p><h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><p>特点：</p><ul><li>每个电路模块都是一个组合逻辑电路。</li><li>每个电路结点：<ul><li>要么是电路是输入</li><li>要么只连接电路模块的一个输出端（并不在意结点连接到多少个输入上，但是只能连接到一个输出）</li></ul></li><li>电路中不包含回路</li></ul><p><img src="https://i.loli.net/2021/03/05/LWKutgyHSw3c4vE.png" alt="组合逻辑电路.png"></p><p>通常用CL符号表示组合逻辑。</p><p>思考题：</p><p><img src="https://i.loli.net/2021/03/05/9JStAY3kH7CnBxW.png" alt="思考题.png"></p><p>图2存在回路，图4的n4结点有2个输入，图6存在回路。</p><h1 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h1><p>3种逻辑运算：</p><ul><li>与：$A\cdot B或AB$</li><li>或：$A+B$</li><li>非：$\overline{A}$</li></ul><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>变量：可以用大小写英文字母表示，取值只能是0或1.</p><p>反变量（complement）：即变量的非.</p><p>项（literal）：变量或它的反变量.</p><p>布尔表达式适用于描述<strong>组合逻辑电路</strong>中输入与输出间的功能规范。（因为组合逻辑电路的输出只与输入有关）</p><p>对偶（duality）：</p><p>设F为任意逻辑表达式，若将F中所有运算符和常量作如下变换：</p><script type="math/tex; mode=display">. \rightarrow +</script><script type="math/tex; mode=display">+ \rightarrow .</script><script type="math/tex; mode=display">0 \rightarrow 1</script><script type="math/tex; mode=display">1 \rightarrow 0</script><p>则变换后得到的是F的对偶式F‘。</p><p>对偶是相互的，F和F’互为对偶式。</p><p>对偶规则：两个逻辑表达式F和G相等，则对偶式F’和G’也相等。例如：</p><script type="math/tex; mode=display">A(B+C)=AB+AC \rightarrow A+BC=(A+B)(A+C)</script><p><img src="https://i.loli.net/2021/03/05/eVtTS4E3BWoZ6KO.png" alt="德摩根定律.png"></p><p>蕴含项（implicant）：项的乘积</p><blockquote><p>如 $AB\overline{C}$, $AC$</p></blockquote><p>最小项（miniterm）：包含全部输入变量的乘积项</p><blockquote><p>如 AB\overline{C}$, $ABC$</p></blockquote><p>最大项（maxterm）：包含全部输入变量的求和项</p><blockquote><p>如 $A+B+C$, $A+\overline{B}+C$</p></blockquote><h2 id="最小项"><a href="#最小项" class="headerlink" title="最小项"></a>最小项</h2><p>n个变量逻辑函数的每个最小项，一定是包含n个因子的乘积项，有 $2^n$ 个最小项。</p><p><strong>最小项的编号</strong></p><p>最小项用 $m_i$ 表示。m表示最小项，下标 i 为使该最小项为1的变量取值所对应的等效十进制数。</p><blockquote><p>最小项 $\overline{A}BC$<br>要使该最小项为1，A、B、C的取值应为0、1、1.<br>二进制数011所等效的十进制数为3，所以 $\overline{A}BC=m_3$.</p></blockquote><p><strong>最小项的性质</strong></p><ol><li><p>变量任取一组值，仅有一个最小项为1，其余为0.</p></li><li><p>n变量的全体最小项之和恒为1.</p></li><li><p>n个变量任意两个不同的最小项相与，结果恒为1.</p></li><li><p>相邻最小项相或，可以合并为一项，并可以消除一个变量：</p><blockquote><p>相邻：两最小项仅有一个变量因子不同，其他变量均相同</p><p>例如：$ABC+AB\overline{C}=AB$.</p><p><strong>任一n变量的最小项，必定和其他n个不同最小项相邻</strong>（每一个变量取反都是相邻项）</p></blockquote></li></ol><h2 id="最大项"><a href="#最大项" class="headerlink" title="最大项"></a>最大项</h2><p><strong>最大项的编号</strong></p><p>最大项用 $M_i$ 表示。M表示最大项，下标 i 为使该最大项为0的变量取值所对应的等效十进制数。</p><blockquote><p>最大项 $\overline{A}+B+C$<br>要使该最小项为0，A、B、C的取值应为1、0、0.<br>二进制数100所等效的十进制数为4，所以 $\overline{A}+B+C=M_4$.</p></blockquote><p><strong>最大项的性质</strong></p><ol><li><p>变量任取一组值，仅有一个最大项为0，其余为1.</p></li><li><p>n变量的全体最大项之积恒为0.</p></li><li><p>n个变量任意两个不同的最大项相或，结果恒为1.</p></li><li><p>相邻最大项相与，可以合并为一项，并可以消除一个变量：</p><blockquote><p>例如：$(A+B+C)(A+B+\overline{C})=A+B$.</p></blockquote></li></ol><p><strong>相同编号的最小项和最大项互为反函数。</strong></p><h1 id="标准与或式和标准或与式"><a href="#标准与或式和标准或与式" class="headerlink" title="标准与或式和标准或与式"></a>标准与或式和标准或与式</h1><h2 id="标准与或式（sum-of-products）"><a href="#标准与或式（sum-of-products）" class="headerlink" title="标准与或式（sum-of-products）"></a>标准与或式（sum-of-products）</h2><p>由最小项之和构成的逻辑表达式。</p><p>例如：</p><script type="math/tex; mode=display">F(A,B,C)=\overline{A}B\overline{C}+A\overline{B}\overline{C}+AB\overline{C}=\Sigma(m_2,m_4,m_6)=\Sigma(2,4,6)</script><p>每个最小项都对应真值表中值为1的一行。</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F(A, B, C)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>标准与或式是最小项之间的或运算，与真值表间一一对应。</p><p>可以有多个逻辑表达式对应相同的真值表，但是只有一个标准与或式与该真值表对应。</p><p><strong>标准与或式具有唯一性。</strong></p><p><strong>任一逻辑函数都可以表达为最小项之和的形式，而且是唯一的。</strong></p><p>例如：（通常把缺的那一项配上）</p><script type="math/tex; mode=display">F(A,B,C)=AB+\overline{A}C=AB(C+\overline{C})+\overline{A}C(B+\overline{B})=ABC+AB\overline{C}+\overline{A}BC+\overline{A}\overline{B}C=\Sigma(1,3,6,7)</script><h2 id="标准或与式（product-of-sum）"><a href="#标准或与式（product-of-sum）" class="headerlink" title="标准或与式（product-of-sum）"></a>标准或与式（product-of-sum）</h2><p>最大项之积构成的逻辑表达式。</p><p>例如：</p><script type="math/tex; mode=display">F(A,B,C)=(A+B+C)(A+\overline{B}+C)(\overline{A}+B+C)=\prod(M_0,M_2,M_4)=\prod(0,2,4)</script><p><strong>任何一个逻辑函数也可以写成最大项之积的形式，并且是唯一的。</strong></p><h2 id="标准与或式和标准或与式的关系"><a href="#标准与或式和标准或与式的关系" class="headerlink" title="标准与或式和标准或与式的关系"></a>标准与或式和标准或与式的关系</h2><script type="math/tex; mode=display">F(A,B,C)=\Sigma(2,4,6)</script><script type="math/tex; mode=display">\overline{F}(A,B,C)=\Sigma(0,1,3,5,7)</script><script type="math/tex; mode=display">F=\overline{\overline{F}}=\overline{m_0+m_1+m_3+m_5+m_7}=\overline{m_0}\cdot\overline{m_1}\cdot\overline{m_3}\cdot\overline{m_5}\cdot\overline{m_7}=M_0M_1M_3M_5M_7</script><p>于是有</p><script type="math/tex; mode=display">F=\sum_i m_i=\prod_{j\neq i}M_j</script><p>推导：</p><script type="math/tex; mode=display">F=\sum_i m_i=\overline{\sum_{j\neq i} m_j}=\prod_{j\neq i}\overline{m_j}=\prod_{j\neq i}M_j</script><h2 id="布尔表达式与真值表的转换"><a href="#布尔表达式与真值表的转换" class="headerlink" title="布尔表达式与真值表的转换"></a>布尔表达式与真值表的转换</h2><ol><li><p>代入法</p></li><li><p>将表达式转化为标准与或式</p></li><li><p>直接填表：</p><p>对 $F(A,B,C)=AB+BC$，表示的逻辑含义为：</p><ol><li><p>AB=1时，F=1.</p></li><li><p>BC=1时，F=1.</p></li><li><p>否则F=0.</p></li></ol><p>于是只有(0,1,1), (1,1,0), (1,1,1)满足条件。</p></li></ol><h2 id="使用定理化简表达式"><a href="#使用定理化简表达式" class="headerlink" title="使用定理化简表达式"></a>使用定理化简表达式</h2><p>使与或式中的与项最少，与项中出现的变量最少。</p><script type="math/tex; mode=display">例如，A(A+B)=A</script><h1 id="从逻辑到门"><a href="#从逻辑到门" class="headerlink" title="从逻辑到门"></a>从逻辑到门</h1><p><img src="https://i.loli.net/2021/03/05/MUnShzXARHamIcE.png" alt="原理图.png"></p><h1 id="X和Z"><a href="#X和Z" class="headerlink" title="X和Z"></a>X和Z</h1><h2 id="非法值"><a href="#非法值" class="headerlink" title="非法值"></a>非法值</h2><p>竞争（contention）：电路结点同时被0和1驱动</p><ul><li>电压值可能介于 $0~V_{DD}$ 之间</li><li>可能是0，可能是1，也可能处于禁止区域内</li><li>导致电路的功耗变大、电路发热，并导致损坏</li></ul><p>竞争通常是由于电路设计缺陷引起的。</p><h2 id="无关项"><a href="#无关项" class="headerlink" title="无关项"></a>无关项</h2><p><img src="https://i.loli.net/2021/03/06/NtrRXUysqm76zio.png" alt="无关项.png"></p><h2 id="浮空值"><a href="#浮空值" class="headerlink" title="浮空值"></a>浮空值</h2><p>浮空（floating）也称悬空、高阻态（high impedance）、高Z态、开路、断路</p><p>浮空不等于逻辑0.</p><ul><li>使用电压表并不能判断哪个电路结点处于浮空状态</li><li>测量断路结点的电压（断路）和接地点的电压（短路），在电压表上的读数都是0</li></ul><p>当电路的输入结点浮空时，输出不确定。</p><ul><li>可能为0，可能为1，也可能为某个中间电压（处于禁止区）</li></ul><p>产生浮空结点常见的原因是忘记将电压连接到输入端，但浮空结点并不意味着电路一定出错。</p><p>浮空表示的是断路。</p><h2 id="三态缓冲器"><a href="#三态缓冲器" class="headerlink" title="三态缓冲器"></a>三态缓冲器</h2><p>浮空可以用来防止结点处于竞争状态。</p><p>三态缓冲器有3种可能输出状态，分别为高电平、低电平和浮空。</p><p><img src="https://i.loli.net/2021/03/06/GAQ6wbBCPWHFE5e.png" alt="三态缓冲器.png"></p><p>上图中输入端是A，输出端是Y，使能端是E。使能端也作为输入，所以是2个输入1个输出。</p><p>当E为1时，Y由A决定；当E为0时，Y恒为高阻态，说明此时是断路的。<strong>即三态门的使能端无效时输出为高阻态。</strong></p><p><img src="https://i.loli.net/2021/03/06/SzuxewfmjVQOR2G.png" alt="三态缓冲器的应用.png"></p><h1 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h1><p>卡诺图化简法是将逻辑函数用一种称为“卡诺图”的图形来表示，然后在卡诺图上进行化简的方法。</p><p>卡诺图采用相邻两个最小项能够合并，并消掉一个变量的原理进行变量化简。</p><p>卡诺图中每个小方格对应一个最小项。</p><p>相邻最小项可以是位置相邻</p><p>相邻最小项可以是对称相邻</p><p>相邻的两个最小项在卡诺图中也是相邻的。卡诺图中相邻的含义：</p><ol><li>几何相邻性，即几何位置上相邻，也就是左右紧挨着或者上下相接。</li><li>对称相邻性，即图形中位于边缘的单元与对称位置的单元是相邻的。</li></ol><p>卡诺图是真值表的一种变形。</p><p><strong>卡诺图上合并最小项的规则</strong><br>规则1：当卡诺图中有最小项相邻时（即有标1的方格相邻），可利用最小项相邻的性质，对最小项合并。（卡诺图中相邻的两个小项合并时，消掉的是取值不同的变量。）<br>规则2：卡诺图上4个标1方格相邻，可合并为一项，并可消去2个变量。</p><blockquote><p>4个标1方格相邻的特点：同在一行或一列；同在一个田字格中。</p></blockquote><p><img src="https://i.loli.net/2021/03/07/lwovJ962CQtPTpd.png" alt="卡诺图.png"></p><p>规则3：卡诺图上8个标1方格相邻，可以合并为1项，并可消去3个变量.</p><p><strong>合并规则总结</strong>：在n个变量的卡诺图中，只有2的i次方个相邻的标1方格（必须排列成方形格）才能合并为1项，并且消去i个变量。</p><h1 id="减少硬件"><a href="#减少硬件" class="headerlink" title="减少硬件"></a>减少硬件</h1><p>所有的逻辑表达式都可以转化为与或式。</p><p>理论上，与或式可以用两级门电路实现，但是成本太高。采用多级逻辑可以减少门电路的数量和扇入数。</p><blockquote><p>扇入（fan-in）：单个逻辑门能够接受的数字信号最大输入数。</p></blockquote><p>可以将一个三输入与或门转化成两个二输入与或门：</p><script type="math/tex; mode=display">Y=A\oplus B\oplus C=(A\oplus B)\oplus C</script><p>将二级门电路转成多级门电路来实现时，输出信号的延迟会增大。</p><p><strong>与非和或非运算都是完备的，利用与非门和或非门可以实现任何表达式。</strong></p><p><img src="https://i.loli.net/2021/03/15/c23Cr8hXqWePdDO.png" alt="推气泡.png"></p><p>（由于德摩根定律）</p><p>推气泡：将与非门和或非门转换成与/或门电路用于读取BOOL表达式；将与/非门的电路转换为与/或非门电路用于CMOS实现。</p><h1 id="组合逻辑电路设计方法"><a href="#组合逻辑电路设计方法" class="headerlink" title="组合逻辑电路设计方法"></a>组合逻辑电路设计方法</h1><p>七段数码管驱动电路：4位输入数据，输入一个十进制数字（4位二进制数可表示一位十进制数）；7位输出控制发光管显示数字0-9.</p><p>七段数码管（由7个发光二极管构成）的连接方式有共阴极和共阳极两种方式。共阴极连接时，对应字段高电平时被点亮；共阳极连接时，对应字段低电平时被点亮。</p><h1 id="组合逻辑模块"><a href="#组合逻辑模块" class="headerlink" title="组合逻辑模块"></a>组合逻辑模块</h1><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>用n位二进制代码对$N=2^n$个特定信息进行编码的逻辑电路。</p><p>例如，设计一个具有4路信号输入的优先级编码器：</p><p>输入：X0, X1, X2, X3</p><p>输出：A0, A1, EO(EO用于判定是否存在有效输入)</p><p>功能：将4个输入信号进行二进制编码（4线-2线编码器）</p><p><strong>优先级编码</strong>：当有多个信号同时输入时，只对优先权高的一个信号进行编码。</p><p><strong>输出使能端</strong>：用于判别电路是否有信号输入。用EO表示，EO=0表示有信号输入，EO=1表示无信号输入。</p><div class="table-container"><table><thead><tr><th>输入</th><th>A0</th><th>A1</th><th>EO</th></tr></thead><tbody><tr><td>无有效信号</td><td>0</td><td>0</td><td>1</td></tr><tr><td>X0有效，X1, X2, X3无效</td><td>0</td><td>0</td><td>0</td></tr><tr><td>X1有效，X2, X3无效</td><td>0</td><td>1</td><td>0</td></tr><tr><td>X2有效，X3无效</td><td>1</td><td>0</td><td>0</td></tr><tr><td>X3有效</td><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>因此X0, X1, X2, X3编码分别为：00，01，10，11</p><p>于是可以画出真值表。在真值表中，X0先出现(X3=0, X2=0, X1=0, X0=1)就对应A0=0，A1=0，EO=0；X1先出现(X3=0, X2=0, X1=1, X0=0或X3=0, X2=0, X1=1, X0=1)就对应A0=0，A1=1，EO=0…</p><p>然后就可以使用X简化真值表：</p><div class="table-container"><table><thead><tr><th>X3</th><th>X2</th><th>X1</th><th>X0</th><th>A1</th><th>A0</th><th>EO</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>X</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>X</td><td>X</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>X</td><td>X</td><td>X</td><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>由真值表画出X0X1X2X3的卡诺图，即可写出A0、A1、EO的表达式。</p><h2 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h2><p>译码时编码的逆过程，有n个输入，$2^n$个输出。</p><p>每一种输入的组合对应使能端某个特定时刻的输出信号。</p><p>输出使独热（互斥）的，同一时刻只能输出一个有效信号，即每一组输入只能使一条输出线产生有效输出电平。</p><p>如果是高电平有效，EO的值在输入信号无效时为1.（于是当EO为0时，输出为高电平）</p><p>译码器的每一个输出都对应输入信号的一个最小项。</p><p>译码器可以把地址信息当做输入信号，把有效输出信号当成选择信号，来选中特定的设备来工作。</p><p>同一时刻只能允许总线上的一个外部设备向处理器发送信息，所以在同一时刻只能允许一个三态缓冲器的使能端输出有效信号。这时就要用到译码器。因为译码器输出的信号就是互斥的。</p><p>译码器的每一个输出信号连接到一个外部设备的三态缓冲器上。于是，同一时刻只需发送一个特定的信号，就能确定用哪一个三态缓冲器了。</p><p>每个外部设备都有一个地址来唯一标识。计算机想与哪一个外部设备进行数据交换，首先就要知道这个设备的地址，控制这个设备。</p><p>但是只知道信号和地址，无法确定数据的流向。因为总线上的数据是双向传递的。</p><p>读写控制依赖于输入输出信号（0或1，通过与门或与非门后到达三态缓冲器使能端，由此决定数据传输方向）。高电平时表示设备向处理器发送数据，低电平时表示处理器将数据输送到设备。</p><p>数据、地址、控制——三总线。</p><p>通过译码器+或门可以构造出更加复杂的表达式。</p><h2 id="多路选择器（MUX）"><a href="#多路选择器（MUX）" class="headerlink" title="多路选择器（MUX）"></a>多路选择器（MUX）</h2><p>根据选择信号的值从N个可能的输入中选择一个作为输出。</p><p>需要使用logN位选择信号（也称地址信号）作为输入，控制输入信号的选择。</p><p>3-8译码器对低电平有效，输出值中只有一个是0.</p><p>74LS138 3-8译码器</p><p>组合逻辑电路的传播延迟是关键路径上每一个元件的传播延迟之和。</p><p>传播延迟一般大于最小延迟。</p><p>最小延迟是从输入发生变化直到任何一个输出开始改变的最短时间。</p><p>传播延迟是从输入改变直到一个或多个输出改变为最终值所经历的最长时间延迟。</p><p>由0到1是一个给电容充电的过程，由1到0是一个给电容放电的过程。</p><p>产生延迟的原因：</p><ul><li>电路中的电阻和电容的充放电</li><li>光速的上限</li></ul><p>上升沿和下降沿的延迟可能不同</p><p>不同输出的延迟可能不同</p><p>电路对温度敏感，电路较热时速度会变慢</p><p>组合逻辑电路中，最小延迟是最短路径上每个元件的最小延迟之和。</p><p>毛刺的产生是由于电路中，变化的信号从出发点到汇合点所经历的两个路径长度不同所造成的。</p><p>毛刺只能在传播延迟的时间范围之内发生，否则传播延迟计算错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;可以先参考我写的这篇：&lt;a href=&quot;https://www.preccrep.com/2021/02/18/%E6%95%B0%E5%A</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数字逻辑与数字系统" scheme="https://preccrep.github.io/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://preccrep.github.io/2021/02/23/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://preccrep.github.io/2021/02/23/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-02-23T06:12:36.000Z</published>
    <updated>2021-02-26T14:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用层<br>应用层协议原理<br>网络应用程序体系结构<br>现代网络应用程序的两大主流体系结构：客户-服务器体系结构 对等（P2P）体系结构</p><p>客户-服务器体系结构（client-server architecture）<br>在此结构中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。客户之间不能相互通信。</p><p>该服务器具有固定的、周知的地址，即IP地址。</p><p>P2P体系结构<br>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。</p><p>进程通信</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>应用层的大多数协议都是基于客户服务器方式。客户和服务器都是指通信中所涉及的两个应用进程。客户服务器方式所描述的进程之间服务和被服务的关系。</p><p><strong>域名系统(Domain Name System, 简称DNS)</strong>，主要是解决Internet网上机器或设备命名的一种系统。它是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>DNS使用TCP和UDP端口53.</p><p>对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p>域名系统是一种服务器资源，许多应用层软件经常直接使用域名系统DNS，但计算机的用户只是间接而不是直接使用域名系统。</p><p>Internet采用层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS。</p><p>域名服务器程序在专设的节点上运行，运行该程序的机器称为域名服务器。</p><blockquote><p><strong>域名</strong>（英语：<strong>Domain Name</strong>），又称<strong>网域</strong>，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。</p><p>由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p></blockquote><p>Internet采用了层次树状结构的命名方法，任何一个连接在Internet上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</p><p>域名的结构由若干层次组成，各分量之间用点隔开，各分量分别代表不同级别的域名。</p><p><strong>域名服务器与域名解析</strong></p><p>Internet允许各个单位根据具体情况将本单位的域名划分为若干个域名服务器管辖区(zone)，并在各管辖区中设置相应的授权域名服务器。</p><p>域名是需要授权的，需要预先注册登记，如果没有授权，域名是不允许改动、删除的。</p><p>在Internet中，划分多个区域，每个区域中设一个授权区域。</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210223145913712.png" alt="image-20210223145913712"></p><p><strong>域名解析过程</strong>：</p><p>DNS查询有两种方式：递归查询和迭代查询。</p><p>DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。DNS服务器之间一般采用迭代查询方式。</p><p><strong>递归查询</strong>：如果想知道一个域名对应的IP地址，但在访问本地域名服务器时，可能该域名查询不到，此时该本地域名服务器就会请求它的上级支援，直到查到所查询的IP地址。</p><p>递归解析（递归查询）过程中，一直是以本地名称服务器为中心的，DNS客户端只是发出原始的域名查询请求报文，然后就一直处于等待状态，直到本地域名服务器发来最终的查询结果。此时的本地域名服务器只是起到了中介代理的作用。</p><p>本地名称服务器也有缓存技术。</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210223152830400.png" alt="image-20210223152830400"  /></p><p><strong>域名解析过程加快的途径</strong>：</p><ul><li>物理配置上，配一台运行速度高（CPU主频高、计算机内存大）的域名服务器；</li><li>让数据库域名表中记录有序存放，可采用效率高的查找算法，例如折半查找法；</li><li>准备一个高速缓冲cache，将域名放入其中，即名字的高速缓存。</li></ul><h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>文件传输协议FTP是用于在网络上进行文件传输的一套标准协议。</p><p>FTP能把多种类型的文件或文档，从不同厂家生产的计算机、手机等智能终端，通过有线或无线的计算机网络，发送复制到远程另外一台智能设备中，是网络环境的一项基本应用。</p><p>网络环境下复制文件的复杂性主要是：</p><ol><li>计算机存储数据的格式不同；</li><li>文件的目录结构和文件命名的规定不同；</li><li>对于相同的文件存取功能，操作系统使用的命令不同；</li><li>访问控制方法不同。</li></ol><p><strong>FTP特点</strong>：</p><ul><li>文件传输协议FTP只提供文件传送的一些基本的服务，它使用TCP可靠的传输服务。</li><li>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。</li><li>FTP的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</li></ul><p><strong>主进程的工作步骤</strong>：</p><ul><li>打开熟知端口(端口号为21)，使客户进程能够连接上；</li><li>等待客户进程发出连接请求；</li><li>启动从属进程来处理客户进程发来的请求。从属进程将客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程；</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程和从属进程的处理是并发进行。</li></ul><blockquote><p><strong>TCP的端口(用16位端口号来标示一个端口  0-66535正好65536个  0为保留，可允许有65535个不同的端口)</strong></p><p><strong>注意：端口只具有本地意义，只是为标志本计算机应用层中的各个进程在和运输层交互时的层间接口，在因特网上不同主机中，相同的端口号没有关联。</strong></p><p><strong>由此可见，两个计算机的进程要互相通信，不仅必须知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)</strong></p><p>TCP的端口号可分为两大类:</p><ol><li><p>服务器端使用的端口号(又可分为两类):</p><p>1) 熟知端口号/系统端口号(well known port number): 数值为0-1023.可在www.iana.org查到，IANA把这些端口号指派给TCP/IP中最重要的一些应用程序，让所有用户都知道。当一种新的应用程序出现后，IANA必须为它指派一个熟知端口，否则因特网上的其他应用进程就无法和它进行通信。如下是一些熟知端口号：</p><p>| 应用程序   | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | SNMP | SNMP(trap) |<br>| ————— | —— | ——— | —— | —— | —— | —— | —— | ————— |<br>| 熟知端口号 | 21   | 23     | 25   | 53   | 69   | 80   | 161  | 162        |</p><p>2) 注册端口号: 数值为1024-49151.为没有熟知端口号的应用程序使用的。使用这类端口号必须按照IANA的规定手续登记，以防止重复。</p></li><li><p>客户端使用的端口号</p><p>数值为49152-65535。由于这类端口号仅在客户进程运行时才动态的选择，因此又称短暂端口号(临时端口号)。是留给客户进程选择暂时使用，当服务器进程收到客户进程的报文，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，这个端口号就不存在了，就可以供给其他客户进程以后使用。</p></li></ol></blockquote><p>FTP使用的两个TCP连接：控制连接和数据连接</p><p>控制连接在整个会话期间一直保持打开，FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</p><p>实际用于传输文件的是“数据连接”。服务器端的控制进程在受到FTP客户发送来的文件传输请求后，就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</p><p>两个不同的端口号：当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口(21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口(20)与客户进程所提供的端口号码建立数据传送连接。</p><p>由于FTP使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</p><p>FTP的使用模式：主动模式和被动模式</p><p>主动模式要求客户端和服务器端同时打开并且监听一个端口以建立连接。在这种情况下，客户端如果安装了防火墙，文件传输就会产生一些问题。所以，创立了被动模式。</p><p>被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装防火墙的问题。</p><p><strong>基于主动模式的FTP连接创建步骤</strong></p><p>客户端打开一个随机的端口(端口号大于1024，在这里称其为X)，同时一个FTP进程连接至服务器的21号命令端口。此时，该TCP连接的来源地端口为客户端指定的随机端口X，目的地端口(远程端口)为服务器上的21号端口。</p><p>客户端开始监听端口X+1，同时向服务器发送一个端口命令(通过服务器的21号命令端口)，此命令告诉服务器客户端正在监听的端口号并且已准备好从此端口接收数据。这个端口就是数据端口。</p><p>服务器打开20号源端口并且创建和客户端数据端口的连接。此时，来源地端口为20，目的地端口为X+1.</p><p>客户端通过本地的数据端口创建一个和服务器20号端口的连接，然后向服务器发送一个应答，告诉服务器它已经创建好了一个连接。</p><p>大多数网页浏览器和文件管理器都能和FTP服务器创建连接。这使得在FTP上通过一个接口就可以操控远程文件，如同操控本地文件一样。</p><p>是否提供密码是可选择的，如果有密码，则形如<code>ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;</code>.</p><h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><p>网络文件系统是FreeBSD支持的文件系统中的一种，它允许一个系统在网络上与他人共享目录和文件。</p><p>通过使用NFS，用户和程序可以像访问本地文件一样，访问远端系统上的文件。</p><p>NFS至少有两个主要部分：一台服务器和一台(或者更多)客户机。客户机远程访问存放在服务器上 的数据。为了正常工作，一些进程需要被配置并运行。</p><p>Linux环境下，NFS的配置重点在于对<code>/etc/rc.conf</code>文件的修改，过程如下：</p><p>NFS服务器端，确认<code>/etc/rc.conf</code>文件有如下语句：</p><p><code>rpcbind_enable=&quot;YES&quot;</code></p><p><code>nfs_server_enable=&quot;YES&quot;</code></p><p><code>mountd_flags=&quot;-r&quot;</code></p><blockquote><p>NFS被设置为enable，mountd就能自动运行。</p></blockquote><p>客户端，确认<code>/etc/rc.conf</code>文件有如下语句：</p><p><code>nfs_client_enable=&quot;YES&quot;</code></p><blockquote><p><code>/etc/exports</code>文件指定了哪个文件系统NFS应该输出(也成为共享)。<code>/etc/exports</code>里面每行指定一个输出的文件系统和哪些机器可以访问该文件系统。在指定机器访问权限的同时，访问选项开关也可以被指定。</p></blockquote><p>NFS的技术优势：</p><ul><li>本地工作站使用更少的磁盘空间，因为通常的数据可以存放在一台机器上而且可以通过网络访问到。</li><li>用户不必在每个网络机器上都有一个home目录。home目录可以被放在NFS服务器上并且在网络上处处可用。</li></ul><blockquote><p>以下内容来自<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">维基</a>：</p><p><strong>文件传输协议</strong>（英语：<strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>FTP</strong>）是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS(<strong>N</strong>etwork <strong>F</strong>ile <strong>S</strong>ystem)等应用系统提供。</p><p>FTP是一个8位的客户端-服务器协议，能操作任何类型的文件而不需要进一步处理，就像<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>或<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>一样。但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。</p><p>FTP服务一般运行在20和21两个端口。端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流，并且是命令通向ftp服务器的进口。当数据通过数据流传输时，控制流处于空闲状态。而当控制流空闲很长时间后，客户端的防火墙会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功的传输，但因为控制会话，会被防火墙断开；传输会产生一些错误。</p></blockquote><h1 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h1><p>TFTP(<strong>简单文件传输协议</strong>也称<strong>小型文件传输协议</strong>（<strong>T</strong>rivial <strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol, <strong>TFTP</strong>）)是一个很小且易于实现的文件传送协议。</p><p>TFTP使用客户服务器方式和使用<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>数据报，它得不到可靠的数据传输，因此TFTP需要有自己的差错改正措施。</p><p>TFTP只支持文件传输而不支持交互。</p><p>TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>特点：</p><ul><li>每次传送的数据PDU中有512个字节的数据，但最后一次可不足512字节</li><li>数据PDU(协议数据单元)也称为文件块(block)，每个块按序编号，从1开始</li><li>支持ASCII码(即支持文本文件传输)或二进制(即支持非文本传输，如一段音乐、一个照片等)传送</li><li>可对文件进行读或写</li><li>使用很简单的首部</li></ul><blockquote><p><strong>协议数据单元</strong>（英语：Protocol Data Unit，缩写为<strong>PDU</strong>）:</p><p>在<a href="https://zh.wikipedia.org/wiki/OSI模型">OSI模型</a>系统里，PDU和最下面四层相关。</p><ol><li><p><a href="https://zh.wikipedia.org/wiki/物理层">物理层</a>（一层）PDU指<strong>数据位</strong>（<strong>Bit</strong>）。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/数据链路层">数据链路层</a>（二层）PDU指<strong>数据帧</strong>（<strong>Frame</strong>）。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/网络层">网络层</a>（三层）PDU指<strong>数据包</strong>（<strong>Packet</strong>）。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/传输层">传输层</a>（四层）PDU指<strong>数据段</strong>（<strong>Segment</strong>）。</p></li></ol><p>第五层或以上为<strong>数据</strong>（<strong>data</strong>）。在特定的上下文情况下，一个特定层的PDU有时可以代表这个层。</p></blockquote><p>关于UDP：</p><blockquote><p><strong>用户数据报协议</strong>（英语：<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，缩写：<strong>UDP</strong>；又称<strong>用户数据包协议</strong>）是一个简单的面向<a href="https://zh.wikipedia.org/wiki/数据报">数据报</a>的<a href="https://zh.wikipedia.org/wiki/通信协议">通信协议</a>，位于<a href="https://zh.wikipedia.org/wiki/OSI模型">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/传输层">传输层</a>。</p><p>在<a href="https://zh.wikipedia.org/wiki/TCP/IP">TCP/IP</a>模型中，UDP为<a href="https://zh.wikipedia.org/wiki/网络层">网络层</a>以上和<a href="https://zh.wikipedia.org/wiki/应用层">应用层</a>以下提供了一个简单的接口。UDP只提供<a href="https://zh.wikipedia.org/wiki/数据">数据</a>的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。</p><p>UDP适用于不需要或在<a href="https://zh.wikipedia.org/wiki/计算机程序">程序</a>中执行<a href="https://zh.wikipedia.org/wiki/错误检测与纠正">错误检查和纠正</a>的<a href="https://zh.wikipedia.org/wiki/应用程序">应用</a>，它避免了<a href="https://zh.wikipedia.org/wiki/协议栈">协议栈</a>中此类处理的<a href="https://zh.wikipedia.org/w/index.php?title=开销&amp;action=edit&amp;redlink=1">开销</a>。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。</p></blockquote><p>数据报（Datagram）：</p><blockquote><p>是在<a href="https://zh.wikipedia.org/wiki/封包交換網路">分组交换网络</a>中的最小传输资料单元。是一种<a href="https://zh.wikipedia.org/wiki/無連接式通訊">无连接式通信</a>方法，它与<a href="https://zh.wikipedia.org/wiki/虛擬電路">虚拟电路</a>构成了<a href="https://zh.wikipedia.org/wiki/分组交换">分组交换</a>的两种主要传输方式。</p></blockquote><p>TFTP工作原理：</p><ul><li>在一开始工作时，TFTP客户进程发送一个读请求PDU或写请求PDU给TFTP服务器进程，其熟知端口号为69(16进制)</li><li>初始连接时要发出WRQ(请求写入远程系统)或RRQ(请求读取远程系统)，收到一个确定应答，一个确定可以写出的包或应该读取的第一块数据</li><li>创建连接时，通信双方随机选择一个TID，因此两次选择同一个ID的可能性就很小</li><li>每个包包括两个TID，发送者ID和接收者ID</li><li>TFTP服务器进程要选择一个新的端口和TFTP客户进程进行通信。若文件长度恰好为512字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据PDU。若文件长度不是512字节的整数倍，则最后传送数据PDU的数据字段一定不满足512字节，这正好可作为文件结束的标志</li></ul><p>TFTP工作原理：</p><p>写入例子(WRQ，ACK和DATA代表写入、确认和数据)</p><p>主机A向主机B发出WRQ，其中端口为69</p><p>B机向A机发出ACK，块号为0，包括B和A的TID</p><h1 id="EMAIL"><a href="#EMAIL" class="headerlink" title="EMAIL"></a>EMAIL</h1><p>3个主要组成部分：</p><ol><li>用户代理</li><li>邮件服务器</li><li>简单邮件传输协议：SMTP</li></ol><p><strong>用户代理</strong>：</p><ul><li>又名“邮件阅读器”</li><li>撰写、编辑和阅读邮件</li><li>如Outlook, Foxmail</li><li>输出和输入邮件保存在服务器上</li></ul><p>例如WEB的HTTP代理就是浏览器，FTP的代理就是FTP的后端软件</p><p><strong>邮件服务器</strong>：</p><ul><li>邮箱中管理和维护发送给用户的邮件</li><li>输出报文队列保持待发送邮件报文</li><li>邮件服务器之间的SMTP协议：发送EMAIL报文<ul><li>客户：发送方邮件服务器</li><li>服务器：接收端邮件服务器</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;应用层&lt;br&gt;应用层协议原理&lt;br&gt;网络应用程序体系结构&lt;br&gt;现代网络应用程序的两大主流体系结构：客户-服务器体系结构 对等（P2P）体系结构&lt;/p&gt;
&lt;p&gt;客户-服务器体系结构（client-server architecture）&lt;br&gt;在此结构中，有一个总是打开的主</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://preccrep.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基本概念</title>
    <link href="https://preccrep.github.io/2021/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://preccrep.github.io/2021/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-23T00:04:28.000Z</published>
    <updated>2021-04-20T09:52:10.842Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络的定义</strong>：利用通信线路将地理上分散的、具有独立功能的计算机系统和通信设备按不同的形式连接起来，以功能完善的网络软件实现资源共享和信息传递的复合系统。</p><p><strong>网络的基本特征</strong>：</p><ol><li>具有共享能力</li><li>各计算机自治（计算机自成系统）</li><li>网络协议支持（管理、控制和通信）</li><li>支持互操作功能</li></ol><p><strong>资源子网</strong>是由各计算机系统、终端控制器和终端设备、软件和可供共享的数据库等组成。其功能是负责全网面向应用的数据处理工作，向用户提供数据处理能力、数据存储能力、数据管理能力和数据输入输出能力以及其它数据资源。</p><p><strong>网络资源</strong>：硬件资源、软件资源、数据资源。</p><p><strong>资源共享</strong>：是指网络系统中的各计算机用户可以利用网内其他计算机系统中的全部或部分资源的过程。它是网络的主要功能之一。</p><p><strong>通信子网</strong>是由通信硬件（通信设备和通信线路等）和通信软件组成，其功能是为网中用户共享各种网络资源提供必要的通信手段和通信服务。</p><p><strong>通信子网类型</strong>：结合型、公用型、专用型</p><p><strong>节点</strong>：就是由一条或多条通信线路连接的具有一定功能的设备。网络中的各主计算机、终端和通信设备等均可称为节点。网络节点有两类：访问节点和交换节点。</p><p><strong>广域网（WAN）</strong>：覆盖的范围大，如一个大城市、国家或洲际间建立的网络。</p><p><strong>局域网（LAN）</strong>：覆盖范围有限，属于一个部门或单位组建的小范围网络，是目前计算机网络发展中最活跃的分支。</p><p><strong>城域网（MAN）</strong>：是指建立在大城市、大都市区域的计算机网络，覆盖城市的大部分或全部地域。</p><p><strong>互联网</strong>：一般把由多个网络相互连接构成的复合网络称为互联网。互联网是不同网络的相互连接，如局域网和广域网连接、两个局域网相互连接或多个局域网通过广域网连接。</p><p><strong>虚拟局域网（VLAN）</strong>是指利用网络软件和网络交换技术将跨越不同地理位置的一个或多个物理网段上的相关用户组成的一个逻辑工作组（逻辑网络）。VLAN是依赖网络软件建立起的逻辑网络，相当部分的VLAN是临时性的。</p><p><strong>虚拟专用网（VPN）</strong>是指依靠Internet服务提供者(ISP)和其他网络服务提供者(NSP)在公共网络中建立的专用的数据通信网络。VPN可使用户利用公共网的资源将分散在各地的机构动态地连接起来，进行数据低成本的安全传输，这样既节省长途电话费用支出，又不再需要专用线路。</p><p><strong>主计算机（HOST）</strong>：与其他主计算机联网后构成网络中的主要资源。主计算机的作用：</p><ul><li>负责网络中的数据处理</li><li>执行网络协议</li><li>网络控制和管理</li><li>维护共享数据库</li></ul><p><strong>终端</strong>：用户访问网络的设备。终端的主要功能：</p><ul><li>[x] 把用户输入的信息转变为适合传送的信息送到网络上</li><li>[x] 把网络上其他节点输出并经过通信线路接收的数据转变为用户所能识别的信息</li></ul><p><strong>通信控制处理机（CCP）</strong>：也称通信控制器，在某些网络中也叫前端处理机（FEP）、接口信息处理机（IMP）等。</p><p><strong>CCP主要作用</strong>：承担通信控制和管理工作，减轻主机负担。</p><p>通信控制处理机是一种在计算机网络系统中执行通信控制与处理功能的专用计算机，通常由小型机或微型机担任。</p><p><strong>调制解调器（MODEM）</strong>：一种数据传输和信号转换设备。借助于调制解调器，就可以进行远距离通信，便于实现多路复用。</p><p><strong>多路复用器</strong>：具有多路复用功能。</p><p>利用多路复用器可以实现在一条物理链路上同时传输多路信号，提高信道利用率。</p><p><strong>集中器</strong>：用于在终端密集的地方，可以节省通信链路，提高线路利用率。集中器可由微型计算机或单片机担任。</p><p><strong>网络连接设备</strong>有：中继器、集线器及各种线路连接器等。</p><p><strong>网络互联设备</strong>有：网桥、路由器、交换机和网关等。</p><p><strong>网络操作系统（NOS）</strong>的主要作用：除了具有常规操作系统的功能外，还应有网络通信管理功能、网络范围内的资源管理功能和网络服务等。</p><p><strong>网络协议软件（Protocol）</strong>：网络协议软件是网络软件中最重要、最核心的部分。它是计算机网络中各部分通信所必须遵守的规则集合。</p><p><strong>计算机网络的特点</strong>：</p><ul><li>可靠性：当网内某子系统出现故障时，可由网内其他子系统代为处理，网络环境提供了高度的可靠性。</li><li>独立性：网络系统中各相连的计算机系统是相对独立的，它们各自既相互联系又相互独立。</li><li>高效率性：网络信息传递迅速，系统实时性强。网络系统可把一个大型复杂的任务分给几台计算机去处理，从而提高工作效率。</li><li>易扩充性：可以灵活地在网络中接入新的节点，如远程终端系统等，达到扩充网络系统功能的目的。</li><li>廉价性</li><li>透明性：网络用户所关心的是如何利用网络高效而可靠地完成自己的任务，而不去考虑网络所涉及的技术和具体工作过程。</li><li>易操作性</li></ul><p><strong>计算机网络的分类</strong>：</p><ul><li>[x] 按照覆盖范围划分：广域网、局域网、城域网</li><li>[x] 按照逻辑功能划分：资源子网、通信子网</li><li>[x] 按照传输介质划分：有线网、无线网</li><li>[x] 按照拓扑结构划分：星型网、总线型网、环形网、树形网、网型网</li><li>[x] 按照传输介质种类划分：双绞线网、同轴电缆网、光纤网、卫星网、微波网</li><li>[x] 按照应用范围和管理性质划分：公用网和专用网</li><li>[x] 按照交换方式划分：电路交换网、分组交换网、ATM交换网等</li><li>[x] 按照连接方式划分：全连通式网络、交换式网络、广播式网络</li></ul><p>网络体系结构是针对计算机网络所执行的各种功能而设计出的一种<strong>层次结构模型</strong>。</p><p>网络协议组成的三要素：</p><ul><li>语义：规定了通信双方要发出的控制信息、执行的动作和返回的应答等。</li><li>语法：规定通信双方彼此应该如何操作，即确定协议元素的形式。</li><li>时序：（也称定时、同步）是对事件实现顺序的详细说明，指出事件的顺序和速率匹配等，</li></ul><p>OSI七层模型：</p><ol><li><p>物理层：物理介质为数据链路层提供传输比特流的一个物理连接</p><p>主要任务：为通信双方的数据传输提供物理连接，并在物理连接上透明地传输比特流。传输单位是位（比特）。</p></li><li><p>数据链路层：检测并校正物理层传输介质上产生的传输差错，使两系统之间构成一条无差错的链路。</p></li><li><p>网络层：通信子网的最高层，用于控制和管理通信子网的操作。它体现了网络应用环境中资源子网访问通信子网的方式。网络层的数据传输单位是数据分组（包）。</p><p>主要任务：在数据链路服务的基础上，实现整个通信子网内的连接，向传输层提供端到端的数据传输链路，为报文分组以最佳路径通过通信子网到达目的主机提供服务。</p></li><li><p>传输层：OSI中1-3层面向数据通信，是由通信子网所完成的通信功能的集合，通信子网就是基于低三层通信协议构成的网络。5-7层是由端主机进程所完成的面向应用功能的集合。传输层是OSI中高层与低层之间的接口层。</p><p>对于网络中通信的两个主机，其端到端的可靠通信最后要靠传输层来完成。传输层是OSI中负责通信的最高层，是唯一总体负责数据传输和控制的层次。传输层还是OSI中用户功能的最低层。</p></li><li><p>会话层：利用传输层提供的端到端服务，向表示层提供它的增值服务。这种服务主要是向表示层实体或用户进程提供建立连接并在连接上有序地传输数据。</p></li><li><p>表示层：</p></li><li><p>应用层</p></li></ol><p>协议是计算机网络有序运行的重要保证。</p><p>硬件（主机、路由器、通信链路等）是计算机网络的基础。</p><p>计算机网络中的数据交换必须遵守约定好的规则。</p><p><strong>网络协议</strong>(network protocol)，简称<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准或约定。</p><p><strong>协议</strong>规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的”动作”(actions).</p><p><strong>协议的三要素</strong>：</p><ol><li>语法(syntax)<ul><li>数据与控制信息的结构或格式</li><li>信号电平</li></ul></li><li>语义(semantics)<ul><li>需要发出何种控制信息</li><li>完成何种动作以及做出何种响应</li><li>差错控制</li></ul></li><li>时序(timing)<ul><li>事件顺序</li><li>速度匹配</li></ul></li></ol><p>协议规范了网络中所有信息发送和接收过程。</p><p><strong>网络应用体系结构</strong></p><p>C/S结构、P2P结构、混合结构</p><p><strong>客户机/服务器结构</strong></p><p>服务器：</p><ol><li>7*24小时提供服务</li><li>永久性访问地址/域名</li><li>利用大量服务器实现可扩展性</li></ol><p>客户机：</p><ol><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不会与其他客户机直接通信</li></ol><p>服务器上运行web服务器软件，客户机上运行浏览器软件</p><p><strong>P2P结构</strong></p><p>没有永远在线的服务器</p><p>任意端系统/节点之间可以直接通讯</p><p>节点<strong>间歇性</strong>接入网络</p><p>节点可能改变IP地址</p><blockquote><p>优点：高度可伸缩</p><p>缺点：难于管理</p></blockquote><p><strong>混合结构</strong></p><p>Napster</p><p><strong>网络应用的基础：进程间通信</strong></p><p>进程：主机上运行的程序</p><p>同一主机上运行的进程之间如何通信？</p><ul><li>进程间通信机制</li><li>操作系统提供</li></ul><p>不同主机上运行的进程之间如何通信？</p><ul><li>消息交换</li></ul><p><strong>客户机进程</strong>：发起通信的进程</p><p><strong>服务器进程</strong>：等待通信请求的进程</p><p>不同主机之间进程的通信依靠套接字。这是操作系统提供的一种抽象接口，使其与网络硬件基础设施进行交互。例如寄信，你只需要把信件放在自己门外的信箱里，信箱就像是socket，邮政部门就是传输基础设施，负责将信件传送到接收方的信箱中，即接收方的socket。</p><p><strong>传输基础设施向进程提供API</strong>：传输协议的选择、参数的设置</p><p><strong>socket是操作系统提供的关于网络的API</strong></p><p><strong>如何寻址进程？</strong></p><p>不同主机上进程间通信，那么每个进程必须拥有<strong>标识符</strong></p><p>寻址主机——IP地址</p><p>寻址进程——端口号</p><p>为主机上每个需要通信的进程分配一个端口号：</p><p>HTTP Server：80</p><p>Mail Server：25</p><p>mac查看端口占用：<code>sudo lsof -i tcp:port</code></p><p>例如<code>sudo lsof -i tcp:80</code></p><p>于是，进程的标识符就是：IP地址+端口号</p><div class="table-container"><table><thead><tr><th>协议</th><th>本机IP:port</th><th>外部IP:port</th><th>状态</th></tr></thead><tbody><tr><td>TCP</td><td>192.168.0.100:49225</td><td>202.108.23.105:5287</td><td>ESTABLISHED</td></tr></tbody></table></div><p>应用层协议：</p><p>网络应用需遵循应用层协议</p><p>公开协议：</p><p>由RFC(Request For Comments)定义</p><p>允许互操作</p><p>HTTP, SMTP, …</p><p>私有协议：</p><p>多数P2P的文件共享应用</p><p><strong>应用层协议的内容</strong></p><p>消息的类型(type)：请求消息、响应消息</p><p>消息的语法(syntax)/格式：消息中有哪些字段(field)? 每个字段如何描述</p><p>字段的语义(semantics)：字段中信息的含义</p><p>规则(rules)：进程何时发送/响应消息、进程如何发送/响应消息</p><p>设计一个网络应用时，要么使用现有的网络协议，要么设计一个新的协议</p><p><strong>网络应用的需求与传输层服务</strong></p><p>网络应用对传输服务的需求：</p><ol><li>数据丢失(data loss)/可靠性(reliability)</li><li>时间(timing)/延迟(delay)</li><li>带宽(bandwidth)</li></ol><p><strong>Internet提供的传输服务</strong></p><p>TCP服务：</p><ol><li>面向连接：客户机/服务器进程间需要建立连接</li><li>可靠的传输</li><li>流量控制：发送方的发送速度不会过快，以至于超过接收方的处理能力</li><li>拥塞控制：当网络负载过重时，能够限制发送方的发送速度</li><li>不提供时间/延迟保障</li><li>不提供最小带宽保障</li></ol><p>UDP服务：</p><ol><li>不面向连接</li><li>不可靠传输</li><li>不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障</li></ol><p><strong>web与HTTP</strong></p><p>World Wide Web: 网页互相链接</p><p>网页包含多个对象</p><p>对象的寻址：URL(Uniform Resource Locator): 统一资源定位器 RFC1738</p><p>Scheme://host:port/path</p><p>www.someschool.edu/someDept/pic.gif</p><p>www.someschool.edu是host name, someDept/pic.gif是path name.</p><p><a href="http://被省略了(因为是默认">http://被省略了(因为是默认</a>).</p><p><strong>web遵守的应用层协议：HTTP</strong></p><p>超文本传输协议(HyperText Transfer Protocol)</p><p>HTTP使用TCP传输服务：</p><ul><li>服务器在80端口等待客户的请求</li><li>浏览器发起到服务器的TCP连接(创建socket)</li><li>服务器接受来自浏览器的TCP连接</li><li>浏览器(HTTP客户端)与web服务器(HTTP服务器)交换HTTP信息</li><li>关闭TCP连接</li></ul><p>HTTP是一个无状态的协议(stateless)：服务器不维护任何有关客户端过去所发送请求的信息。</p><p><strong>HTTP连接的两种类型</strong></p><ol><li><p>非持久性连接(Nonpersistent HTTP)</p><p>每个TCP连接最多允许传输一个对象</p><p>HTTP 1.0版本使用非持久性连接</p></li><li><p>持久性连接(Persistent HTTP)</p><p>每个TCP连接允许传输多个对象</p><p>HTTP 1.1版本默认使用非持久性连接</p></li></ol><p>socket编程——应用编程接口(Application Programming Interface, API)——位于应用层和传输层之间</p><p>socket将应用层的数据交给传输层</p><p><strong>应用编程接口API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。</strong></p><p>标识一个套接字(对外)：IP地址+端口号</p><p>操作系统/进程如何管理套接字(对内)？</p><ul><li>套接字描述符(socket descriptor)</li></ul><p>即，操作系统在管理其内部创建的socket套接字的时候，使用套接字描述符来标识的</p><ol><li><p>socket抽象类似于文件的抽象，在UNIX中，套接字就是一种特殊的文件(一切皆文件！)</p></li><li><p>当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息。</p></li><li>最后返回的是套接字描述符。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;网络的定义&lt;/strong&gt;：利用通信线路将地理上分散的、具有独立功能的计算机系统和通信设备按不同的形式连接起来，以功能完善的网络软件实现资源共享和信息传递的复合系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络的基本特征&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;l</summary>
      
    
    
    
    <category term="笔记" scheme="https://preccrep.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://preccrep.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑基础</title>
    <link href="https://preccrep.github.io/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://preccrep.github.io/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/</id>
    <published>2021-02-18T01:25:11.000Z</published>
    <updated>2021-02-22T06:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>物理量有两种表示方法：<strong>模拟表示法</strong>、<strong>数字表示法</strong></p><p>模拟量和数字量的主要区别：模拟量=连续，数字量=离散</p><p><strong>数字系统</strong>是用来处理逻辑信息或以数字形式表示的物理量的器件组合，即其数值只能取离散值。或称是<code>有一组或几种基本的标准逻辑门来构成的复杂的、使用数字量来传递和加工、处理信息的实际工程系统</code>。</p><p>最常见的数字系统：计算机、数字音像及世界上最大的数字系统——手机电话系统</p><p><strong>数字逻辑电路</strong>是以逻辑门为基本单元构成的复杂的数字系统中的硬件部分。</p><p><strong>逻辑门</strong>：以能完成<code>独立逻辑功能</code>的一组电子元件和器件所组成的线路。</p><p><strong>模拟系统</strong>所包含的装置能处理以模拟形式表示的物理量。</p><blockquote><p>数字技术的优点：易设计、信息存储方便、操作可编程、数字电路抗干扰能力强、多数数字电路能制造在IC芯片上</p><p>数字技术的缺点：</p><ol><li>由于必须在信息的模拟形式与数字形式之间进行转换，从而增加了系统的复杂性和费用；</li><li>数字（二进制数）信号的处理需要时间。所需要的数据越精确，处理时间越长。</li></ol></blockquote><p>当涉及到模拟输入、输出时，为了利用数字技术的优点，必须采用下面3步：</p><ol><li>把实际中的模拟输入转换为数字形式；</li><li>数字信息处理；</li><li>把数字输出变换为模拟输出。</li></ol><p>原则：随着信号在系统中的流动，在输入通道中尽可能早地把信号数字化，在输出通道中尽可能晚地把信号转换为模拟信号。</p><h1 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h1><h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>不同进位计数制的数值具有等值关系：</p><script type="math/tex; mode=display">N=N_{10}=(N)_{10}=N_S=(M)_S=N_T=(K)_T</script><p>其中M是十进制数N的S进制形式，K是N的T进制形式。</p><p>也就是说，加了括号的括号内一定是转换数制后的数，不加括号就是原来的十进制数。例如：</p><script type="math/tex; mode=display">13=(13)_{10}=13_8=(15)_8=(1101)_2</script><p>数值转换时小数位数的确定：</p><script type="math/tex; mode=display">\alpha 进制的小数有k位，转换为\beta进制后，至少具有相同精度的小数是j位，则(0.1)_{\alpha}^k \geq (0.1)_{\beta}^j.</script><script type="math/tex; mode=display">在十进制中可表示为：(\frac{1}{\alpha})^k \geq (\frac{1}{\beta})^j.</script><script type="math/tex; mode=display">即：\alpha^k \leq \beta^j</script><script type="math/tex; mode=display">两边取对数：\log\alpha^k \leq \log\beta^j，即k\log\alpha \leq j\log\beta</script><script type="math/tex; mode=display">得到：j \geq k\frac{\log\alpha}{\log\beta}</script><script type="math/tex; mode=display">则j满足的不等式条件为：k\frac{\log\alpha}{\log\beta} \leq j < k\frac{\log\alpha}{\log\beta}+1</script><h2 id="数的表示和运算"><a href="#数的表示和运算" class="headerlink" title="数的表示和运算"></a>数的表示和运算</h2><p>计算机中表示小数点位置的方法通常有两种：定点表示法和浮点表示法。</p><h3 id="定点表示法"><a href="#定点表示法" class="headerlink" title="定点表示法"></a>定点表示法</h3><p>小数点位置固定，一般固定在数的最高位之前或最低位之后。</p><h3 id="浮点表示法"><a href="#浮点表示法" class="headerlink" title="浮点表示法"></a>浮点表示法</h3><p>例如，二进制数101.1和10.11可表示为：</p><script type="math/tex; mode=display">101.1=(10)^{11}\times0.1011</script><script type="math/tex; mode=display">10.11=(10)^{10}\times0.1011</script><p>其中10和11是二进制数，转换为十进制就是2和3.</p><p>因此，这两个二进制数可以用<strong>阶码</strong>和<strong>尾数</strong>表示：</p><script type="math/tex; mode=display">101.1\rightarrow11, 0.1011</script><script type="math/tex; mode=display">10.11\rightarrow10, 0.1011</script><p>这就是浮点表示法。表示时需要将一个字长划分为两部分，分别用来表示阶码和尾数，<strong>两个部分的最高位分别为各自的符号位</strong>。</p><p>例如，规定一个16位字长的前5位表示阶码，后11位表示尾数：</p><p><code>0    0011        0    1011000000</code></p><p><code>0    0010        0    1011000000</code></p><p><strong>原码</strong>：符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。</p><p>因为第一位是符号位, 所以8位二进制数的取值范围就是[-127, 127]</p><p><strong>反码</strong>：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p><strong>补码</strong>：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1（即在反码的基础上+1）。</p><p>一篇可参考的博客：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">戳这</a></p><h3 id="可靠性编码"><a href="#可靠性编码" class="headerlink" title="可靠性编码"></a>可靠性编码</h3><p>目的：解决代码在形成或传输过程中可能会发生的错误，提高系统的安全性</p><p>方法：使代码自身具有一种特征或能力</p><h4 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h4><p>任意两个相邻数的代码只有一位二进制数不同</p><blockquote><p>格雷码(Gray code)是1880年由法国工程师Jean-Maurice-Emlle Baudot发明的一种编码，是一种绝对编码方式，典型格雷码是一种具有反射特性和循环特性的单步自补码，它的循环、单步特性消除了随机取数时出现重大误差的可能，它的反射、自补特性使得求反非常方便。格雷码属于可靠性编码，是一种错误最小化的编码方式，因为，虽然自然二进制码可以直接由数/模转换器转换成模拟信号，但在某些情况，例如从十进制的3转换为4时二进制码的每一位都要变，能使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它在相邻位间转换时，只有一位产生变化。它大大地减少了由一个状态到下一个状态时逻辑的混淆。由于这种编码相邻的两个码组之间只有一位不同，引起数字量发生变化时，格雷码仅改变一位，这样与其它编码同时改变两位或多位的情况相比更为可靠，即可减少出错的可能性。</p></blockquote><p> 格雷码是一个数列集合，相邻两数间只有一个位元改变，为无权数码，且格雷码的顺序不是唯一的。</p><p>例如以下为3位元的格雷码： 000 001 011 010 110 111 101 100 。</p><p>如果要产生n位元的格雷码，那么格雷码的个数为$2^n$.</p><p>假设原始的值从0开始，格雷码产生的规律是：</p><p>第一步，改变最右边的位元值；</p><p>第二步，改变右起第一个为1的位元的左边位元；</p><p>第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了$2^n -1$步）。</p><p>用一个例子来说明：</p><p>假设产生3位元的格雷码，原始值位 000</p><p>第一步：改变最右边的位元值： 001</p><p>第二步：改变右起第一个为1的位元的左边位元： 011</p><p>第三步：改变最右边的位元值： 010</p><p>第四步：改变右起第一个为1的位元的左边位元： 110</p><p>第五步：改变最右边的位元值： 111</p><p>第六步：改变右起第一个为1的位元的左边位元： 101</p><p>第七步：改变最右边的位元值： 100</p><p>如果按照这个规则来生成格雷码，是没有问题的，但是这样做太复杂了。如果仔细观察格雷码的结构，我们会有以下发现：</p><ol><li><p>除了最高位（左边第一位），格雷码的位元完全上下对称（看下面列表）。比如第一个格雷码与最后一个格雷码对称（除了第一位），第二个格雷码与倒数第二个对称，以此类推。</p></li><li><p><strong>最小的重复单元是 0 , 1</strong>。</p></li></ol><blockquote><p>0<strong>00</strong></p><p>0<strong>01</strong></p><p>…</p><p>1<strong>01</strong></p><p>1<strong>00</strong></p></blockquote><p>所以，在实现的时候，我们完全可以利用递归，在每一层前面加上0或者1，然后就可以列出所有的格雷码。</p><p>比如：</p><p>第一步：产生 0, 1 两个字符串。</p><p>第二步：在第一步的基础上，每一个字符串都加上0和1，但是每次只能加一个，所以得做两次。这样就变成了 00,01,11,10 （注意对称）。</p><p>第三步：在第二步的基础上，再给每个字符串都加上0和1，同样，每次只能加一个，这样就变成了 000,001,011,010,110,111,101,100。</p><p>好了，这样就把3位元格雷码生成好了。</p><p>如果要生成4位元格雷码，我们只需要在3位元格雷码上再加一层0,1就可以了： 0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1110,1010,0111,1001,1000.</p><p>也就是说，<em>n位元格雷码是基于n-1位元格雷码产生的</em>。</p><p><strong>格雷码和自然二进制码之间的转换方法</strong></p><p>自然二进制码转换成二进制格雷码，其法则是保留自然二进制码的最高位作为格雷码的最高位，而次高位格雷码为二进制码的高位与次高位相异或，而格雷码其余各位与次高位的求法相类似。</p><p><strong>原理:</strong> 若二进制码表示为：<code>B[N-1]B[N-2]...B[2]B[1]B[0]</code>；</p><p>则二进制格雷码表示为：<code>G[N-1]G[N-2]...G[2]G[1]G[0]</code>.</p><p>其中最高位保留：<code>G[N-1] = B[N-1]</code>；</p><p>其他各位：<code>G[i] = B[i+1] xor B[i]. (i = 0, 1, 2, ..., n-2)</code></p><p><strong>格雷码转换为二进制码的实现方法</strong></p><p>二进制格雷码转换成自然二进制码，其法则是保留格雷码的最高位作为自然二进制码的最高位，而次高位自然二进制码为高位自然二进制码与次高位格雷码相异或，而自然二进制码的其余各位与次高位自然二进制码的求法相类似。</p><p><strong>原理:</strong> 若二进制格雷码表示为：<code>G[N-1]G[N-2]...G[2]G[1]G[0]</code>；</p><p>相应地, 则二进制码表示为：<code>B[N-1]B[N-2]...B[2]B[1]B[0]</code>.</p><p>其中最高位保留：<code>B[N-1] = G[N-1]</code>；</p><p>其他各位：<code>B[i-1] = G[i-1] xor B[i]. (i = 1, 2, ..., n-1)</code></p><p>算法实现：<a href="https://www.cnblogs.com/0201zcr/p/4796950.html">参考链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] GrayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n)];</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] b = GrayCode(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        arr[i] = <span class="string">&quot;0&quot;</span> + b[i];</span><br><span class="line">        arr[arr.length - <span class="number">1</span> - i] = <span class="string">&quot;1&quot;</span> + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] GrayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n);</span><br><span class="line">    String[] s1 = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">        String[] si = <span class="keyword">new</span> String[p];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; p/<span class="number">2</span>)</span><br><span class="line">                si[j] = <span class="string">&quot;0&quot;</span> + s1[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                si[j] = <span class="string">&quot;1&quot;</span> + s1[p - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>典型格雷码</strong>（0~15）还有一个特点：所有对应于十进制数$2^m-1$的格雷码，都仅在m位上有1，其余位都为0.</p><p>例如：m=1，1的典型格雷码为0001；m=2，3的典型格雷码为0010；m=3，7的典型格雷码为0100；m=4，15的典型格雷码为1000.</p><p>15与0的格雷码仍能保持一位差别，所以这种典型格雷码也称作循环码，适用于做二进制码计数器。</p><p><strong>十进制格雷码</strong>（0~9）：代码特征符合格雷码要求，且16选10，使得9到0也只有一位的差别，保持循环码特点。</p><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><p>参考博客：<a href="https://www.cnblogs.com/FZfangzheng/p/8519791.html">戳这</a></p><p><strong>奇偶校验码</strong></p><p>参考博客1：<a href="https://www.cnblogs.com/dushikang/p/8334776.html">戳这</a></p><p>参考博客2：<a href="https://blog.csdn.net/qq_44574333/article/details/108927425">戳这</a></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV1BE411D7ii?from=search&amp;seid=6420326887479343502">戳这</a></p><blockquote><p>问题：</p><ul><li>奇偶校验码能发现单错，但不能对单错定位；</li><li>奇偶校验码不能发现双错.</li></ul></blockquote><p><strong>海明校验码</strong></p><p>参考博客1：<a href="https://blog.csdn.net/coolskyying/article/details/78963550">戳这</a></p><p>参考博客2：<a href="https://my.oschina.net/u/3374461/blog/1931270">戳这</a></p><p>海明码（Hamming Code）是利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的确定位置插入k个校验位，通过扩大码距来实现检错和纠错。对于m位的数据，加入k位的校验码，它应满足：$m+k+1&lt;2^k$.</p><h1 id="逻辑代数"><a href="#逻辑代数" class="headerlink" title="逻辑代数"></a>逻辑代数</h1><ol><li><p>布尔代数：用一种数学运算来描述人的逻辑思维规律和推理过程的代数系统.</p></li><li><p>逻辑代数：将布尔代数的一些基本前提和定理应用于继电器电路的分析与描述。即开关代数，也就是二值布尔代数.</p></li><li><p>逻辑变量：用于表示事物的逻辑状态随逻辑条件的变化而变化的量，取值：0或1.</p></li><li><p>逻辑常量：逻辑状态保持不变，值为0或1.</p></li><li><p>逻辑电路：由实现逻辑变量之间逻辑关系的物理器件所构成的电路称为逻辑电路，即二值逻辑电路.</p></li><li><p>逻辑电平：在二值逻辑电路即开关电路中，将物理器件的物理量离散为两种电平.</p><blockquote><p>噪音区：在高、低电平之间有一逻辑不确定区。若电平稳定于噪音区称为逻辑模糊，这在逻辑电路中不允许。</p><p>一般用H表示高电平，用L表示的低电平</p><p>抽象化的高、低电平忽略了其物理量值的实际含义，实际上它们是代表着一定范围的物理量。</p></blockquote></li><li><p>逻辑状态：事物的某些特性表现为两种互不相容的状态，即<br>① 某一时刻必出现且仅出现一种状态；<br>② 一种状态是另一种状态的反状态.</p><p>用0、1表示，两种状态无大小之分.</p></li><li><p>逻辑约定：规定逻辑电平（表示物理器件的物理量）与逻辑状态（表示物理器件的功能）之间的关系，即逻辑规定。这一规定的过程称为逻辑化过程。<br>逻辑规定有两种：正逻辑规定和负逻辑规定。</p></li><li><p>逻辑函数：输入逻辑变量 $A_1, A_2, …, A_n$，输出逻辑变量F，记为 $F = f(A_1, A_2, …, A_n)$。</p><p>逻辑函数的表示法：真值表、逻辑表达式、卡诺图、时间图</p></li></ol><h2 id="逻辑代数的运算"><a href="#逻辑代数的运算" class="headerlink" title="逻辑代数的运算"></a>逻辑代数的运算</h2><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>”与“运算（逻辑乘，Logic Multiplication），运算结果是逻辑积（Logic Product）</p><div class="table-container"><table><thead><tr><th></th><th>”与“运算（逻辑乘, Logic Multiplication）</th><th>”或“运算（逻辑加, Logic Addition）</th><th>”非“运算（逻辑乘, Logic Negation）</th></tr></thead><tbody><tr><td>运算结果</td><td>逻辑积(Logic Product)</td><td>逻辑和(Logic Sum)</td><td>求补(Complement)</td></tr><tr><td>代数式</td><td>$F=A\times B=A\cdot B$</td><td>$F=A+B$</td><td>$F=\overline{A}$</td></tr></tbody></table></div><h3 id="逻辑代数的基本公理"><a href="#逻辑代数的基本公理" class="headerlink" title="逻辑代数的基本公理"></a>逻辑代数的基本公理</h3><p><strong>0-1律</strong></p><blockquote><p>$A+0=A$</p><p>$A+1=1$</p><p>$A\cdot 1=A$</p><p>$A\cdot 0=0$</p></blockquote><p>与、或运算满足交换律、结合律、分配律。</p><p>互补律：$A+\overline{A}=1$, $A\cdot \overline{A}=0$</p><p>重叠律：$A+A=A$, $A\cdot A=A$</p><p>对合律：$\overline{\overline{A}}=A$</p><h3 id="逻辑代数的基本定理"><a href="#逻辑代数的基本定理" class="headerlink" title="逻辑代数的基本定理"></a>逻辑代数的基本定理</h3><p><strong>吸收定理</strong></p><blockquote><p>$A+AB=A$</p><p>$A\cdot (A+B)=A$</p><p>$A+\overline{A} \cdot B=A+B$</p><p>$A\cdot (\overline{A}+B)=A\cdot B$</p><p>$A\cdot B+A\cdot \overline{B}=A$</p><p>$(A+B)(A+\overline{B})=A$</p></blockquote><p><strong>反演定理</strong></p><blockquote><p>$\overline{A_1+A_2+\dots +A_n}=\overline{A_1}\cdot \overline{A_2}\cdot \dots \overline{A_n}$</p><p>$\overline{A_1\cdot A_2\cdot \dots \cdot A_n}=\overline{A_1}+ \overline{A_2}+ \dots \overline{A_n}$</p></blockquote><p><strong>包含定理(多余项定理)</strong></p><script type="math/tex; mode=display">AB+\overline{A} C+BC=AB+\overline{A} C</script><script type="math/tex; mode=display">(A+B)(\overline{A}+C)(B+C)=(A+B)(\overline{A}+C)</script><blockquote><p>证明：$AB+\overline{A} C+BC=AB+\overline{A} C$</p><script type="math/tex; mode=display">AB+\overline{A} C+BC=(A+C)B+\overline{A}C=(A+\overline{A}C)B+\overline{A}C=AB+\overline{A}C(B+1)=AB+\overline{A}C\cdot 1=AB+\overline{A}C</script></blockquote><h3 id="逻辑代数的基本规则"><a href="#逻辑代数的基本规则" class="headerlink" title="逻辑代数的基本规则"></a>逻辑代数的基本规则</h3><p><strong>代入规则</strong></p><p>已知 $f(x_1,x_2,\dots ,x_i,\dots ,x_n)=g(x_1,x_2,\dots ,x_i,\dots ,x_n)$，有任意函数h，令$x_i=h$，则 $f(x_1,x_2,\dots ,h,\dots ,x_n)=g(x_1,x_2,\dots ,h,\dots ,x_n)$依然成立。</p><blockquote><p>证明：</p><script type="math/tex; mode=display">\because x_i\in \{0,1\}且逻辑函数h取值仅有0或1</script><script type="math/tex; mode=display">\therefore 带入规则成立</script></blockquote><p>可以用带入规则证明N变量的德摩根定理。</p><p><strong>反演规则</strong></p><p>已知原函数 $f(x_1,x_2,\dots ,x_n,0,1,+,\cdot)$，则反函数 $\overline{f}(x_1,x_2,\dots ,x_n,0,1,+,\cdot)=f(\overline{x_1},\overline{x_2},\dots ,\overline{x_n},1,0,\cdot ,+)$</p><p><strong>对偶规则</strong></p><p>已知原函数 $f(x_1,x_2,\dots ,x_n,0,1,+,\cdot)$，则对偶函数 $f’(x_1,x_2,\dots ,x_n,0,1,+,\cdot)=f(x_1,x_2,\dots ,x_n,1,0,\cdot ,+)$</p><p>如果原函数相等，则对偶函数也相等。</p><h3 id="复合运算"><a href="#复合运算" class="headerlink" title="复合运算"></a>复合运算</h3><p><strong>与非（NAND）</strong>：$F=\overline{A\cdot B\cdot C}$</p><p>可以用与非门实现三种基本运算：</p><p>与运算：$F_1=A\cdot B=\overline{\overline{A\cdot B}}$</p><p>非运算：$F_2=\overline{A\cdot A}=\overline{A}$</p><p>或运算：$F_3=\overline{\overline{A\cdot A}\cdot \overline{B\cdot B}}=\overline{\overline{A}\cdot \overline{B}}=A+B$</p><p><strong>或非（NOR）</strong>：$F=\overline{A+B+C}$</p><p>可以用或非门实现三种基本运算：</p><p>与运算：$F_1=\overline{\overline{A+A}+\overline{B+B}}=\overline{\overline{A}+\overline{B}}=A\cdot B$</p><p>非运算：$F_2=\overline{A+A}=\overline{A}$</p><p>或运算：$F_3=\overline{\overline{A+B}}$</p><p><strong>与或非（AOI）</strong>：$F=\overline{AB+CD+EF}$</p><p><strong>异或（XOR）</strong>：$F=A\oplus B=\overline{A}\cdot B+A\cdot \overline{B}$</p><p><strong>同或（XNOR）</strong>：$F=A\odot B=A\cdot B+\overline{A}\cdot\overline{B}$</p><blockquote><p>异或和同或的关系：</p><p>$\overline{A\oplus B}=A\odot B$        $\overline{A\odot B}=A\oplus B$</p><p>$(A\oplus B)‘=A\odot B$        $(A\odot B)‘=A\oplus B$（用对偶函数的运算性质证明）</p><p>$A\oplus B\oplus C=A\odot B\odot C$</p><p>证明  $(A\oplus B)‘=A\odot B$</p><script type="math/tex; mode=display">(A\oplus B)'=(\overline{A}\cdot B+A\cdot\overline{B})'=(\overline{A}+B)\cdot(A+\overline{B})=AB+\overline{A}\overline{B}=A\odot B</script></blockquote><p>由带入规则可以证明：</p><p>当变量<strong>n为偶数</strong>时，XOR和XNOR具有互补关系：</p><script type="math/tex; mode=display">A_1\oplus A_2\oplus\dots\oplus A_n=\overline{A_1\odot A_2\odot\dots\odot A_n}</script><p>当变量<strong>n为奇数</strong>时，XOR和XNOR具有相等关系：</p><script type="math/tex; mode=display">A_1\oplus A_2\oplus\dots\oplus A_n=A_1\odot A_2\odot\dots\odot A_n</script><h2 id="逻辑函数的标准形式"><a href="#逻辑函数的标准形式" class="headerlink" title="逻辑函数的标准形式"></a>逻辑函数的标准形式</h2><p><strong>最小项之和</strong>：乘积项之和称为<em>积之和表达式（SOP）</em>，或称<em>与或表达式</em>。如果构成函数的积之和表达式中每一个与项均为最小项时，称为最小项标准式，且这种表示是唯一的。</p><p><strong>最大项之积</strong>：和项之积称为<em>和之积表达式（POS）</em>，或称<em>或与表达式</em>。如果构成函数的和之积表达式中每一个和项均为最大值，称为最大项标准式，且这种表示是唯一的。</p><p><strong>最小项minterm</strong>：设有n个变量，它们组成的与项中每个变量或以原变量或以反变量形式出现一次，且仅出现一次，此与项称之为n个变量的最小项。对于n个变量就可构成 $2^n$ 个最小项，记为 $m_i$.<br>其中下标值i：当各最小项变量按一定顺序排好后，用1代替其中的原变量，0代替其中的反变量，便得一个二进制数，该二进制数的等值十进制即为i的值。</p><p>例如$\overline{A}B\overline{C}=m_{(010)_2}=m_2$</p><p>为了区别不同n值对应的相同的 $m_i$，可记为 $m_i^n$.</p><p><strong>最大项maxterm</strong>：与最小项相反，用0代替原变量，1代替反变量，例如：$\overline{A}+B+\overline{C}=M_5$</p><p><strong>性质</strong>：</p><ol><li><p>对于任意最小项，只有一组变量组合取值可使其值为1；对于任意最大项，只有一组变量组合取值可使其值为0.</p></li><li><script type="math/tex; mode=display">n变量的所有最小项的和必为1，记为\sum_{i=0}^{2^n-1} m_i=1.</script><script type="math/tex; mode=display">n变量的所有最大项的积必为0，记为\prod_{i=0}^{2^n-1} M_i=0.</script></li><li><p>任意两个最小项之积必为0，即：$m_i\cdot m_j=0, i\neq j$.</p><p>任意两个最大项之和必为1，即：$M_i+M_j=1, i\neq j$.</p></li><li><p>同变量数（n相同）下标相同的最小项和最大项互为反函数，即 $m_i=\overline{M_i}$，$M_i=\overline{m_i}$.</p><p>则 $m_i\cdot M_i=0$，$m_i+M_i=1$.</p></li></ol><p><strong>最小项与原、反函数的关系</strong>：对于n个变量的函数F，它共有 $2^n$ 个最小项，这些最小项不是包含在原函数 $F$ 的最小项表达式中，就是包含在反函数 $\overline{F}$ 的最小项表达式中。</p><p><strong>最大项与原、反函数的关系</strong>：对于n个变量的函数F，它共有 $2^n$ 个最大项，这些最大项不是包含在原函数 $F$ 的最大项表达式中，就是包含在反函数 $\overline{F}$ 的最大项表达式中。</p><p><strong>同一函数的最小项标准式与其最大项标准式的关系</strong>：</p><script type="math/tex; mode=display">F=\sum m^3(0,2,3)=\prod M^3(1,4,5,6,7)</script><blockquote><p>证明：设 $F=\sum m^3(0,2,3)$，则</p><script type="math/tex; mode=display">\overline{F}=\sum m^3(1,4,5,6,7)=m_1+m_4+m_5+m_6+m_7</script><script type="math/tex; mode=display">F=\overline{\overline{F}}=\overline{m_1+m_4+m_5+m_6+m_7}=M_1\cdot M_4\cdot M_5\cdot M_6\cdot M_7=\prod M^3(1,4,5,6,7)</script></blockquote><p><strong>卡诺图</strong></p><p>卡诺图是一种<em>平面方格阵列图</em>：</p><p>行和列按变量的组合标注，其变量顺序按真值表中输入变量从左至右的顺序，并且行与列坐标按变量组合的二进制格雷码的顺序而小方格左上角标注可用十进制数表示，该数对应最小项。</p><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/31649253">戳这</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;物理量有两种表示方法：&lt;strong&gt;模拟表示法&lt;/strong&gt;、&lt;strong&gt;数字表示法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模拟量和数字</summary>
      
    
    
    
    <category term="数字逻辑与数字系统" scheme="https://preccrep.github.io/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="数字逻辑" scheme="https://preccrep.github.io/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Note for Computer Networking, Chapter I</title>
    <link href="https://preccrep.github.io/2021/02/10/I/"/>
    <id>https://preccrep.github.io/2021/02/10/I/</id>
    <published>2021-02-10T12:19:16.000Z</published>
    <updated>2021-02-16T15:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-the-Internet"><a href="#What-is-the-Internet" class="headerlink" title="What is the Internet"></a>What is the Internet</h1><blockquote><p>主机（host）和端系统（end system）有什么区别？列举几种不同类型的端系统。Web服务器是一种端系统吗？</p></blockquote><p>没有不同，只是两种不同的叫法。<br>智能手机、电脑、电视、WEB服务器、游戏机等等。<br>如上所述，WEB服务器也是一种端系统。</p><h2 id="从硬件和软件组件的角度描述因特网"><a href="#从硬件和软件组件的角度描述因特网" class="headerlink" title="从硬件和软件组件的角度描述因特网"></a>从硬件和软件组件的角度描述因特网</h2><blockquote><p>端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起</p></blockquote><p><strong>通信链路</strong>有许多类型，它们由不同类型的物理媒体组成。这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输数据，链路的<strong>传输速率</strong>（transmission rate）以比特/秒（bit/s, or bps）度量。当一台端系统要向另一台端系统发送数据时，<em>发送端系统（sending end system）</em>将数据分段，并为每段加上首部字节（When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment.）。由此形成的信息包成为<strong>分组</strong>（packet）。这些分组通过网络发送到<em>目的端系统（destination end system）</em>，在那里被装配成初始数据。</p><p><strong>分组交换机</strong>从它的一条<em>入通信链路（incoming communication links）</em>接收到达的分组，并从它的一条<em>出通信链路（outgoing communication links）</em>转发该分组。分组交换机类型很多，最著名的是<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。</p><p>链路层交换机通常用于<em>接入网（access networks）</em>中，而路由器通常用于<em>网络核心（network core）</em>中。</p><p>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机成为通过该网络的<strong>路径</strong>（route or path）。</p><blockquote><p>泽字节：zettabyte，10^21字节</p></blockquote><p>端系统通过<strong>因特网服务提供商</strong>（Internet Service Provider, ISP）接入因特网。较低层的ISP通过国家的、国际的较高层ISP（如Level 3 Communications、AT&amp;T、Sprint和NTT）互联起来。较高层ISP是由通过高速光纤链路互联的高速路由器组成的。无论是较高层还是较低层ISP网络，它们每个都是独立管理的，运行着IP协议（详情见后），遵从一定的命名和地址规则。</p><p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），这些协议控制因特网中信息的接收和发送。<strong>TCP</strong>（Transmission Control Protocol，传输控制协议）和<strong>IP</strong>（Internet Protocol，网际协议）是因特网中两个最为重要的协议。</p><p>IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p><p><strong>因特网标准</strong>（Internet standard）由因特网工程任务组（Internet Engineering Task Force, IETF）研发。IETF的标准文档称为<strong>请求评论</strong>（Request For Comment, RFC）。RFC最初只是普通的请求评论（因此而得名），目的是解决因特网先驱者们面临的网络和协议问题。RFC文档往往是技术性很强并相当详细的。它们定义了TCP、IP、HTTP（用于Web）和SMTP（用于电子邮件）等协议。</p><h2 id="从为应用程序提供服务的基础设施的角度描述因特网"><a href="#从为应用程序提供服务的基础设施的角度描述因特网" class="headerlink" title="从为应用程序提供服务的基础设施的角度描述因特网"></a>从为应用程序提供服务的基础设施的角度描述因特网</h2><blockquote><p>涉及多个相互交换数据的端系统的的应用程序称为<strong>分布式应用程序</strong>（distributed application）。</p><p>因特网应用程序运行在端系统上，即它们并不运行在网络核心中的分组交换机中。分组交换机能够加速端系统之间的数据交换，并不在意应用程序。</p><p>运行在一个端系统上的应用程序如何让因特网向运行在另一个端系统上的软件发送数据？</p><p>与因特网相连的端系统提供了一个<strong>套接字接口</strong>（socket interface），该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。</p></blockquote><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><strong>协议</strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事物所采取的动作。</p><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>端系统位于因特网的边缘，包括桌面计算机、服务器（Web和电子邮件）和移动计算机。</p><p>端系统也称为主机，因为它们容纳（即运行）应用程序，如Web浏览器程序、Web服务器程序、电子邮件客户程序或电子邮件服务器程序等。</p><p>主机有时又被进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。客户通常是桌面PC、移动PC和智能手机等；服务器通常是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等。如今大部分提供搜索结果、电子邮件、Web页面和视频的服务器都属于大型<strong>数据中心</strong>（data center）。</p><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网是将端系统物理连接到其<strong>边缘路由器</strong>（edge router）的网络。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p><h4 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h4><p>宽带住宅接入有两种最流行的类型：<strong>数字用户线</strong>（Digital Subscriber Line, DSL）和<strong>电缆</strong>。住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。例如，每个用户的DSL调制解调器使用现有的电话线（即双绞铜线）与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的DSL调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在DSLAM处被转换回数字形式。</p><p>家庭电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码：</p><ul><li>高速下行信道，位于50kHz到1MHz频段；</li><li>中速上行信道，位于4kHz到50kHz频段；</li><li>普通的双向电话信道，位于0到4kHz频段.</li></ul><p>这种方法使单根DSL线路看起来就像有3根单独的线路一样，因此一个电话呼叫和一个因特网连接能够同时共享DSL线路。在用户一侧，一个分配器把到达家庭的数据信号和电话信号分隔开，并将数据信号转发给DSL调制解调器。在电话公司一侧，在CO中，DSLAM把数据和电话信号分隔开，并将数据送往因特网。数百甚至上千个家庭与同一个DSLAM相连。</p><p>DSL利用电话公司现有的本地电话基础设施，而<strong>电缆因特网接入</strong>（cable Internet access）利用了有线电视公司现有的有线电视基础设施。住宅从提供有线电视的公司获得了电缆因特网接入。</p><p>在<strong>混合光纤同轴</strong>（Hybrid Fiber Coax, HFC）系统中，光缆将电缆头端连接到地区枢纽，从这里使用传统的同轴电缆到达各家各户和公寓。</p><p>电缆因特网接入需要特殊的调制解调器，称为<em>电缆调制解调器（cable modem）</em>。</p><p>电缆因特网接入的一个重要特征是共享广播媒体。</p><p>还有一种更高速率的接入方式是<strong>光纤到户</strong>（Fiber To The Home, FTTH），即从本地中心局直接到家庭连一条光线路径。</p><h3 id="企业（和家庭）接入：以太网和WiFi"><a href="#企业（和家庭）接入：以太网和WiFi" class="headerlink" title="企业（和家庭）接入：以太网和WiFi"></a>企业（和家庭）接入：以太网和WiFi</h3><p>使用局域网（LAN）将端系统连接到边缘路由器。</p><p>以太网用户使用双绞铜线与一台以太网交换机相连，以太网交换机或这样相连的交换机网络，则再与更大的因特网相连。</p><h3 id="广域无线接入：3G和LTE"><a href="#广域无线接入：3G和LTE" class="headerlink" title="广域无线接入：3G和LTE"></a>广域无线接入：3G和LTE</h3><p>电信公司已经在所谓第三代（3G）无线技术中进行了大量投资，3G为分组交换广域无线因特网接入提供了超过1Mbps的速率。甚至更高速率的广域接入技术即第四代（4G）广域无线网络也已经被部署了。</p><p>LTE（长期演进，Long-Term Evolution）来源于3G技术，它能够取得超过10Mbps的速率。</p><h2 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h2><blockquote><p>前面提到的物理媒体：</p><p>HFC使用光缆和同轴电缆，DSL和以太网使用双绞铜线，移动接入网使用无线电频谱</p></blockquote><p>对于每个发射器-接收器对，通过跨越一种<strong>物理媒体</strong>（physical medium）传播电磁波或光脉冲来发送该比特。该物理媒体可具有多种形状和形式，并且对沿途的每个发射器-接收器对不必具有相同的类型。</p><blockquote><p>物理媒体分为<strong>导引型媒体</strong>（guided media）和<strong>非导引型媒体</strong>（unguided media）。对于导引型媒体，电波沿着固体媒体前行，如光缆、双铜绞线或同轴电缆。对于非引导型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中。</p></blockquote><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心是由互联因特网端系统的分组交换机和链路构成的网状网络。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>（store-and-forward transmission）机制。</p><blockquote><p>在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p></blockquote><p>该分组的比特缓存在路由器中，直到该分组的所有比特全部到达路由器才会向目的地传输。</p><h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer，也成为<strong>输出队列</strong>），它用于存储路由器准备发往那条链路的分组。如果到达的分组发现要走的链路还在传输其他分组，那么该分组就必须等待。因此，除了存储转发时延，还有输出缓存的<strong>排队时延</strong>（queuing delay）。</p><p>这些时延是变化的，变化程度取决于网络的拥塞程度。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现<strong>分组丢失（丢包）</strong>（packet loss），到达的分组或已经排队的分组之一将被丢弃。</p><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>每个端系统都有一个IP地址。源在该分组的首部包含了目的地IP地址。</p><p>当一个分组到达路由器时，路由器检查目的地址那部分，并向一台相邻路由器转发该分组。每台路由器具有一个<strong>转发表</strong>（forwarding table）。</p><p>因特网具有一些特殊的<strong>路由选择协议</strong>（routing protocol），用于自动地设置这些转发表。例如，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>（circuit switching）和<strong>分组交换</strong>（packet switching）。</p><p>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。也就是说原则上是不需要等待的。</p><h5 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h5><p>链路中的电路是通过<strong>频分复用</strong>（Frequency-Division Multiplexing, FDM）或<strong>时分复用</strong>（Time-Division Multiplexing, TDM）来实现的。对于FDM，链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段。在电话网络中，这个频段的宽度通常为4kHz（即每秒4000周期）。该频段的宽度称为<strong>带宽</strong>（bandwidth）。调频无线电台也使用FDM来共享88MHz~108MHz的频谱，其中每个电台被分配一个特定的频段。</p><p>对于一条TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙，这些时隙由该连接专门使用，一个时隙（在每个帧内）可用于传输该连接的数据。</p><blockquote><p>考虑从主机A到主机B经一个电路交换网络发送一个640000比特的文件需要多长时间。假如在该网络中所有链路使用具有24时隙的TDM，比特速率为1.536Mbps。同时假定在主机A能够开始传输该文件之前，需要500ms创建一条端到端电路。它需要多长时间才能发送该文件？每条链路具有的传输速率是1. 536Mbps/24 = 64kbps，因此传输该文件需要（640kb）/（64kbps） =10s。这个10s，再加上电路创建时间，这样就需要10.5s发送该文件。值得注意的是，该传输时间与链路数量无关：端到端电路不管是通过一条链路还是100条链路，传输时间都将是10s。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-is-the-Internet&quot;&gt;&lt;a href=&quot;#What-is-the-Internet&quot; class=&quot;headerlink&quot; title=&quot;What is the Internet&quot;&gt;&lt;/a&gt;What is the Internet&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="Computer Networking" scheme="https://preccrep.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>最大流问题</title>
    <link href="https://preccrep.github.io/2021/01/23/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <id>https://preccrep.github.io/2021/01/23/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-23T03:02:48.000Z</published>
    <updated>2021-01-23T04:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最大流问题</strong></p><p>以V为节点集，A为弧集，有向图G = ( V, A ).</p><p>L( i, j )是( i, j )的容量下界，U( i, j )是( i, j )的容量上界。节点 i 对应的权d(i)是顶点 i 的供需量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;最大流问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以V为节点集，A为弧集，有向图G = ( V, A ).&lt;/p&gt;
&lt;p&gt;L( i, j )是( i, j )的容量下界，U( i, j )是( i, j )的容量上界。节点 i 对应的权d(i)是顶点 i 的供需量</summary>
      
    
    
    
    <category term="图论" scheme="https://preccrep.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="最大流" scheme="https://preccrep.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组</title>
    <link href="https://preccrep.github.io/2021/01/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://preccrep.github.io/2021/01/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-08T11:53:01.000Z</published>
    <updated>2021-01-08T11:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-array/">source</a></p><p>题目不难，但是我觉得很有用。</p><p><strong>方法1 — 使用额外数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot;&gt;source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目不难，但是我觉得很有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1 — 使用额外数组&lt;/strong&gt;&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://preccrep.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://preccrep.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>IA-32/Linux下逻辑地址-线性地址-物理地址</title>
    <link href="https://preccrep.github.io/2020/12/26/IA-32-Linux%E4%B8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"/>
    <id>https://preccrep.github.io/2020/12/26/IA-32-Linux%E4%B8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/</id>
    <published>2020-12-26T03:02:29.000Z</published>
    <updated>2020-12-26T03:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>CPU内部的存储器就是寄存器</p><p>分层存储器存在的意义：让存储器又快又大</p><p>存储器越靠近CPU速度越大，容量越小</p><p>局部性原理达到分层的效果</p><p>英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。</p><p>IA-32架构属于复杂指令集，由英特尔公司开发，1985年，随着Intel 80386的上市，被公之于世。接下来20年的时间，虽然后继的新型芯片运算速度不断增加，但IA-32架构大体上都没有改变。对许多编程语言来说，IA-32与i386是同义词。</p><p>英特尔也是世界上最大的IA-32芯片供应商，AMD则是第二大的供应商。2011年，英特尔与AMD同时采用了新的x86-64架构，但是x86架构仍然被应用在如Intel Atom（N2xx与Z5xx系列）、AMD Geode等芯片上。威盛电子生产的VIA C3/C7，也仍然采用IA-32架构。</p><p>IA-32微处理器支持实模式和保护模式。</p><p><strong>实模式</strong></p><p>相当于高性能的16位8086微处理器，但进行了功能扩充，能够使用8086所没有的寻址方式和32位通用寄存器以及大部分指令。不具有保护机制，不能使用部分特权指令。实模式下只有20条地址线有效，存储空间为1MB。</p><p><strong>保护模式</strong></p><p>充分发挥IA-32微处理器的存储管理功能和硬件支持的保护机制，为多任务操作系统设计提供支持。该模式下每个任务的存储空间为4GB。</p><p>在保护模式下还具有一种子模式——虚拟8086模式（V86模式），可以在保护模式的多任务环境中以类似实模式的方式运行16位8086软件。</p><p>按字节编址（通用计算机大都是）</p><p>在<strong>保护模式</strong>下，IA-32采用<strong>段页式虚拟存储</strong>管理方式</p><p>逻辑地址和线性地址是虚拟地址，是编程用的地址；描述的都是4GB虚拟地址空间中的一个存储地址。</p><p>物理地址是访问存储器的地址，是真实地址。</p><blockquote><p>逻辑地址：48位，包含16位段选择符和32位段内偏移量（即<strong>有效地址</strong>）</p><p>线性地址：32位（其位数由虚拟地址空间大小决定）</p><blockquote><p>32位处理器，所以虚拟成32位</p></blockquote><p>物理地址：32位（其位数由存储器总线中的地址线条数决定）</p><blockquote><p>对于物理地址：（实际的不知道）假设就是32位，那外面的物理存储器可能就是4GB(2^32B=4GB)</p></blockquote></blockquote><p><strong><em>分段过程实现   逻辑地址 —&gt; 线性地址</em></strong></p><p><strong><em>分页过程实现    线性地址—&gt;物理地址</em></strong></p><h1 id="逻辑地址到线性地址（分段）"><a href="#逻辑地址到线性地址（分段）" class="headerlink" title="逻辑地址到线性地址（分段）"></a>逻辑地址到线性地址（分段）</h1><p><em>8086处理器的所有内部寄存器都是16位（AX, BX, CX, DX, SP, BP, SI, <strong>CS</strong>, <strong>DS</strong>）</em></p><p>（CS、DS是段寄存器）</p><p><em>8086处理器支持的存储器寻址方式有哪些？</em></p><div class="table-container"><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">位移</td><td style="text-align:center">EA = A</td></tr><tr><td style="text-align:center">基址寻址</td><td style="text-align:center">EA = (B)</td></tr><tr><td style="text-align:center">基址加位移</td><td style="text-align:center">EA = (B) + A</td></tr><tr><td style="text-align:center">比例变址加位移</td><td style="text-align:center">EA = (I) * S + A</td></tr><tr><td style="text-align:center">基址加变址加位移</td><td style="text-align:center">EA = (B) + (I) + A</td></tr><tr><td style="text-align:center">基址加比例变址加位移</td><td style="text-align:center">EA = (B) + (I) * S + A</td></tr></tbody></table></div><blockquote><p>A — 地址段偏移量</p><p>B — 基址寄存器</p><p>I — 变址寄存器（除SP）</p><p>S — 比例因子</p><p>EA — 有效地址</p></blockquote><p>8086指令（AT&amp;T格式）举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw 8(%bp, %dx, 4), %ax   &#x2F;&#x2F;R[ax] &lt;-- M[R[bp] + R[dx]*4 + 8]</span><br></pre></td></tr></table></figure><p>此时的寻址空间是 2^16B = 64KB，太小了！</p><p>于是8086引入段寄存器开辟更大的寻址空间：</p><blockquote><p>16位段寄存器（CS, SS, DS, ES等）</p><p>物理访存地址 = (段寄存器 &lt;&lt; 4) + 有效地址</p></blockquote><p>于是寻址空间变为 1MB了（2^16&lt;&lt; 4 B = 2^20 B = 1MB）</p><p>此时的物理地址称为<strong>线性地址</strong>。</p><p>于是就变成了：</p><div class="table-container"><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">位移</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + A</td></tr><tr><td style="text-align:center">基址寻址</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + (B)</td></tr><tr><td style="text-align:center">基址加位移</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + A</td></tr><tr><td style="text-align:center">比例变址加位移</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + (I) * S + A</td></tr><tr><td style="text-align:center">基址加变址加位移</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + (I) + A</td></tr><tr><td style="text-align:center">基址加比例变址加位移</td><td style="text-align:center">LA = (SR &lt;&lt; 4) + (B) + (I) * S + A</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw [ds:8(%bp, %dx, 4)], %ax   &#x2F;&#x2F;R[ax] &lt;-- M[R[ds]&lt;&lt;4 + R[bp] + R[dx]*4 + 8]</span><br></pre></td></tr></table></figure><p>访问数据段就是和DS绑定的，访问代码段就是和CS绑定的。取指令要用到CS和IP，访问堆栈用到SS，等等。</p><p>物理访存地址 = (段寄存器 &lt;&lt; 4) + 有效地址—<strong>这个访问模式称为实模式！</strong></p><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>8086处理器在实模式下工作：</p><blockquote><p>物理地址直接访存</p><p>可访问 1MB 主存空间</p><p>需要20根地址线（2^20，因为加上了(SR&gt;&gt;4)）</p><p>每次访存必须和某个段寄存器绑定</p></blockquote><p>存在的问题：</p><blockquote><p>寻址空间有限</p><p>存在安全隐患</p></blockquote><p>IA-32，即80386，标志着32位计算机的时代到来。</p><p>所有通用寄存器都是32位，寻址空间达到4GB！</p><p>正式支持虚拟存储器的概念，采用虚拟地址访存。</p><blockquote><p>寻址空间已经达到4GB，是否可以去掉段寄存器？</p><p>不能。考虑兼容性！</p></blockquote><p>于是IA-32处理器支持两种工作模式：</p><blockquote><p>实模式：IA-32处理器加电或复位时处于这一模式，此时相当于8086/8088处理器，32位地址线中的A31~A20不起作用，所有访存地址都是物理地址（实地址）。</p><p>保护模式：完成系统初始化后，进入该模式，此时32位地址线全部起作用，访存地址为逻辑地址（虚拟地址），进入虚拟存储器管理方式。</p></blockquote><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>IA-32有一个”开关”，决定处理器处于哪种模式下：</p><p>CR0寄存器与通用寄存器不同，是另外一种寄存器。它叫控制状态寄存器。</p><blockquote><p>对实模式和保护模式来说看哪一位呢？</p><p><strong>最后一位。（第0位，即PE位）</strong></p></blockquote><p>计算机加电或复位时，PE = 0，IA-32处理器处于实模式。</p><p>PE = 1时，处于保护模式，并且一旦进入保护模式就不能再切换回到实模式了，除非…重启（重新开机复位）。</p><p>（所以只能从实模式进保护模式）</p><p><em>为什么IA-32分段机制更复杂？</em></p><blockquote><p>与历史遗留问题有关：</p><p>寻址空间有限，仅1MB.</p><p>存在安全隐患。</p><p>段大小固定(64KB(2^16 B))</p><p>不灵活，无法设置访问权限。</p><p>……</p></blockquote><p>进入IA-32时代，我们希望段地址也是32位的，还可以灵活设置各种段属性，但段寄存器只有16位，连32位段基址也放不下，怎么办？</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p><strong>段描述符</strong>是用来描述一个段所有属性的数据结构。</p><p>每个段对应一个段描述符。</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201225173007530.png" alt="image-20201225173007530"></p><p>一个段描述符占8个字节（64位），包括：</p><p>B31~B0：32位基地址</p><p>L19~L0：20位限界，表示段的大小</p><p>G：粒度。G = 1以页（4KB）为单位，G = 0以字节为单位。因为界限为20位，故当G = 0时最大的段为1MB；当G = 1时，最大段为4KB*2^20=4GB。</p><p>D：D = 1表示段内偏移量为32位宽，D = 0表示段内偏移量为16位宽。</p><p>P：present. P = 1表示段在主存里，P = 0表示段不在主存里。Linux总把P置1，不会以段为单位淘汰，因为Linux以页为单位。</p><p>S：S = 0表示系统控制描述符，S = 1表示普通的代码段或数据段描述符。</p><p>TYPE：段的访问权限或系统控制描述符类型。</p><p>A：A = 1表示已被访问过，A = 0表示未被访问过（TYPE一般是4位，A是其中的1位）</p><p>DPL：权限位。</p><h3 id="段描述符的组织"><a href="#段描述符的组织" class="headerlink" title="段描述符的组织"></a><strong>段描述符的组织</strong></h3><blockquote><p>（Q represents question, P represents preccrep）</p><p>Q：<em>段描述符占64位，段寄存器才16位，根本放不下，怎么办？</em></p><p>P：放到主存中。</p><p>Q：<em>可是怎么在主存中找到一个段描述符？</em></p><p>P：利用指针。</p><p>Q：<em>IA-32中涉及到地址的，还是32位。所以段描述符的地址也一定是32位的，段寄存器放不下，只能放到主存里。IA-32中的指针也是32位的，段寄存器还是放不下；即使能放下，如果想切换到其他段，怎么知道段描述符在什么地方？</em></p><p>P：把所有的段描述符组织成一个数组啊。</p><p>Q：<em>？</em></p><p>P：段描述符只是一个数据结构，一旦找到段描述符，就能把段的基地址读出来，然后就能访问到相应的段了，问题就解决了。所以关键是怎么找到段描述符。没错，段描述符的地址一定是32位地址，因为它们是放在主存里的。在IA-32里，我们把所有段描述符都组成一个数组，数组索引用16位总能放下吧！用数组索引访问！就是——</p></blockquote><p>IA-32把内存中的某一连续空间解释成一个数组，称为<strong>段描述符表</strong>，简称<strong>段表</strong>。数组中每个元素对应一个段描述符。</p><p>段表由OS负责填写。包括3种类型：</p><blockquote><p>全局描述符表(GDT)：只有一个，是所有进程共享的，用来保存系统中每个任务都可以访问的段描述符，如内核代码段、数据段，用户代码段、数据段等。</p><p>局部描述符表(LDT)：存放某一用户进程专用的描述符（其他用户进程是访问不到的），但LDT不是一个独立的段表，它就保存在GDT中，甚至可以看作是GDT里的一个段描述符。</p><p>中断描述符表(IDT)：独立于GDT的段表，包含中断门、陷阱门等描述符。例如系统调用的函数入口地址就要从IDT中获取。</p></blockquote><p>GDT的首地址由<strong>全局描述符表寄存器（GDTR）</strong>提供。</p><p>GDTR这个寄存器<strong>只存放</strong>GDT的入口地址！</p><p>还有，段表不是一个大数组吗，我们是通过数组索引找到所需的描述符的，而该索引不就保存在段寄存器中吗，它称为<strong>段选择符</strong>。</p><h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a><strong>GDTR</strong></h3><p>GDTR的结构长这样：</p><p>BASE ADDR(基地址)    |   LIMIT(限界)</p><p>32-bit                            |   16-bit</p><p>高32位存放GDT的入口地址，低16位存放GDT的大小。</p><p>当然，GDTR最大也就64位。这里是48位。</p><blockquote><p>Q：<em>GDTR中保存的地址是线性地址，为什么不是逻辑地址？</em></p><p>P：我们分段机制用它(GDTR)不就是为了把逻辑地址变为线性地址吗。要是GDTR中也是逻辑地址，那这个首地址(GDT的首地址)谁来给它变？</p></blockquote><p><strong>GDTR对用户进程不可见</strong>，只有OS才能访问。仅可由OS内核通过一条特权指令(lgdt m16&amp;32)将GDT的首地址和限界装载到GDTR中，启动分段机制。</p><h3 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a><strong>段选择符和段寄存器</strong></h3><blockquote><p>CS(代码段)：程序代码所在段</p><p>SS(栈段)：栈区所在段</p><p>DS(数据段)：全局静态数据区所在段</p><p>其他3个段寄存器ES、GS和FS可指向任意数据段</p></blockquote><h3 id="段选择符各字段含义"><a href="#段选择符各字段含义" class="headerlink" title="段选择符各字段含义"></a><strong>段选择符各字段含义</strong></h3><p>15   14 … 3  |  2   |  1   0</p><p> INDEX         |  TI  |  RPL</p><p>TI = 0，选择GDT；TI = 1，选择LDT。</p><p>RPL请求特权级。</p><p><strong>高13位索引</strong>用来确定当前使用的段描述符在描述表中的位置。</p><p>——&gt; <strong>由此可知，GDT中最多可容纳 2^13=8192=8K 个段描述符。</strong></p><p>那么整个段表多大？（1个段描述符占8个字节）</p><p>8K*8 B = 64KB.</p><p>而段寄存器是16位，2^16 = 64K个字节——刚好相等呀！</p><p>没错，16位就是这么来的。</p><p>于是，回归正题，逻辑地址怎么变到线性地址？</p><p>先看TI位。若TI = 0，那就先从GDTR里把GDT首地址读出来，然后加上索引——注意，是索引乘上8！乘上字节的宽度！基地址+索引*8.</p><p>GDT和IDT只有一个，GDTR和IDTR指向各自起始处。</p><p>LDTR  16-bit</p><p>GDTR, IDTR  48-bit</p><p>每次段寄存器装入新选择符时，新描述符装入描述符cache，在逻辑地址到线性地址转换时，MMU直接用描述符cache中的信息，不必访问主存段表</p><p>LDTR存放LDT描述符的段选择符</p><p>LDT描述符在GDT中</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201225200258987.png" alt="image-20201225200258987"></p><p>总之，逻辑地址转线性地址的过程就是这样：</p><ol><li>逻辑地址高16位是段选择符，低32位是段内偏移。</li><li>通过段寄存器中的段选择符TI位决定在哪个表中查找。</li><li>根据GDTR读出段描述符表的首地址。</li><li>根据段寄存器中的段选择符index位在表中进行索引，找到一个段描述符。</li><li>在段描述符中读出段的基地址，和逻辑地址相加，得到线性地址。</li></ol><p>在计算线性地址的过程中，可根据段描述符中的限界和访问权限判断是否“地址越界”或“访问越权”，以实现存储保护。</p><blockquote><p>Q：<em>索引 为什么乘以8？</em></p><p>P：1个段描述符占8个字节。</p><p>Q：<em>被选中的段描述符存放在什么地方？</em></p><p>P：描述符cache里。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>逻辑地址起作用的<strong>前提</strong>：CR0的PE位为1，进入保护模式，启动分段机制。</li><li>根据<strong>段寄存器中的段选择符</strong>的TI位决定查GDT还是LDT</li><li>在GDTR中读出GDT首地址</li><li>GDT首地址+段选择符中索引*8 — 得到段描述符首地址</li><li>在段描述符中读出段基址，和有效地址（逻辑地址后32位，即段内偏移）相加，得到线性地址</li></ol><p>注意那个前提——否则实模式下有效地址就是线性地址，段寄存器也就用来左移4位加上有效地址得到物理地址了。</p><h1 id="IA-32-Linux中的存储保护"><a href="#IA-32-Linux中的存储保护" class="headerlink" title="IA-32/Linux中的存储保护"></a>IA-32/Linux中的存储保护</h1><h2 id="IA-32的权限检查（基于环保护机制）"><a href="#IA-32的权限检查（基于环保护机制）" class="headerlink" title="IA-32的权限检查（基于环保护机制）"></a>IA-32的权限检查（基于环保护机制）</h2><p>DPL：位于段描述符中，表示一个段所在的特权级别。例如，DPL为3说明该段可能是一个用户段，为0可能是内核段。</p><p>RPL：位于段选择符中，表示请求者所在的特权级别。</p><p>CPL：表示当前进程的特权级别，一般与CS寄存器指向的段描述符的DPL字段相同。</p><p>同时满足以下两个条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_descriptor.DPL &gt;= requestor.RPL   <span class="comment">//请求者有权访问目标段</span></span><br><span class="line">target_descriptor.DPL &gt;= CPL             <span class="comment">//当前进程有权访问目标段</span></span><br></pre></td></tr></table></figure><p>只要OS将GDT、页表等重要信息放在ring0段中，恶意程序将永远无法篡改它们，除非恶意程序获得了OS权限。</p><h2 id="IA-32-Linux中的分段机制"><a href="#IA-32-Linux中的分段机制" class="headerlink" title="IA-32/Linux中的分段机制"></a>IA-32/Linux中的分段机制</h2><p>为能被移植到绝大多数流行处理器平台，Linux简化了分段机制。</p><p>RISC对分段支持非常有限，因此<strong>Linux仅使用IA-32的分页机制</strong>，而对于分段，则通过<strong>在初始化时将所有段描述符的基址设为”0”来简化</strong>。</p><p>每个段都被初始化在 0~4GB 的线性地址空间中。</p><p>PA2中的用户程序都是从 <code>kernel/src/start.S</code> 开始的。PA3也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">#ifndef IA32_SEG</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line"># Set up a stack for C code.</span><br><span class="line">movl $0, %ebp</span><br><span class="line">movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">jmp init# never return</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line"># To understand macros here, see i386 manual.</span><br><span class="line">#define GDT_ENTRY(n) ((n) &lt;&lt; 3)</span><br><span class="line"></span><br><span class="line">#define MAKE_NULL_SEG_DESC   \</span><br><span class="line">.word 0, 0;              \</span><br><span class="line">.byte 0, 0, 0, 0</span><br><span class="line"></span><br><span class="line"># The 0xC0 means the limit is in 4096-byte units</span><br><span class="line"># and (for executable segments) 32-bit mode.</span><br><span class="line">#define MAKE_SEG_DESC(type,base,lim)                        \</span><br><span class="line">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span><br><span class="line">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span><br><span class="line">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><span class="line"></span><br><span class="line">#ifdef IA32_PAGE</span><br><span class="line">#define KOFFSET 0xc0000000</span><br><span class="line">#define va_to_pa(x) (x - KOFFSET)</span><br><span class="line">#else</span><br><span class="line">#define va_to_pa(x) (x)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">lgdt    va_to_pa(gdtdesc) # See i386 manual for more information</span><br><span class="line">movl    %cr0, %eax        # %CR0 |&#x3D; PROTECT_ENABLE_BIT</span><br><span class="line">orl     $0x1, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Complete transition to 32-bit protected mode by using long jmp</span><br><span class="line"># to reload %CS and %EIP.  The segment descriptors are set up with no</span><br><span class="line"># translation, so that the mapping is still the identity mapping.</span><br><span class="line">ljmp    $GDT_ENTRY(1), $va_to_pa(start_cond)</span><br><span class="line"></span><br><span class="line">start_cond:</span><br><span class="line"># Set up the protected-mode data segment registers</span><br><span class="line">movw    $GDT_ENTRY(2), %ax</span><br><span class="line">movw    %ax, %ds          # %DS &#x3D; %AX</span><br><span class="line">movw    %ax, %es          # %ES &#x3D; %AX</span><br><span class="line">movw    %ax, %ss          # %SS &#x3D; %AX</span><br><span class="line"></span><br><span class="line"># Set up a stack for C code.</span><br><span class="line">movl $0, %ebp</span><br><span class="line">movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">jmp init# never return</span><br><span class="line"></span><br><span class="line"># GDT</span><br><span class="line">.p2align 2                    # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">MAKE_NULL_SEG_DESC                   # empty segment</span><br><span class="line">MAKE_SEG_DESC(0xA, 0x0, 0xffffffff)  # code</span><br><span class="line">MAKE_SEG_DESC(0x2, 0x0, 0xffffffff)  # data</span><br><span class="line"></span><br><span class="line">gdtdesc:                      # descriptor</span><br><span class="line">.word   (gdtdesc - gdt - 1)    # limit &#x3D; sizeof(gdt) - 1</span><br><span class="line">.long   va_to_pa(gdt)          # address of GDT</span><br><span class="line"></span><br><span class="line"># end of IA32_SEG</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在来逐段分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef IA32_SEG</span><br></pre></td></tr></table></figure><p>这个是分段的宏，PA2里没考虑分段，也就没用到，所以直接跳到内核里去了。但是在PA3中，这个宏就要起作用了。在 <code>kernel/include/common.h</code> 中设置，把 <code>define IA32_SEG</code> 前的注释符号去掉。</p><blockquote><p>除了 <code>#define</code> 中的 <code>#</code> 外，其他的 <code>#</code> 都是注释！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line"># Set up a stack for C code.</span><br><span class="line">movl $0, %ebp</span><br><span class="line">movl $(128 &lt;&lt; 20), %esp</span><br><span class="line">jmp init# never return</span><br></pre></td></tr></table></figure><p>PA2没用分段（即没用 IA32_SEG 宏，not define，满足 <code>#ifndef</code>），就执行上面的部分；</p><p>PA3用了分段，就执行 <code>#else</code> 的部分.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAKE_NULL_SEG_DESC   \</span><br><span class="line">.word 0, 0;              \</span><br><span class="line">.byte 0, 0, 0, 0</span><br></pre></td></tr></table></figure><p>这个宏是将 <code>MAKE_NULL_SEG_DESC</code> 替换为下面那两个东西…</p><p><code>.word</code> 和 <code>.byte</code> 就是汇编里的声明数据。声明为 <code>.word</code> 就是说那两个0都是 <code>.word</code> 类型，也就是16位宽，所以这里声明了两个16位的0。<code>.byte</code> 声明的是字节，相当于C语言中的 <code>char</code> 类型。2个16位的加上4个8位的，一共就是8个字节。所以——</p><p>这就是一个段描述符！只不过这是一个空的段描述符，因为都是0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define MAKE_SEG_DESC(type,base,lim)                        \</span><br><span class="line">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span><br><span class="line">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span><br><span class="line">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br></pre></td></tr></table></figure><p>这个宏还带参数的啊—— <code>type</code> ，<code>base</code> ，<code>lim</code> ——这不就是段描述符里的信息吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef IA32_PAGE</span><br><span class="line">#define KOFFSET 0xc0000000</span><br><span class="line">#define va_to_pa(x) (x - KOFFSET)</span><br><span class="line">#else</span><br><span class="line">#define va_to_pa(x) (x)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>定没定义PAGE，自己决定用哪个函数。</p><p>最核心的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">lgdt    va_to_pa(gdtdesc) # See i386 manual for more information</span><br><span class="line">movl    %cr0, %eax        # %CR0 |&#x3D; PROTECT_ENABLE_BIT</span><br><span class="line">orl     $0x1, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>再来看这个——<code>lgdt</code> ，将全局描述符表的首地址和大小加载到了GDTR里。这里 <code>va_to_pa</code> 只有1个参数 <code>gdtdesc</code> ，这是一个地址，而由 <code>#define va_to_pa(x) (x)</code> 得知，这不就是 <code>gdtdesc</code> 本身吗。那这到底是什么东西呢，看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdtdesc:                      # descriptor</span><br><span class="line">.word   (gdtdesc - gdt - 1)    # limit &#x3D; sizeof(gdt) - 1</span><br><span class="line">.long   va_to_pa(gdt)          # address of GDT</span><br></pre></td></tr></table></figure><p>嗯，不就是把 <code>gdtdesc</code> 里面的 <code>.word</code> 和 <code>.long</code> 加载过去吗？ <code>.word</code> 是16位的， <code>.long</code> 是32位的。它们是什么注释里都写清楚了，要强调的是 <code>gdtdesc - gdt - 1</code> 的这个减一。</p><p>当然，再看看这个 <code>gdtdesc</code> ，不就刚好是48位吗？没错，<code>lgdt</code> 就是把48位的逻辑地址加载到GDTR中去。</p><p>继续看start的代码。先把CR0的值放到EAX里，然后EAX与1进行OR，再把得到的值放回CR0。我们分析一下，当 “CR0最低位” = 0时，这一番操作使得 “CR0最低位” = 1，这就是实模式 —&gt; 保护模式。</p><h1 id="线性地址到物理地址（分页）"><a href="#线性地址到物理地址（分页）" class="headerlink" title="线性地址到物理地址（分页）"></a>线性地址到物理地址（分页）</h1><h2 id="IA-32中的控制寄存器"><a href="#IA-32中的控制寄存器" class="headerlink" title="IA-32中的控制寄存器"></a>IA-32中的控制寄存器</h2><p>控制寄存器保存机器的各种控制和状态信息，操作系统进行任务控制或存储管理时使用控制寄存器。</p><p><strong>CR0</strong>：PG位：</p><p>1 - 启用分页</p><p>0 - 禁止分页，此时线性地址被直接作为物理地址使用。</p><p>若启用分页机制，PE和PG位都要置1.</p><p><strong>CR2</strong>：页故（page fault）障线性地址寄存器</p><p>当要访问的页不在主存里时，触发了缺页中断，中断处的线性地址保存在CR2里，等到页面被调入后再继续从这里开始执行。</p><p><strong>CR3</strong>：页目录基址寄存器</p><p>保存页目录表的起始地址。</p><p>当然，CR2和CR3有效的前提都是PG = 1。</p><p>Linux中线性地址空间划分：4GB = 1K个子空间 <em> 1K个页面/子空间 </em> 4KB/页</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201226101431856.png" alt="image-20201226101431856"></p><p>每一个页表就是一个子空间，页表中有1K项，每一项对应一个物理页；</p><p>页目录表只有1张，里面有1K个页目录项，每一项对应一个页表。</p><blockquote><p>每1K个页面用一个页表进行组织，每个页表有1K个项，每项对应一个物理页（页框）</p><p>线性地址由3个字段组成，分别是10位页目录索引，10位页表索引，12位页内偏移</p></blockquote><p>CR3中存放的就是页目录表的基地址，拿到基地址后加上DIR*4（为什么乘以4？因为一个页目录项是32位，即4字节），得到相应页表项的首地址。再加上PAGE*4，得到物理页的首地址。物理页首地址再加上页内偏移量，就是真正的物理地址。</p><h2 id="页目录项和页表项的格式"><a href="#页目录项和页表项的格式" class="headerlink" title="页目录项和页表项的格式"></a>页目录项和页表项的格式</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201226105427190.png" alt="image-20201226105427190"></p><p>CPU发出地址先送到MMU，MMU完成分段和分页再送到cache。MMU中的分段解决逻辑地址到物理地址的变换，分页解决线性地址到物理地址的变换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CPU内部的存储器就是寄存器&lt;/p&gt;
&lt;p&gt;分层存储器存在的意义：让存储器又快又大&lt;/p&gt;
&lt;p&gt;存储器越靠近CPU速度越大，容量越小&lt;/p&gt;
&lt;p&gt;局部性原理达到分层的效果&lt;/p&gt;
&lt;p&gt;英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为</summary>
      
    
    
    
    <category term="NEMU" scheme="https://preccrep.github.io/categories/NEMU/"/>
    
    
    <category term="计算机组成原理" scheme="https://preccrep.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://preccrep.github.io/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://preccrep.github.io/2020/12/23/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</id>
    <published>2020-12-23T14:19:38.000Z</published>
    <updated>2020-12-24T05:19:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(tr,tc)是棋盘左上角的方格坐标</span></span><br><span class="line"><span class="comment">(dr,dc)是特殊方格所在坐标</span></span><br><span class="line"><span class="comment">size是棋盘的行数和列数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1025</span></span><br><span class="line"><span class="keyword">int</span> board[N][N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tile = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr, <span class="keyword">int</span> tc, <span class="keyword">int</span> dr, <span class="keyword">int</span> dc, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">int</span> t = tile++; <span class="comment">//L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s = size/<span class="number">2</span>; <span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="comment">//覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        ChessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">//覆盖其余方格</span></span><br><span class="line">        ChessBoard(tr, tc, tr + s - <span class="number">1</span>, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        Chessboard(tr, tc + s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖左下角子棋盘 </span></span><br><span class="line"><span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">ChessBoard(tr + s, tc, dr, dc, s);</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖右上角</span></span><br><span class="line">board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line"><span class="comment">//覆盖其余方格 </span></span><br><span class="line">ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//覆盖右下角子棋盘 </span></span><br><span class="line"><span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &gt;= t c+ s) <span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">ChessBoard(tr + s, tc + s, dr, dc, s);</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//此棋盘中无特殊方格，用t号L型骨牌覆盖左上角 </span></span><br><span class="line">board[tr + s][tc + s] = t;</span><br><span class="line"><span class="comment">//覆盖其余方格 </span></span><br><span class="line">ChessBoard(tr + s, tc + s, tr + s, tc + s, s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k) &#123;  <span class="comment">//k cases</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        board[x][y] = <span class="number">0</span>;</span><br><span class="line">        ChessBoard(<span class="number">0</span>, <span class="number">0</span>, x, y, size);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; board[i][j] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span>^k</span><br><span class="line">需(n-<span class="number">1</span>)/<span class="number">3</span>个L型骨牌填满</span><br><span class="line">算法的时间复杂度: t(n)=<span class="number">4</span>t(n/<span class="number">4</span>)+c</span><br><span class="line">Master <span class="function"><span class="keyword">Method</span>求解得到:</span> t(n)=Theta(n)</span><br></pre></td></tr></table></figure><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a href="https://www.geeksforgeeks.org/merge-sort/">source</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program for Merge Sort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merges two subarrays of arr[].</span></span><br><span class="line"><span class="comment">// First subarray is arr[l..m]</span></span><br><span class="line"><span class="comment">// Second subarray is arr[m+1..r]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n1 = m - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = r - m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create temp arrays</span></span><br><span class="line"><span class="keyword">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy data to temp arrays L[] and R[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">L[i] = arr[l + i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">R[j] = arr[m + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge the temp arrays back into arr[l..r]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial index of first subarray</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial index of second subarray</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial index of merged subarray</span></span><br><span class="line"><span class="keyword">int</span> k = l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line"><span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">arr[k] = L[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = R[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the remaining elements of</span></span><br><span class="line"><span class="comment">// L[], if there are any</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">arr[k] = L[i];</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the remaining elements of</span></span><br><span class="line"><span class="comment">// R[], if there are any</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">arr[k] = R[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l is for left index and r is</span></span><br><span class="line"><span class="comment">// right index of the sub-array</span></span><br><span class="line"><span class="comment">// of arr to be sorted */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//returns recursively</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = (l+r<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr,l,m);</span><br><span class="line">mergeSort(arr,m+<span class="number">1</span>,r);</span><br><span class="line">merge(arr,l,m,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UTILITY FUNCTIONS</span></span><br><span class="line"><span class="comment">// Function to print an array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> arr_size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Given array is \n&quot;</span>;</span><br><span class="line">printArray(arr, arr_size);</span><br><span class="line"></span><br><span class="line">mergeSort(arr, <span class="number">0</span>, arr_size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nSorted array is \n&quot;</span>;</span><br><span class="line">printArray(arr, arr_size);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by Mayank Tyagi</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    QuickSort(a, l, j - <span class="number">1</span>);</span><br><span class="line">    QuickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找第-k-小的元素"><a href="#寻找第-k-小的元素" class="headerlink" title="寻找第 k 小的元素"></a>寻找第 k 小的元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">select</span><span class="params">(T a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r + <span class="number">1</span>;</span><br><span class="line">    T pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span>(a[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span>(a[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> == k) <span class="keyword">return</span> pivot;</span><br><span class="line">    a[l] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    <span class="keyword">if</span>(j - i + <span class="number">1</span> &lt; k)</span><br><span class="line">        select(a, j + <span class="number">1</span>, r, k - j + l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> select(a, l, j - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="距离最接近的点对"><a href="#距离最接近的点对" class="headerlink" title="距离最接近的点对"></a>距离最接近的点对</h2><p><a href="https://blog.csdn.net/sinat_35678407/article/details/82874216">source</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    point() &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> point&amp; A, <span class="keyword">const</span> point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(A.x - B.x, <span class="number">2</span>) + <span class="built_in">pow</span>(A.y - B.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* function: 合并，同第三区域最近点距离比较</span></span><br><span class="line"><span class="comment">* param: points 点的集合</span></span><br><span class="line"><span class="comment">*        dis 左右两边集合的最近点距离</span></span><br><span class="line"><span class="comment">*        mid x坐标排序后，点集合中中间点的索引值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points, <span class="keyword">double</span> dis, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; left, right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].x - points[mid].x &lt;= <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &gt; -dis)</span><br><span class="line">            left.push_back(points[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(points[i].x - points[mid].x &gt; <span class="number">0</span> &amp;&amp; points[i].x - points[mid].x &lt; dis)</span><br><span class="line">            right.push_back(points[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(right.begin(), right.end(), cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, index; i &lt; left.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; right.size() &amp;&amp; left[i].y &lt; right[index].y; index++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span> &amp;&amp; index + j &lt; right.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(left[i], right[j + index]) &lt; dis)</span><br><span class="line">                dis = distance(left[i], right[j + index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">2</span>) <span class="keyword">return</span> distance(points[<span class="number">0</span>], points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(points.size() == <span class="number">3</span>) <span class="keyword">return</span> min(distance(points[<span class="number">0</span>], points[<span class="number">1</span>]), min(distance(points[<span class="number">0</span>], points[<span class="number">2</span>]), distance(points[<span class="number">1</span>], points[<span class="number">2</span>])));</span><br><span class="line">    <span class="keyword">int</span> mid = (points.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d1, d2, d;</span><br><span class="line">    vector&lt;point&gt; left(mid + 1), right(points.size() - mid - 1);</span><br><span class="line">    copy(points.begin(), points.begin() + mid + <span class="number">1</span>, left.begin()); <span class="comment">//左边区域点集合</span></span><br><span class="line">    copy(points.begin() + mid + <span class="number">1</span>, points.end(), right.begin()); <span class="comment">//右边区域点集合</span></span><br><span class="line">    d1 = closest(left);</span><br><span class="line">    d2 = closest(right);</span><br><span class="line">    d = min(d1, d2);</span><br><span class="line">    <span class="keyword">return</span> merge(points, d, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;点个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; points;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个点&quot;</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        points.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(points.begin(), points.end(), cmp_x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最近点对值：%lf&quot;</span>, closest(points));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 <code>n*n</code> 的矩阵 A 与 B 的乘积是另一个 <code>n*n</code> 的矩阵 C，则：进行了 n^3 次乘法和 n^2(n-1) 次加法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;棋盘覆盖问题&quot;&gt;&lt;a href=&quot;#棋盘覆盖问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘覆盖问题&quot;&gt;&lt;/a&gt;棋盘覆盖问题&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="算法" scheme="https://preccrep.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="divide-and-conquer" scheme="https://preccrep.github.io/tags/divide-and-conquer/"/>
    
  </entry>
  
</feed>
