<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"preccrep.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概念物理量有两种表示方法：模拟表示法、数字表示法 模拟量和数字量的主要区别：模拟量&#x3D;连续，数字量&#x3D;离散 数字系统是用来处理逻辑信息或以数字形式表示的物理量的器件组合，即其数值只能取离散值。或称是有一组或几种基本的标准逻辑门来构成的复杂的、使用数字量来传递和加工、处理信息的实际工程系统。 最常见的数字系统：计算机、数字音像及世界上最大的数字系统——手机电话系统 数字逻辑电路是以逻辑门为基本单元构成的">
<meta property="og:type" content="article">
<meta property="og:title" content="数字逻辑基础">
<meta property="og:url" content="https://preccrep.github.io/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Serial">
<meta property="og:description" content="概念物理量有两种表示方法：模拟表示法、数字表示法 模拟量和数字量的主要区别：模拟量&#x3D;连续，数字量&#x3D;离散 数字系统是用来处理逻辑信息或以数字形式表示的物理量的器件组合，即其数值只能取离散值。或称是有一组或几种基本的标准逻辑门来构成的复杂的、使用数字量来传递和加工、处理信息的实际工程系统。 最常见的数字系统：计算机、数字音像及世界上最大的数字系统——手机电话系统 数字逻辑电路是以逻辑门为基本单元构成的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-18T01:25:11.000Z">
<meta property="article:modified_time" content="2021-02-22T06:15:36.000Z">
<meta property="article:author" content="preccrep">
<meta property="article:tag" content="数字逻辑">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://preccrep.github.io/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>数字逻辑基础 | Serial</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Serial" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Serial</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">of or relating to the sequential performance of multiple operations</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">79</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://preccrep.github.io/2021/02/18/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="preccrep">
      <meta itemprop="description" content="serial processing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serial">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数字逻辑基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-18 09:25:11" itemprop="dateCreated datePublished" datetime="2021-02-18T09:25:11+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-22 14:15:36" itemprop="dateModified" datetime="2021-02-22T14:15:36+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">数字逻辑与数字系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>物理量有两种表示方法：<strong>模拟表示法</strong>、<strong>数字表示法</strong></p>
<p>模拟量和数字量的主要区别：模拟量=连续，数字量=离散</p>
<p><strong>数字系统</strong>是用来处理逻辑信息或以数字形式表示的物理量的器件组合，即其数值只能取离散值。或称是<code>有一组或几种基本的标准逻辑门来构成的复杂的、使用数字量来传递和加工、处理信息的实际工程系统</code>。</p>
<p>最常见的数字系统：计算机、数字音像及世界上最大的数字系统——手机电话系统</p>
<p><strong>数字逻辑电路</strong>是以逻辑门为基本单元构成的复杂的数字系统中的硬件部分。</p>
<p><strong>逻辑门</strong>：以能完成<code>独立逻辑功能</code>的一组电子元件和器件所组成的线路。</p>
<p><strong>模拟系统</strong>所包含的装置能处理以模拟形式表示的物理量。</p>
<blockquote>
<p>数字技术的优点：易设计、信息存储方便、操作可编程、数字电路抗干扰能力强、多数数字电路能制造在IC芯片上</p>
<p>数字技术的缺点：</p>
<ol>
<li>由于必须在信息的模拟形式与数字形式之间进行转换，从而增加了系统的复杂性和费用；</li>
<li>数字（二进制数）信号的处理需要时间。所需要的数据越精确，处理时间越长。</li>
</ol>
</blockquote>
<p>当涉及到模拟输入、输出时，为了利用数字技术的优点，必须采用下面3步：</p>
<ol>
<li>把实际中的模拟输入转换为数字形式；</li>
<li>数字信息处理；</li>
<li>把数字输出变换为模拟输出。</li>
</ol>
<p>原则：随着信号在系统中的流动，在输入通道中尽可能早地把信号数字化，在输出通道中尽可能晚地把信号转换为模拟信号。</p>
<h1 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h1><h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>不同进位计数制的数值具有等值关系：</p>
<script type="math/tex; mode=display">
N=N_{10}=(N)_{10}=N_S=(M)_S=N_T=(K)_T</script><p>其中M是十进制数N的S进制形式，K是N的T进制形式。</p>
<p>也就是说，加了括号的括号内一定是转换数制后的数，不加括号就是原来的十进制数。例如：</p>
<script type="math/tex; mode=display">
13=(13)_{10}=13_8=(15)_8=(1101)_2</script><p>数值转换时小数位数的确定：</p>
<script type="math/tex; mode=display">
\alpha 进制的小数有k位，转换为\beta进制后，至少具有相同精度的小数是j位，则
(0.1)_{\alpha}^k \geq (0.1)_{\beta}^j.</script><script type="math/tex; mode=display">
在十进制中可表示为：(\frac{1}{\alpha})^k \geq (\frac{1}{\beta})^j.</script><script type="math/tex; mode=display">
即：\alpha^k \leq \beta^j</script><script type="math/tex; mode=display">
两边取对数：\log\alpha^k \leq \log\beta^j，即k\log\alpha \leq j\log\beta</script><script type="math/tex; mode=display">
得到：j \geq k\frac{\log\alpha}{\log\beta}</script><script type="math/tex; mode=display">
则j满足的不等式条件为：k\frac{\log\alpha}{\log\beta} \leq j < k\frac{\log\alpha}{\log\beta}+1</script><h2 id="数的表示和运算"><a href="#数的表示和运算" class="headerlink" title="数的表示和运算"></a>数的表示和运算</h2><p>计算机中表示小数点位置的方法通常有两种：定点表示法和浮点表示法。</p>
<h3 id="定点表示法"><a href="#定点表示法" class="headerlink" title="定点表示法"></a>定点表示法</h3><p>小数点位置固定，一般固定在数的最高位之前或最低位之后。</p>
<h3 id="浮点表示法"><a href="#浮点表示法" class="headerlink" title="浮点表示法"></a>浮点表示法</h3><p>例如，二进制数101.1和10.11可表示为：</p>
<script type="math/tex; mode=display">
101.1=(10)^{11}\times0.1011</script><script type="math/tex; mode=display">
10.11=(10)^{10}\times0.1011</script><p>其中10和11是二进制数，转换为十进制就是2和3.</p>
<p>因此，这两个二进制数可以用<strong>阶码</strong>和<strong>尾数</strong>表示：</p>
<script type="math/tex; mode=display">
101.1\rightarrow11, 0.1011</script><script type="math/tex; mode=display">
10.11\rightarrow10, 0.1011</script><p>这就是浮点表示法。表示时需要将一个字长划分为两部分，分别用来表示阶码和尾数，<strong>两个部分的最高位分别为各自的符号位</strong>。</p>
<p>例如，规定一个16位字长的前5位表示阶码，后11位表示尾数：</p>
<p><code>0    0011        0    1011000000</code></p>
<p><code>0    0010        0    1011000000</code></p>
<p><strong>原码</strong>：符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。</p>
<p>因为第一位是符号位, 所以8位二进制数的取值范围就是[-127, 127]</p>
<p><strong>反码</strong>：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p>
<p><strong>补码</strong>：正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1（即在反码的基础上+1）。</p>
<p>一篇可参考的博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">戳这</a></p>
<h3 id="可靠性编码"><a href="#可靠性编码" class="headerlink" title="可靠性编码"></a>可靠性编码</h3><p>目的：解决代码在形成或传输过程中可能会发生的错误，提高系统的安全性</p>
<p>方法：使代码自身具有一种特征或能力</p>
<h4 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h4><p>任意两个相邻数的代码只有一位二进制数不同</p>
<blockquote>
<p>格雷码(Gray code)是1880年由法国工程师Jean-Maurice-Emlle Baudot发明的一种编码，是一种绝对编码方式，典型格雷码是一种具有反射特性和循环特性的单步自补码，它的循环、单步特性消除了随机取数时出现重大误差的可能，它的反射、自补特性使得求反非常方便。格雷码属于可靠性编码，是一种错误最小化的编码方式，因为，虽然自然二进制码可以直接由数/模转换器转换成模拟信号，但在某些情况，例如从十进制的3转换为4时二进制码的每一位都要变，能使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它在相邻位间转换时，只有一位产生变化。它大大地减少了由一个状态到下一个状态时逻辑的混淆。由于这种编码相邻的两个码组之间只有一位不同，引起数字量发生变化时，格雷码仅改变一位，这样与其它编码同时改变两位或多位的情况相比更为可靠，即可减少出错的可能性。</p>
</blockquote>
<p> 格雷码是一个数列集合，相邻两数间只有一个位元改变，为无权数码，且格雷码的顺序不是唯一的。</p>
<p>例如以下为3位元的格雷码： 000 001 011 010 110 111 101 100 。</p>
<p>如果要产生n位元的格雷码，那么格雷码的个数为$2^n$.</p>
<p>假设原始的值从0开始，格雷码产生的规律是：</p>
<p>第一步，改变最右边的位元值；</p>
<p>第二步，改变右起第一个为1的位元的左边位元；</p>
<p>第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了$2^n -1$步）。</p>
<p>用一个例子来说明：</p>
<p>假设产生3位元的格雷码，原始值位 000</p>
<p>第一步：改变最右边的位元值： 001</p>
<p>第二步：改变右起第一个为1的位元的左边位元： 011</p>
<p>第三步：改变最右边的位元值： 010</p>
<p>第四步：改变右起第一个为1的位元的左边位元： 110</p>
<p>第五步：改变最右边的位元值： 111</p>
<p>第六步：改变右起第一个为1的位元的左边位元： 101</p>
<p>第七步：改变最右边的位元值： 100</p>
<p>如果按照这个规则来生成格雷码，是没有问题的，但是这样做太复杂了。如果仔细观察格雷码的结构，我们会有以下发现：</p>
<ol>
<li><p>除了最高位（左边第一位），格雷码的位元完全上下对称（看下面列表）。比如第一个格雷码与最后一个格雷码对称（除了第一位），第二个格雷码与倒数第二个对称，以此类推。</p>
</li>
<li><p><strong>最小的重复单元是 0 , 1</strong>。</p>
</li>
</ol>
<blockquote>
<p>0<strong>00</strong></p>
<p>0<strong>01</strong></p>
<p>…</p>
<p>1<strong>01</strong></p>
<p>1<strong>00</strong></p>
</blockquote>
<p>所以，在实现的时候，我们完全可以利用递归，在每一层前面加上0或者1，然后就可以列出所有的格雷码。</p>
<p>比如：</p>
<p>第一步：产生 0, 1 两个字符串。</p>
<p>第二步：在第一步的基础上，每一个字符串都加上0和1，但是每次只能加一个，所以得做两次。这样就变成了 00,01,11,10 （注意对称）。</p>
<p>第三步：在第二步的基础上，再给每个字符串都加上0和1，同样，每次只能加一个，这样就变成了 000,001,011,010,110,111,101,100。</p>
<p>好了，这样就把3位元格雷码生成好了。</p>
<p>如果要生成4位元格雷码，我们只需要在3位元格雷码上再加一层0,1就可以了： 0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1110,1010,0111,1001,1000.</p>
<p>也就是说，<em>n位元格雷码是基于n-1位元格雷码产生的</em>。</p>
<p><strong>格雷码和自然二进制码之间的转换方法</strong></p>
<p>自然二进制码转换成二进制格雷码，其法则是保留自然二进制码的最高位作为格雷码的最高位，而次高位格雷码为二进制码的高位与次高位相异或，而格雷码其余各位与次高位的求法相类似。</p>
<p><strong>原理:</strong> 若二进制码表示为：<code>B[N-1]B[N-2]...B[2]B[1]B[0]</code>；</p>
<p>则二进制格雷码表示为：<code>G[N-1]G[N-2]...G[2]G[1]G[0]</code>.</p>
<p>其中最高位保留：<code>G[N-1] = B[N-1]</code>；</p>
<p>其他各位：<code>G[i] = B[i+1] xor B[i]. (i = 0, 1, 2, ..., n-2)</code></p>
<p><strong>格雷码转换为二进制码的实现方法</strong></p>
<p>二进制格雷码转换成自然二进制码，其法则是保留格雷码的最高位作为自然二进制码的最高位，而次高位自然二进制码为高位自然二进制码与次高位格雷码相异或，而自然二进制码的其余各位与次高位自然二进制码的求法相类似。</p>
<p><strong>原理:</strong> 若二进制格雷码表示为：<code>G[N-1]G[N-2]...G[2]G[1]G[0]</code>；</p>
<p>相应地, 则二进制码表示为：<code>B[N-1]B[N-2]...B[2]B[1]B[0]</code>.</p>
<p>其中最高位保留：<code>B[N-1] = G[N-1]</code>；</p>
<p>其他各位：<code>B[i-1] = G[i-1] xor B[i]. (i = 1, 2, ..., n-1)</code></p>
<p>算法实现：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/0201zcr/p/4796950.html">参考链接</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] GrayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n)];</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] b = GrayCode(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        arr[i] = <span class="string">&quot;0&quot;</span> + b[i];</span><br><span class="line">        arr[arr.length - <span class="number">1</span> - i] = <span class="string">&quot;1&quot;</span> + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] GrayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n);</span><br><span class="line">    String[] s1 = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">        String[] si = <span class="keyword">new</span> String[p];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; p/<span class="number">2</span>)</span><br><span class="line">                si[j] = <span class="string">&quot;0&quot;</span> + s1[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                si[j] = <span class="string">&quot;1&quot;</span> + s1[p - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = si;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<strong>典型格雷码</strong>（0~15）还有一个特点：所有对应于十进制数$2^m-1$的格雷码，都仅在m位上有1，其余位都为0.</p>
<p>例如：m=1，1的典型格雷码为0001；m=2，3的典型格雷码为0010；m=3，7的典型格雷码为0100；m=4，15的典型格雷码为1000.</p>
<p>15与0的格雷码仍能保持一位差别，所以这种典型格雷码也称作循环码，适用于做二进制码计数器。</p>
<p><strong>十进制格雷码</strong>（0~9）：代码特征符合格雷码要求，且16选10，使得9到0也只有一位的差别，保持循环码特点。</p>
<h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/FZfangzheng/p/8519791.html">戳这</a></p>
<p><strong>奇偶校验码</strong></p>
<p>参考博客1：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dushikang/p/8334776.html">戳这</a></p>
<p>参考博客2：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44574333/article/details/108927425">戳这</a></p>
<p>视频链接地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BE411D7ii?from=search&amp;seid=6420326887479343502">戳这</a></p>
<blockquote>
<p>问题：</p>
<ul>
<li>奇偶校验码能发现单错，但不能对单错定位；</li>
<li>奇偶校验码不能发现双错.</li>
</ul>
</blockquote>
<p><strong>海明校验码</strong></p>
<p>参考博客1：<a target="_blank" rel="noopener" href="https://blog.csdn.net/coolskyying/article/details/78963550">戳这</a></p>
<p>参考博客2：<a target="_blank" rel="noopener" href="https://my.oschina.net/u/3374461/blog/1931270">戳这</a></p>
<p>海明码（Hamming Code）是利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的确定位置插入k个校验位，通过扩大码距来实现检错和纠错。对于m位的数据，加入k位的校验码，它应满足：$m+k+1&lt;2^k$.</p>
<h1 id="逻辑代数"><a href="#逻辑代数" class="headerlink" title="逻辑代数"></a>逻辑代数</h1><ol>
<li><p>布尔代数：用一种数学运算来描述人的逻辑思维规律和推理过程的代数系统.</p>
</li>
<li><p>逻辑代数：将布尔代数的一些基本前提和定理应用于继电器电路的分析与描述。即开关代数，也就是二值布尔代数.</p>
</li>
<li><p>逻辑变量：用于表示事物的逻辑状态随逻辑条件的变化而变化的量，取值：0或1.</p>
</li>
<li><p>逻辑常量：逻辑状态保持不变，值为0或1.</p>
</li>
<li><p>逻辑电路：由实现逻辑变量之间逻辑关系的物理器件所构成的电路称为逻辑电路，即二值逻辑电路.</p>
</li>
<li><p>逻辑电平：在二值逻辑电路即开关电路中，将物理器件的物理量离散为两种电平.</p>
<blockquote>
<p>噪音区：在高、低电平之间有一逻辑不确定区。若电平稳定于噪音区称为逻辑模糊，这在逻辑电路中不允许。</p>
<p>一般用H表示高电平，用L表示的低电平</p>
<p>抽象化的高、低电平忽略了其物理量值的实际含义，实际上它们是代表着一定范围的物理量。</p>
</blockquote>
</li>
<li><p>逻辑状态：事物的某些特性表现为两种互不相容的状态，即<br>① 某一时刻必出现且仅出现一种状态；<br>② 一种状态是另一种状态的反状态.</p>
<p>用0、1表示，两种状态无大小之分.</p>
</li>
<li><p>逻辑约定：规定逻辑电平（表示物理器件的物理量）与逻辑状态（表示物理器件的功能）之间的关系，即逻辑规定。这一规定的过程称为逻辑化过程。<br>逻辑规定有两种：正逻辑规定和负逻辑规定。</p>
</li>
<li><p>逻辑函数：输入逻辑变量 $A_1, A_2, …, A_n$，输出逻辑变量F，记为 $F = f(A_1, A_2, …, A_n)$。</p>
<p>逻辑函数的表示法：真值表、逻辑表达式、卡诺图、时间图</p>
</li>
</ol>
<h2 id="逻辑代数的运算"><a href="#逻辑代数的运算" class="headerlink" title="逻辑代数的运算"></a>逻辑代数的运算</h2><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>”与“运算（逻辑乘，Logic Multiplication），运算结果是逻辑积（Logic Product）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>”与“运算（逻辑乘, Logic Multiplication）</th>
<th>”或“运算（逻辑加, Logic Addition）</th>
<th>”非“运算（逻辑乘, Logic Negation）</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算结果</td>
<td>逻辑积(Logic Product)</td>
<td>逻辑和(Logic Sum)</td>
<td>求补(Complement)</td>
</tr>
<tr>
<td>代数式</td>
<td>$F=A\times B=A\cdot B$</td>
<td>$F=A+B$</td>
<td>$F=\overline{A}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑代数的基本公理"><a href="#逻辑代数的基本公理" class="headerlink" title="逻辑代数的基本公理"></a>逻辑代数的基本公理</h3><p><strong>0-1律</strong></p>
<blockquote>
<p>$A+0=A$</p>
<p>$A+1=1$</p>
<p>$A\cdot 1=A$</p>
<p>$A\cdot 0=0$</p>
</blockquote>
<p>与、或运算满足交换律、结合律、分配律。</p>
<p>互补律：$A+\overline{A}=1$, $A\cdot \overline{A}=0$</p>
<p>重叠律：$A+A=A$, $A\cdot A=A$</p>
<p>对合律：$\overline{\overline{A}}=A$</p>
<h3 id="逻辑代数的基本定理"><a href="#逻辑代数的基本定理" class="headerlink" title="逻辑代数的基本定理"></a>逻辑代数的基本定理</h3><p><strong>吸收定理</strong></p>
<blockquote>
<p>$A+AB=A$</p>
<p>$A\cdot (A+B)=A$</p>
<p>$A+\overline{A} \cdot B=A+B$</p>
<p>$A\cdot (\overline{A}+B)=A\cdot B$</p>
<p>$A\cdot B+A\cdot \overline{B}=A$</p>
<p>$(A+B)(A+\overline{B})=A$</p>
</blockquote>
<p><strong>反演定理</strong></p>
<blockquote>
<p>$\overline{A_1+A_2+\dots +A_n}=\overline{A_1}\cdot \overline{A_2}\cdot \dots \overline{A_n}$</p>
<p>$\overline{A_1\cdot A_2\cdot \dots \cdot A_n}=\overline{A_1}+ \overline{A_2}+ \dots \overline{A_n}$</p>
</blockquote>
<p><strong>包含定理(多余项定理)</strong></p>
<script type="math/tex; mode=display">
AB+\overline{A} C+BC=AB+\overline{A} C</script><script type="math/tex; mode=display">
(A+B)(\overline{A}+C)(B+C)=(A+B)(\overline{A}+C)</script><blockquote>
<p>证明：$AB+\overline{A} C+BC=AB+\overline{A} C$</p>
<script type="math/tex; mode=display">
AB+\overline{A} C+BC=(A+C)B+\overline{A}C=(A+\overline{A}C)B+\overline{A}C=AB+\overline{A}C(B+1)=AB+\overline{A}C\cdot 1=AB+\overline{A}C</script></blockquote>
<h3 id="逻辑代数的基本规则"><a href="#逻辑代数的基本规则" class="headerlink" title="逻辑代数的基本规则"></a>逻辑代数的基本规则</h3><p><strong>代入规则</strong></p>
<p>已知 $f(x_1,x_2,\dots ,x_i,\dots ,x_n)=g(x_1,x_2,\dots ,x_i,\dots ,x_n)$，有任意函数h，令$x_i=h$，则 $f(x_1,x_2,\dots ,h,\dots ,x_n)=g(x_1,x_2,\dots ,h,\dots ,x_n)$依然成立。</p>
<blockquote>
<p>证明：</p>
<script type="math/tex; mode=display">
\because x_i\in \{0,1\}且逻辑函数h取值仅有0或1</script><script type="math/tex; mode=display">
\therefore 带入规则成立</script></blockquote>
<p>可以用带入规则证明N变量的德摩根定理。</p>
<p><strong>反演规则</strong></p>
<p>已知原函数 $f(x_1,x_2,\dots ,x_n,0,1,+,\cdot)$，则反函数 $\overline{f}(x_1,x_2,\dots ,x_n,0,1,+,\cdot)=f(\overline{x_1},\overline{x_2},\dots ,\overline{x_n},1,0,\cdot ,+)$</p>
<p><strong>对偶规则</strong></p>
<p>已知原函数 $f(x_1,x_2,\dots ,x_n,0,1,+,\cdot)$，则对偶函数 $f’(x_1,x_2,\dots ,x_n,0,1,+,\cdot)=f(x_1,x_2,\dots ,x_n,1,0,\cdot ,+)$</p>
<p>如果原函数相等，则对偶函数也相等。</p>
<h3 id="复合运算"><a href="#复合运算" class="headerlink" title="复合运算"></a>复合运算</h3><p><strong>与非（NAND）</strong>：$F=\overline{A\cdot B\cdot C}$</p>
<p>可以用与非门实现三种基本运算：</p>
<p>与运算：$F_1=A\cdot B=\overline{\overline{A\cdot B}}$</p>
<p>非运算：$F_2=\overline{A\cdot A}=\overline{A}$</p>
<p>或运算：$F_3=\overline{\overline{A\cdot A}\cdot \overline{B\cdot B}}=\overline{\overline{A}\cdot \overline{B}}=A+B$</p>
<p><strong>或非（NOR）</strong>：$F=\overline{A+B+C}$</p>
<p>可以用或非门实现三种基本运算：</p>
<p>与运算：$F_1=\overline{\overline{A+A}+\overline{B+B}}=\overline{\overline{A}+\overline{B}}=A\cdot B$</p>
<p>非运算：$F_2=\overline{A+A}=\overline{A}$</p>
<p>或运算：$F_3=\overline{\overline{A+B}}$</p>
<p><strong>与或非（AOI）</strong>：$F=\overline{AB+CD+EF}$</p>
<p><strong>异或（XOR）</strong>：$F=A\oplus B=\overline{A}\cdot B+A\cdot \overline{B}$</p>
<p><strong>同或（XNOR）</strong>：$F=A\odot B=A\cdot B+\overline{A}\cdot\overline{B}$</p>
<blockquote>
<p>异或和同或的关系：</p>
<p>$\overline{A\oplus B}=A\odot B$        $\overline{A\odot B}=A\oplus B$</p>
<p>$(A\oplus B)‘=A\odot B$        $(A\odot B)‘=A\oplus B$（用对偶函数的运算性质证明）</p>
<p>$A\oplus B\oplus C=A\odot B\odot C$</p>
<p>证明  $(A\oplus B)‘=A\odot B$</p>
<script type="math/tex; mode=display">
(A\oplus B)'=(\overline{A}\cdot B+A\cdot\overline{B})'=(\overline{A}+B)\cdot(A+\overline{B})=AB+\overline{A}\overline{B}=A\odot B</script></blockquote>
<p>由带入规则可以证明：</p>
<p>当变量<strong>n为偶数</strong>时，XOR和XNOR具有互补关系：</p>
<script type="math/tex; mode=display">
A_1\oplus A_2\oplus\dots\oplus A_n=\overline{A_1\odot A_2\odot\dots\odot A_n}</script><p>当变量<strong>n为奇数</strong>时，XOR和XNOR具有相等关系：</p>
<script type="math/tex; mode=display">
A_1\oplus A_2\oplus\dots\oplus A_n=A_1\odot A_2\odot\dots\odot A_n</script><h2 id="逻辑函数的标准形式"><a href="#逻辑函数的标准形式" class="headerlink" title="逻辑函数的标准形式"></a>逻辑函数的标准形式</h2><p><strong>最小项之和</strong>：乘积项之和称为<em>积之和表达式（SOP）</em>，或称<em>与或表达式</em>。如果构成函数的积之和表达式中每一个与项均为最小项时，称为最小项标准式，且这种表示是唯一的。</p>
<p><strong>最大项之积</strong>：和项之积称为<em>和之积表达式（POS）</em>，或称<em>或与表达式</em>。如果构成函数的和之积表达式中每一个和项均为最大值，称为最大项标准式，且这种表示是唯一的。</p>
<p><strong>最小项minterm</strong>：设有n个变量，它们组成的与项中每个变量或以原变量或以反变量形式出现一次，且仅出现一次，此与项称之为n个变量的最小项。对于n个变量就可构成 $2^n$ 个最小项，记为 $m_i$.<br>其中下标值i：当各最小项变量按一定顺序排好后，用1代替其中的原变量，0代替其中的反变量，便得一个二进制数，该二进制数的等值十进制即为i的值。</p>
<p>例如$\overline{A}B\overline{C}=m_{(010)_2}=m_2$</p>
<p>为了区别不同n值对应的相同的 $m_i$，可记为 $m_i^n$.</p>
<p><strong>最大项maxterm</strong>：与最小项相反，用0代替原变量，1代替反变量，例如：$\overline{A}+B+\overline{C}=M_5$</p>
<p><strong>性质</strong>：</p>
<ol>
<li><p>对于任意最小项，只有一组变量组合取值可使其值为1；对于任意最大项，只有一组变量组合取值可使其值为0.</p>
</li>
<li><script type="math/tex; mode=display">
n变量的所有最小项的和必为1，记为\sum_{i=0}^{2^n-1} m_i=1.</script><script type="math/tex; mode=display">
n变量的所有最大项的积必为0，记为\prod_{i=0}^{2^n-1} M_i=0.</script></li>
<li><p>任意两个最小项之积必为0，即：$m_i\cdot m_j=0, i\neq j$.</p>
<p>任意两个最大项之和必为1，即：$M_i+M_j=1, i\neq j$.</p>
</li>
<li><p>同变量数（n相同）下标相同的最小项和最大项互为反函数，即 $m_i=\overline{M_i}$，$M_i=\overline{m_i}$.</p>
<p>则 $m_i\cdot M_i=0$，$m_i+M_i=1$.</p>
</li>
</ol>
<p><strong>最小项与原、反函数的关系</strong>：对于n个变量的函数F，它共有 $2^n$ 个最小项，这些最小项不是包含在原函数 $F$ 的最小项表达式中，就是包含在反函数 $\overline{F}$ 的最小项表达式中。</p>
<p><strong>最大项与原、反函数的关系</strong>：对于n个变量的函数F，它共有 $2^n$ 个最大项，这些最大项不是包含在原函数 $F$ 的最大项表达式中，就是包含在反函数 $\overline{F}$ 的最大项表达式中。</p>
<p><strong>同一函数的最小项标准式与其最大项标准式的关系</strong>：</p>
<script type="math/tex; mode=display">
F=\sum m^3(0,2,3)=\prod M^3(1,4,5,6,7)</script><blockquote>
<p>证明：设 $F=\sum m^3(0,2,3)$，则</p>
<script type="math/tex; mode=display">
\overline{F}=\sum m^3(1,4,5,6,7)=m_1+m_4+m_5+m_6+m_7</script><script type="math/tex; mode=display">
F=\overline{\overline{F}}=\overline{m_1+m_4+m_5+m_6+m_7}=M_1\cdot M_4\cdot M_5\cdot M_6\cdot M_7=\prod M^3(1,4,5,6,7)</script></blockquote>
<p><strong>卡诺图</strong></p>
<p>卡诺图是一种<em>平面方格阵列图</em>：</p>
<p>行和列按变量的组合标注，其变量顺序按真值表中输入变量从左至右的顺序，并且行与列坐标按变量组合的二进制格雷码的顺序而小方格左上角标注可用十进制数表示，该数对应最小项。</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31649253">戳这</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" rel="tag"># 数字逻辑</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/10/I/" rel="prev" title="Note for Computer Networking, Chapter I">
      <i class="fa fa-chevron-left"></i> Note for Computer Networking, Chapter I
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="next" title="计算机网络基本概念">
      计算机网络基本概念 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.</span> <span class="nav-text">数的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.</span> <span class="nav-text">进制表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">数的表示和运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">定点表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">浮点表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.3.</span> <span class="nav-text">可靠性编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E9%9B%B7%E7%A0%81"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">格雷码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">校验码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">逻辑代数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.</span> <span class="nav-text">逻辑代数的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%AC%E7%90%86"><span class="nav-number">3.1.2.</span> <span class="nav-text">逻辑代数的基本公理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86"><span class="nav-number">3.1.3.</span> <span class="nav-text">逻辑代数的基本定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">3.1.4.</span> <span class="nav-text">逻辑代数的基本规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.5.</span> <span class="nav-text">复合运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">逻辑函数的标准形式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">preccrep</p>
  <div class="site-description" itemprop="description">serial processing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">preccrep</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
